{
  "variants": [
    {
      "order_code": "ATtiny814-SSFR",
      "package": "SOIC14",
      "pinout": "SOIC14",
      "speed_max": 20000000,
      "temp_max": 125,
      "temp_min": -40,
      "vcc_max": 5.5,
      "vcc_min": 1.8
    },
    {
      "order_code": "ATtiny814-SSNR",
      "package": "SOIC14",
      "pinout": "SOIC14",
      "speed_max": 20000000,
      "temp_max": 105,
      "temp_min": -40,
      "vcc_max": 5.5,
      "vcc_min": 1.8
    },
    {
      "order_code": "ATtiny814-SSNRES",
      "package": "SOIC14",
      "pinout": "SOIC14",
      "speed_max": 20000000,
      "temp_max": 105,
      "temp_min": -40,
      "vcc_max": 5.5,
      "vcc_min": 1.8
    }
  ],
  "pinouts": [
    {
      "name": "SOIC14",
      "pins": [
        {
          "pad": "VDD",
          "position": 1
        },
        {
          "pad": "PA4",
          "position": 2
        },
        {
          "pad": "PA5",
          "position": 3
        },
        {
          "pad": "PA6",
          "position": 4
        },
        {
          "pad": "PA7",
          "position": 5
        },
        {
          "pad": "PB3",
          "position": 6
        },
        {
          "pad": "PB2",
          "position": 7
        },
        {
          "pad": "PB1",
          "position": 8
        },
        {
          "pad": "PB0",
          "position": 9
        },
        {
          "pad": "PA0",
          "position": 10
        },
        {
          "pad": "PA1",
          "position": 11
        },
        {
          "pad": "PA2",
          "position": 12
        },
        {
          "pad": "PA3",
          "position": 13
        },
        {
          "pad": "GND",
          "position": 14
        }
      ]
    }
  ],
  "devices": [
    {
      "name": "ATtiny814",
      "modules": [
        {
          "name": "AC",
          "instances": [
            {
              "name": "AC0",
              "signals": [
                {
                  "function": "AC0",
                  "group": "N",
                  "index": 0,
                  "pad": "PA6"
                },
                {
                  "function": "AC0",
                  "group": "OUT",
                  "index": 0,
                  "pad": "PA5"
                },
                {
                  "function": "AC0",
                  "group": "P",
                  "index": 0,
                  "pad": "PA7"
                }
              ]
            }
          ]
        },
        {
          "name": "ADC",
          "instances": [
            {
              "name": "ADC0",
              "signals": [
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 4,
                  "pad": "PA4"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 5,
                  "pad": "PA5"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 6,
                  "pad": "PA6"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 7,
                  "pad": "PA7"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 10,
                  "pad": "PB1"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 11,
                  "pad": "PB0"
                }
              ]
            }
          ]
        },
        {
          "name": "BOD",
          "instances": [
            {
              "name": "BOD",
              "signals": null
            }
          ]
        },
        {
          "name": "CCL",
          "instances": [
            {
              "name": "CCL",
              "signals": [
                {
                  "function": "CCL",
                  "group": "LUT0_IN",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "CCL",
                  "group": "LUT0_IN",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "CCL",
                  "group": "LUT0_IN",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "CCL",
                  "group": "LUT0_OUT",
                  "index": 0,
                  "pad": "PA4"
                },
                {
                  "function": "CCL",
                  "group": "LUT1_OUT",
                  "index": 0,
                  "pad": "PA7"
                }
              ]
            }
          ]
        },
        {
          "name": "CLKCTRL",
          "instances": [
            {
              "name": "CLKCTRL",
              "signals": [
                {
                  "function": "CLKCTRL",
                  "group": "CLKI",
                  "index": null,
                  "pad": "PA3"
                },
                {
                  "function": "CLKCTRL",
                  "group": "TOSC1",
                  "index": null,
                  "pad": "PB3"
                },
                {
                  "function": "CLKCTRL",
                  "group": "TOSC2",
                  "index": null,
                  "pad": "PB2"
                }
              ]
            }
          ]
        },
        {
          "name": "CPU",
          "instances": [
            {
              "name": "CPU",
              "signals": [
                {
                  "function": "BREAK",
                  "group": "BREAK",
                  "index": null,
                  "pad": "PA1"
                }
              ]
            }
          ]
        },
        {
          "name": "CPUINT",
          "instances": [
            {
              "name": "CPUINT",
              "signals": null
            }
          ]
        },
        {
          "name": "CRCSCAN",
          "instances": [
            {
              "name": "CRCSCAN",
              "signals": null
            }
          ]
        },
        {
          "name": "DAC",
          "instances": [
            {
              "name": "DAC0",
              "signals": [
                {
                  "function": "DAC0",
                  "group": "OUT",
                  "index": 0,
                  "pad": "PA6"
                }
              ]
            }
          ]
        },
        {
          "name": "EVSYS",
          "instances": [
            {
              "name": "EVSYS",
              "signals": [
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 4,
                  "pad": "PA4"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 5,
                  "pad": "PA5"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 6,
                  "pad": "PA6"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 7,
                  "pad": "PA7"
                },
                {
                  "function": "EVAINCH1",
                  "group": "EVAPB",
                  "index": 0,
                  "pad": "PB0"
                },
                {
                  "function": "EVAINCH1",
                  "group": "EVAPB",
                  "index": 1,
                  "pad": "PB1"
                },
                {
                  "function": "EVAINCH1",
                  "group": "EVAPB",
                  "index": 2,
                  "pad": "PB2"
                },
                {
                  "function": "EVAINCH1",
                  "group": "EVAPB",
                  "index": 3,
                  "pad": "PB3"
                },
                {
                  "function": "EVSYS",
                  "group": "EVOUT",
                  "index": 0,
                  "pad": "PA2"
                },
                {
                  "function": "EVSYS",
                  "group": "EVOUT",
                  "index": 1,
                  "pad": "PB2"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 4,
                  "pad": "PA4"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 5,
                  "pad": "PA5"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 6,
                  "pad": "PA6"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 7,
                  "pad": "PA7"
                },
                {
                  "function": "EVSINCH1",
                  "group": "EVSPB",
                  "index": 0,
                  "pad": "PB0"
                },
                {
                  "function": "EVSINCH1",
                  "group": "EVSPB",
                  "index": 1,
                  "pad": "PB1"
                },
                {
                  "function": "EVSINCH1",
                  "group": "EVSPB",
                  "index": 2,
                  "pad": "PB2"
                },
                {
                  "function": "EVSINCH1",
                  "group": "EVSPB",
                  "index": 3,
                  "pad": "PB3"
                }
              ]
            }
          ]
        },
        {
          "name": "FUSE",
          "instances": [
            {
              "name": "FUSE",
              "signals": null
            }
          ]
        },
        {
          "name": "GPIO",
          "instances": [
            {
              "name": "GPIO",
              "signals": null
            }
          ]
        },
        {
          "name": "LOCKBIT",
          "instances": [
            {
              "name": "LOCKBIT",
              "signals": null
            }
          ]
        },
        {
          "name": "NVMCTRL",
          "instances": [
            {
              "name": "NVMCTRL",
              "signals": null
            }
          ]
        },
        {
          "name": "PORT",
          "instances": [
            {
              "name": "PORTA",
              "signals": [
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 4,
                  "pad": "PA4"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 5,
                  "pad": "PA5"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 6,
                  "pad": "PA6"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 7,
                  "pad": "PA7"
                }
              ]
            },
            {
              "name": "PORTB",
              "signals": [
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 0,
                  "pad": "PB0"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 1,
                  "pad": "PB1"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 2,
                  "pad": "PB2"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 3,
                  "pad": "PB3"
                }
              ]
            }
          ]
        },
        {
          "name": "PORTMUX",
          "instances": [
            {
              "name": "PORTMUX",
              "signals": null
            }
          ]
        },
        {
          "name": "PTC",
          "instances": [
            {
              "name": "PTC",
              "signals": [
                {
                  "function": "PTC_DS",
                  "group": "DS",
                  "index": 0,
                  "pad": "PB2"
                },
                {
                  "function": "PTC_X",
                  "group": "X",
                  "index": 0,
                  "pad": "PA4"
                },
                {
                  "function": "PTC_X",
                  "group": "X",
                  "index": 1,
                  "pad": "PA5"
                },
                {
                  "function": "PTC_X",
                  "group": "X",
                  "index": 2,
                  "pad": "PA6"
                },
                {
                  "function": "PTC_X",
                  "group": "X",
                  "index": 3,
                  "pad": "PA7"
                },
                {
                  "function": "PTC_X",
                  "group": "X",
                  "index": 4,
                  "pad": "PB1"
                },
                {
                  "function": "PTC_X",
                  "group": "X",
                  "index": 5,
                  "pad": "PB0"
                },
                {
                  "function": "PTC_Y",
                  "group": "Y",
                  "index": 0,
                  "pad": "PA4"
                },
                {
                  "function": "PTC_Y",
                  "group": "Y",
                  "index": 1,
                  "pad": "PA5"
                },
                {
                  "function": "PTC_Y",
                  "group": "Y",
                  "index": 2,
                  "pad": "PA6"
                },
                {
                  "function": "PTC_Y",
                  "group": "Y",
                  "index": 3,
                  "pad": "PA7"
                },
                {
                  "function": "PTC_Y",
                  "group": "Y",
                  "index": 4,
                  "pad": "PB1"
                },
                {
                  "function": "PTC_Y",
                  "group": "Y",
                  "index": 5,
                  "pad": "PB0"
                }
              ]
            }
          ]
        },
        {
          "name": "RSTCTRL",
          "instances": [
            {
              "name": "RSTCTRL",
              "signals": [
                {
                  "function": "OTHER",
                  "group": "RESET",
                  "index": null,
                  "pad": "PA0"
                }
              ]
            }
          ]
        },
        {
          "name": "RTC",
          "instances": [
            {
              "name": "RTC",
              "signals": null
            }
          ]
        },
        {
          "name": "SIGROW",
          "instances": [
            {
              "name": "SIGROW",
              "signals": null
            }
          ]
        },
        {
          "name": "SLPCTRL",
          "instances": [
            {
              "name": "SLPCTRL",
              "signals": null
            }
          ]
        },
        {
          "name": "SPI",
          "instances": [
            {
              "name": "SPI0",
              "signals": [
                {
                  "function": "SPI0",
                  "group": "MISO",
                  "index": null,
                  "pad": "PA2"
                },
                {
                  "function": "SPI0",
                  "group": "MOSI",
                  "index": null,
                  "pad": "PA1"
                },
                {
                  "function": "SPI0",
                  "group": "SCK",
                  "index": null,
                  "pad": "PA3"
                },
                {
                  "function": "SPI0",
                  "group": "SS",
                  "index": null,
                  "pad": "PA4"
                }
              ]
            }
          ]
        },
        {
          "name": "SYSCFG",
          "instances": [
            {
              "name": "SYSCFG",
              "signals": [
                {
                  "function": "OTHER",
                  "group": "UPDI",
                  "index": null,
                  "pad": "PA0"
                }
              ]
            }
          ]
        },
        {
          "name": "TCA",
          "instances": [
            {
              "name": "TCA0",
              "signals": [
                {
                  "function": "TCA0_ALT",
                  "group": "WO",
                  "index": 0,
                  "pad": "PB3"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 0,
                  "pad": "PB0"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 1,
                  "pad": "PB1"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 2,
                  "pad": "PB2"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 4,
                  "pad": "PA4"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 5,
                  "pad": "PA5"
                }
              ]
            }
          ]
        },
        {
          "name": "TCB",
          "instances": [
            {
              "name": "TCB0",
              "signals": [
                {
                  "function": "TCB0",
                  "group": "WO",
                  "index": 0,
                  "pad": "PA5"
                }
              ]
            }
          ]
        },
        {
          "name": "TCD",
          "instances": [
            {
              "name": "TCD0",
              "signals": [
                {
                  "function": "TCD0",
                  "group": "WOA",
                  "index": null,
                  "pad": "PA4"
                },
                {
                  "function": "TCD0",
                  "group": "WOB",
                  "index": null,
                  "pad": "PA5"
                }
              ]
            }
          ]
        },
        {
          "name": "TWI",
          "instances": [
            {
              "name": "TWI0",
              "signals": [
                {
                  "function": "TWI0_ALT",
                  "group": "SCL",
                  "index": null,
                  "pad": "PA2"
                },
                {
                  "function": "TWI0",
                  "group": "SCL",
                  "index": null,
                  "pad": "PB0"
                },
                {
                  "function": "TWI0_ALT",
                  "group": "SDA",
                  "index": null,
                  "pad": "PA1"
                },
                {
                  "function": "TWI0",
                  "group": "SDA",
                  "index": null,
                  "pad": "PB1"
                }
              ]
            }
          ]
        },
        {
          "name": "USART",
          "instances": [
            {
              "name": "USART0",
              "signals": [
                {
                  "function": "USART0_ALT",
                  "group": "RXD",
                  "index": null,
                  "pad": "PA2"
                },
                {
                  "function": "USART0",
                  "group": "RXD",
                  "index": null,
                  "pad": "PB3"
                },
                {
                  "function": "USART0_ALT",
                  "group": "TXD",
                  "index": null,
                  "pad": "PA1"
                },
                {
                  "function": "USART0",
                  "group": "TXD",
                  "index": null,
                  "pad": "PB2"
                },
                {
                  "function": "USART0_ALT",
                  "group": "XCK",
                  "index": null,
                  "pad": "PA3"
                },
                {
                  "function": "USART0",
                  "group": "XCK",
                  "index": null,
                  "pad": "PB1"
                },
                {
                  "function": "USART0_ALT",
                  "group": "XDIR",
                  "index": null,
                  "pad": "PA4"
                },
                {
                  "function": "USART0",
                  "group": "XDIR",
                  "index": null,
                  "pad": "PB0"
                }
              ]
            }
          ]
        },
        {
          "name": "USERROW",
          "instances": [
            {
              "name": "USERROW",
              "signals": null
            }
          ]
        },
        {
          "name": "VPORT",
          "instances": [
            {
              "name": "VPORTA",
              "signals": null
            },
            {
              "name": "VPORTB",
              "signals": null
            },
            {
              "name": "VPORTC",
              "signals": null
            }
          ]
        },
        {
          "name": "VREF",
          "instances": [
            {
              "name": "VREF",
              "signals": null
            }
          ]
        },
        {
          "name": "WDT",
          "instances": [
            {
              "name": "WDT",
              "signals": null
            }
          ]
        }
      ]
    }
  ],
  "modules": [
    {
      "caption": "Analog Comparator",
      "id": "I2106",
      "name": "AC",
      "register_groups": [
        {
          "caption": "Analog Comparator",
          "name": "AC",
          "size": "0x8",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the AC."
                },
                {
                  "caption": "Hysteresis Mode",
                  "mask": "0x6",
                  "name": "HYSMODE",
                  "rw": "RW",
                  "values_ref": "AC_HYSMODE",
                  "description": "Writing to this bit field selects the Hysteresis mode for the AC input.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0x0   | OFF   | OFF         |\n| 0x1   | 10    | \u00b110 mV      |\n| 0x2   | 25    | \u00b125 mV      |\n| 0x3   | 50    | \u00b150 mV      |\n\n"
                },
                {
                  "caption": "Interrupt Mode",
                  "mask": "0x30",
                  "name": "INTMODE",
                  "rw": "RW",
                  "values_ref": "AC_INTMODE",
                  "description": "Writing to this bit field selects what edges of the AC output triggers an interrupt request.\n\n\n| Value | Name     | Description                     |\n| :---- | :------- | :------------------------------ |\n| 0x0   | BOTHEDGE | Both negative and positive edge |\n| 0x1   | -        | Reserved                        |\n| 0x2   | NEGEDGE  | Negative edge                   |\n| 0x3   | POSEDGE  | Positive edge                   |\n\n"
                },
                {
                  "caption": "Low Power Mode",
                  "mask": "0x8",
                  "name": "LPMODE",
                  "rw": "RW",
                  "values_ref": "AC_LPMODE",
                  "description": "Writing a '1' to this bit reduces the current through the comparator. This reduces the power consumption but\nincreases the reaction time of the AC.\n\n\n| Value | Description             |\n| :---- | :---------------------- |\n| 0     | Low-Power mode disabled |\n| 1     | Low-Power mode enabled  |\n\n"
                },
                {
                  "caption": "Output Buffer Enable",
                  "mask": "0x40",
                  "name": "OUTEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' makes the OUT signal available on the pin."
                },
                {
                  "caption": "Run in Standby Mode",
                  "mask": "0x80",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit allows the AC to continue operation in Standby sleep mode. Since the clock is stopped,\ninterrupts and status flags are not updated.\n\n\n| Value | Description                                               |\n| :---- | :-------------------------------------------------------- |\n| 0     | In Standby sleep mode, the peripheral is halted           |\n| 1     | In Standby sleep mode, the peripheral continues operation |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Analog Comparator 0 Interrupt Enable",
                  "mask": "0x1",
                  "name": "CMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables analog comparator interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Mux Control A",
              "reset": "0x00",
              "name": "MUXCTRLA",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Invert AC Output",
                  "mask": "0x80",
                  "name": "INVERT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables inversion of the output of the AC. This effectively inverts the input to all the peripherals\nconnected to the signal and affects the internal status signals."
                },
                {
                  "caption": "Negative Input MUX Selection",
                  "mask": "0x3",
                  "name": "MUXNEG",
                  "rw": "RW",
                  "values_ref": "AC_MUXNEG",
                  "description": "Writing to this bit field selects the input signal to the negative input of the AC.\n\n\n| Value | Name     | Description       |\n| :---- | :------- | :---------------- |\n| 0x0   | AINN0    | Negative pin 0    |\n| 0x1   | AINN1(1) | Negative pin 1    |\n| 0x2   | VREF     | Voltage Reference |\n| 0x3   | DAC      | DAC output        |\n\n\nNote:"
                },
                {
                  "caption": "Positive Input MUX Selection",
                  "mask": "0x8",
                  "name": "MUXPOS",
                  "rw": "RW",
                  "values_ref": "AC_MUXPOS",
                  "description": "Writing to this bit field selects the input signal to the positive input of the AC.\n\n\n| Value | Name     | Description    |\n| :---- | :------- | :------------- |\n| 0x0   | AINP0    | Positive pin 0 |\n| 0x0   | AINP1(1) | Positive pin 1 |\n| Other | -        | Reserved       |\n\n\nNote:"
                }
              ],
              "description": "ACn.MUXCTRLA controls the analog comparator MUXes."
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Analog Comparator Interrupt Flag",
                  "mask": "0x1",
                  "name": "CMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This is the Interrupt flag for AC. Writing a '1' to this bit will clear the Interrupt flag."
                },
                {
                  "caption": "Analog Comparator State",
                  "mask": "0x10",
                  "name": "STATE",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This shows the current status of the OUT signal from the AC. This will have a synchronizer delay to get updated in\nthe I/O register (three cycles)."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Analog to Digital Converter",
      "id": "I2132",
      "name": "ADC",
      "register_groups": [
        {
          "caption": "Analog to Digital Converter",
          "name": "ADC",
          "size": "0x18",
          "registers": [
            {
              "caption": "Calibration",
              "reset": "0x00",
              "name": "CALIB",
              "offset": "0x16",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Duty Cycle",
                  "mask": "0x1",
                  "name": "DUTYCYC",
                  "rw": "RW",
                  "values_ref": "ADC_DUTYCYC",
                  "description": "This bit determines the duty cycle of the ADC clock.\nADCclk > 1.5 MHz requires a minimum operating voltage of 2.7V.\n\n\n| Value | Description                                                             |\n| :---- | :---------------------------------------------------------------------- |\n| 0     | 50% Duty Cycle must be used if ADCclk > 1.5 MHz                         |\n| 1     | 25% Duty Cycle (high 25% and low 75%) must be used for ADCclk \u2264 1.5 MHz |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Command",
              "reset": "0x00",
              "name": "COMMAND",
              "offset": "0x08",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Start Conversion Operation",
                  "mask": "0x1",
                  "name": "STCONV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit will start a single measurement. If in Free-Running mode, this will start the first conversion.\nSTCONV will read as '1' as long as a conversion is in progress. When the conversion is complete, this bit is\nautomatically cleared."
                }
              ],
              "description": null
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "ADC Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description     |\n| :---- | :-------------- |\n| 0     | ADC is disabled |\n| 1     | ADC is enabled  |\n\n"
                },
                {
                  "caption": "ADC Freerun mode",
                  "mask": "0x2",
                  "name": "FREERUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit will enable the Free-Running mode for the data acquisition. The first conversion is started by\nwriting the STCONV bit in the ADCn.COMMAND high. In the Free-Running mode, a new conversion cycle is started\nimmediately after or as soon as the previous conversion cycle has been completed. This is signaled by the RESRDY\nflag in the ADCn.INTFLAGS register."
                },
                {
                  "caption": "ADC Resolution",
                  "mask": "0x4",
                  "name": "RESSEL",
                  "rw": "RW",
                  "values_ref": "ADC_RESSEL",
                  "description": "This bit selects the ADC resolution.\n\n\n| Value | Description                                                                                |\n| :---- | :----------------------------------------------------------------------------------------- |\n| 0     | Full 10-bit resolution. The 10-bit ADC results are accumulated or stored in the ADC Result |\n\n\n(ADCn.RES) register.\n1 8-bit resolution. The conversion results are truncated to eight bits (MSbs) before they are accumulated\nor stored in the ADC Result (ADCn.RES) register. The two Least Significant bits (LSbs) are discarded."
                },
                {
                  "caption": "Run standby mode",
                  "mask": "0x80",
                  "name": "RUNSTBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit determines whether the ADC needs to run when the chip is in Standby sleep mode."
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Accumulation Samples",
                  "mask": "0x7",
                  "name": "SAMPNUM",
                  "rw": "RW",
                  "values_ref": "ADC_SAMPNUM",
                  "description": "This bit field selects how many consecutive ADC sampling results are accumulated automatically. When this bit is\nwritten to a value greater than 0x0, the according number of consecutive ADC sampling results are accumulated into\nthe ADC Result (ADCn.RES) register in one complete conversion.\n\n\n| Value | Name  | Description            |\n| :---- | :---- | :--------------------- |\n| 0x0   | NONE  | No accumulation        |\n| 0x1   | ACC2  | 2 results accumulated  |\n| 0x2   | ACC4  | 4 results accumulated  |\n| 0x3   | ACC8  | 8 results accumulated  |\n| 0x4   | ACC16 | 16 results accumulated |\n| 0x5   | ACC32 | 32 results accumulated |\n| 0x6   | ACC64 | 64 results accumulated |\n| 0x7   | -     | Reserved               |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Pre-scaler",
                  "mask": "0x7",
                  "name": "PRESC",
                  "rw": "RW",
                  "values_ref": "ADC_PRESC",
                  "description": "This bit field defines the division factor from the peripheral clock (CLK_PER) to the ADC clock (CLK_ADC).\n\n\n| Value | Name   | Description            |\n| :---- | :----- | :--------------------- |\n| 0x0   | DIV2   | CLK_PER divided by 2   |\n| 0x1   | DIV4   | CLK_PER divided by 4   |\n| 0x2   | DIV8   | CLK_PER divided by 8   |\n| 0x3   | DIV16  | CLK_PER divided by 16  |\n| 0x4   | DIV32  | CLK_PER divided by 32  |\n| 0x5   | DIV64  | CLK_PER divided by 64  |\n| 0x6   | DIV128 | CLK_PER divided by 128 |\n| 0x7   | DIV256 | CLK_PER divided by 256 |\n\n"
                },
                {
                  "caption": "Reference Selection",
                  "mask": "0x30",
                  "name": "REFSEL",
                  "rw": "RW",
                  "values_ref": "ADC_REFSEL",
                  "description": "This bit field selects the voltage reference for the ADC.\n\n\n| Value | Name     | Description              |\n| :---- | :------- | :----------------------- |\n| 0x0   | INTERNAL | Internal reference       |\n| 0x1   | VDD      | VDD                      |\n| 0x2   | VREFA    | External reference VREFA |\n| Other | -        | Reserved                 |\n\n"
                },
                {
                  "caption": "Sample Capacitance Selection",
                  "mask": "0x40",
                  "name": "SAMPCAP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects the sample capacitance, and hence, the input impedance. The best value is dependent on the\nreference voltage and the application's electrical properties.\n\n\n| Value | Description                                                                      |\n| :---- | :------------------------------------------------------------------------------- |\n| 0     | Recommended for reference voltage values below 1V                                |\n| 1     | Reduced size of sampling capacitance. Recommended for higher reference voltages. |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Automatic Sampling Delay Variation",
                  "mask": "0x10",
                  "name": "ASDV",
                  "rw": "RW",
                  "values_ref": "ADC_ASDV",
                  "description": "Writing this bit to '1' enables automatic sampling delay variation between ADC conversions. The purpose of varying\nsampling instant is to randomize the sampling instant and thus avoid standing frequency components in the\nfrequency spectrum. The value of the SAMPDLY bit field is automatically incremented by one after each sample.\nWhen the Automatic Sampling Delay Variation is enabled, and the SAMPDLY value reaches 0xF, it wraps around to\n0x0.\n\n\n| Value | Name   | Description                                        |\n| :---- | :----- | :------------------------------------------------- |\n| 0     | ASVOFF | The Automatic Sampling Delay Variation is disabled |\n| 1     | ASVON  | The Automatic Sampling Delay Variation is enabled  |\n\n"
                },
                {
                  "caption": "Initial Delay Selection",
                  "mask": "0xe0",
                  "name": "INITDLY",
                  "rw": "RW",
                  "values_ref": "ADC_INITDLY",
                  "description": "This bit field defines the initialization/start-up delay before the first sample when enabling the ADC or changing to an\ninternal reference voltage. Setting this delay will ensure that the reference, MUXes, etc., are ready before starting the\nfirst conversion. The initialization delay will also take place when waking up from deep sleep to do a measurement.\nThe delay is expressed several CLK_ADC cycles.\n\n\n| Value | Name   | Description              |\n| :---- | :----- | :----------------------- |\n| 0x0   | DLY0   | Delay 0 CLK_ADC cycles   |\n| 0x1   | DLY16  | Delay 16 CLK_ADC cycles  |\n| 0x2   | DLY32  | Delay 32 CLK_ADC cycles  |\n| 0x3   | DLY64  | Delay 64 CLK_ADC cycles  |\n| 0x4   | DLY128 | Delay 128 CLK_ADC cycles |\n| 0x5   | DLY256 | Delay 256 CLK_ADC cycles |\n| Other | -      | Reserved                 |\n\n"
                },
                {
                  "caption": "Sampling Delay Selection",
                  "mask": "0xf",
                  "name": "SAMPDLY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field defines the delay between consecutive ADC samples. The programmable sampling delay allows\nmodifying the sampling frequency during hardware accumulation to suppress periodic noise sources that may\notherwise disturb the sampling. The SAMPDLY bit field can also be modified automatically from one sampling cycle\nto another, by setting the ASDV bit. The delay is expressed as CLK_ADC cycles and is given directly by the bit field\nsetting. The sampling cap is kept open during the delay."
                }
              ],
              "description": null
            },
            {
              "caption": "Control E",
              "reset": "0x00",
              "name": "CTRLE",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Window Comparator Mode",
                  "mask": "0x7",
                  "name": "WINCM",
                  "rw": "RW",
                  "values_ref": "ADC_WINCM",
                  "description": "This bit field enables and defines when the interrupt flag is set in Window Comparator mode. RESULT is the 16-bit\naccumulator result. WINLT and WINHT are 16-bit lower threshold value and 16-bit higher threshold value,\nrespectively.\n\n\n| Value | Name    | Description                      |\n| :---- | :------ | :------------------------------- |\n| 0x0   | NONE    | No Window Comparison (default)   |\n| 0x1   | BELOW   | RESULT < WINLT                   |\n| 0x2   | ABOVE   | RESULT > WINHT                   |\n| 0x3   | INSIDE  | WINLT < RESULT < WINHT           |\n| 0x4   | OUTSIDE | RESULT < WINLT or RESULT > WINHT |\n| Other | -       | Reserved                         |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Debug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x0C",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Event Control",
              "reset": "0x00",
              "name": "EVCTRL",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Start Event Input Enable",
                  "mask": "0x1",
                  "name": "STARTEI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables using the event input as a trigger for starting a conversion."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Result Ready Interrupt Enable",
                  "mask": "0x1",
                  "name": "RESRDY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the result ready interrupt."
                },
                {
                  "caption": "Window Comparator Interrupt Enable",
                  "mask": "0x2",
                  "name": "WCMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the window comparator interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Result Ready Flag",
                  "mask": "0x1",
                  "name": "RESRDY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Result Ready interrupt flag is set when a measurement is complete, and a new result is ready. The flag is\ncleared by either writing a '1' to the bit location or by reading the Result (ADCn.RES) register. Writing a '0' to this bit\nhas no effect."
                },
                {
                  "caption": "Window Comparator Flag",
                  "mask": "0x2",
                  "name": "WCMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This window comparator interrupt flag is set when the measurement is complete and if the result matches the\nselected Window Comparator mode defined by WINCM (ADCn.CTRLE). The comparison is done at the end of the\nconversion. The flag is cleared by either writing a '1' to the bit position or by reading the Result (ADCn.RES) register.\nWriting a '0' to this bit has no effect."
                }
              ],
              "description": null
            },
            {
              "caption": "Positive mux input",
              "reset": "0x00",
              "name": "MUXPOS",
              "offset": "0x06",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Analog Channel Selection Bits",
                  "mask": "0x1f",
                  "name": "MUXPOS",
                  "rw": "RW",
                  "values_ref": "ADC_MUXPOS",
                  "description": "This bit field selects which single-ended analog input is connected to the ADC. If these bits are changed during a\nconversion, the change will not take effect until this conversion is complete.\n\n\n| Value | Name     | Description                               |\n| :---- | :------- | :---------------------------------------- |\n| 0x00  | AIN0     | ADC input pin 0                           |\n| 0x01  | AIN1     | ADC input pin 1                           |\n| 0x02  | AIN2     | ADC input pin 2                           |\n| 0x03  | AIN3     | ADC input pin 3                           |\n| 0x04  | AIN4     | ADC input pin 4                           |\n| 0x05  | AIN5     | ADC input pin 5                           |\n| 0x06  | AIN6     | ADC input pin 6                           |\n| 0x07  | AIN7     | ADC input pin 7                           |\n| 0x08  | AIN8     | ADC input pin 8                           |\n| 0x09  | AIN9     | ADC input pin 9                           |\n| 0x0A  | AIN10    | ADC input pin 10                          |\n| 0x0B  | AIN11    | ADC input pin 11                          |\n| 0x1C  | DAC0     | DAC0                                      |\n| 0x1D  | INTREF   | Internal reference (from VREF peripheral) |\n| 0x1E  | TEMSENSE | Temperature sensor                        |\n| 0x1F  | GND      | 0V (GND)                                  |\n| Other | -        | Reserved                                  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "ADC Accumulator Result",
              "reset": null,
              "name": "RES",
              "offset": "0x10",
              "rw": "R",
              "size": 2,
              "bitfields": [
                {
                  "name": "RES",
                  "caption": "Result low byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field constitutes the LSB of ADC/Accumulator Result, (ADCn.RES) register. The data format in ADC and\nDigital Accumulation is 1's complement, where 0x0000 represents the zero, and 0xFFFF represents the largest\nnumber (full scale)."
                },
                {
                  "name": "RES",
                  "caption": "Result high byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field constitutes the MSB of the ADCn.RES register, where the MSb is RES[15]. The ADC itself has a 10-bit\noutput, ADC[9:0], where the MSb is ADC[9]. The data format in ADC and Digital Accumulation is 1's complement,\nwhere 0x0000 represents the zero, and 0xFFFF represents the largest number (full scale)."
                }
              ],
              "description": "The ADCn.RESL and ADCn.RESH register pair represents the 16-bit value, ADCn.RES. The low byte [7:0] (suffix L)\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nIf the analog input is higher than the reference level of the ADC, the 10-bit ADC result will be equal the maximum\nvalue of 0x3FF. Likewise, if the input is below 0V, the ADC result will be 0x000. As the ADC cannot produce a result\nabove 0x3FF values, the accumulated value will never exceed 0xFFC0 even after the maximum allowed 64\naccumulations."
            },
            {
              "caption": "Sample Control",
              "reset": "0x00",
              "name": "SAMPCTRL",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Sample lenght",
                  "mask": "0x1f",
                  "name": "SAMPLEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field extends the ADC sampling length in several CLK_ADC cycles. By default, the sampling time is two\nCLK_ADC cycles. Increasing the sampling length allows sampling sources with higher impedance. The total\nconversion time increases with the selected sampling length."
                }
              ],
              "description": null
            },
            {
              "caption": "Temporary Data",
              "reset": "0x00",
              "name": "TEMP",
              "offset": "0x0D",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Temporary",
                  "mask": "0xff",
                  "name": "TEMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                }
              ],
              "description": "The Temporary register is used by the CPU for 16-bit single-cycle access to the 16-bit registers of this peripheral. The\nregister is common for all the 16-bit registers of this peripheral and can be read and written by software. For more\ndetails on reading and writing 16-bit registers, refer to Accessing 16-Bit Registers in the AVR CPU section."
            },
            {
              "caption": "Window comparator high threshold",
              "reset": null,
              "name": "WINHT",
              "offset": "0x14",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "WINHT",
                  "caption": "Window Comparator High Threshold Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit register."
                },
                {
                  "name": "WINHT",
                  "caption": "Window Comparator High Threshold High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit register."
                }
              ],
              "description": "This register is the 16-bit high threshold for the digital comparator monitoring the ADCn.RES register. The ADC itself\nhas a 10-bit output, RES[9:0], where the MSb is RES[9]. The data format in ADC and Digital Accumulation is 1's\ncomplement, where 0x0000 represents the zero, and 0xFFFF represents the largest number (full scale).\nThe ADCn.WINHTH and ADCn.WINHTL register pair represents the 16-bit value, ADCn.WINHT. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Window comparator low threshold",
              "reset": null,
              "name": "WINLT",
              "offset": "0x12",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "WINLT",
                  "caption": "Window Comparator Low Threshold Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit register."
                },
                {
                  "name": "WINLT",
                  "caption": "Window Comparator Low Threshold High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit register."
                }
              ],
              "description": "This register is the 16-bit low threshold for the digital comparator monitoring the ADCn.RES register. The ADC itself\nhas a 10-bit output, RES[9:0], where the MSb is RES[9]. The data format in ADC and Digital Accumulation is 1's\ncomplement, where 0x0000 represents the zero, and 0xFFFF represents the largest number (full scale).\nThe ADCn.WINLTH and ADCn.WINLTL register pair represents the 16-bit value, ADCn.WINLT. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nWhen accumulating samples, the window comparator thresholds are applied to the accumulated value and not on\neach sample."
            }
          ]
        }
      ]
    },
    {
      "caption": "Bod interface",
      "id": "I2114",
      "name": "BOD",
      "register_groups": [
        {
          "caption": "Bod interface",
          "name": "BOD",
          "size": "0x10",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x05",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Operation in active mode",
                  "mask": "0xc",
                  "name": "ACTIVE",
                  "rw": "R",
                  "values_ref": "BOD_ACTIVE",
                  "description": "These bits select the BOD operation mode when the device is in Active or Idle mode.\nThe Reset value is loaded from the ACTIVE bit field in FUSE.BODCFG.\nThis bit field is not under Configuration Change Protection (CCP).\n\n\n| Value | Name    | Description                                                                     |\n| :---- | :------ | :------------------------------------------------------------------------------ |\n| 0x0   | DIS     | Disabled                                                                        |\n| 0x1   | ENABLED | Enabled in continuous mode                                                      |\n| 0x2   | SAMPLED | Enabled in sampled mode                                                         |\n| 0x3   | ENWAKE  | Enabled in continuous mode. Execution is halted at wake-up until BOD is running |\n\n"
                },
                {
                  "caption": "Sample frequency",
                  "mask": "0x10",
                  "name": "SAMPFREQ",
                  "rw": "R",
                  "values_ref": "BOD_SAMPFREQ",
                  "description": "This bit controls the BOD sample frequency.\nThe Reset value is loaded from the SAMPFREQ bit in FUSE.BODCFG.\nThis bit is not under Configuration Change Protection (CCP).\n\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0x0   | Sample frequency is 1 kHz  |\n| 0x1   | Sample frequency is 125 Hz |\n\n"
                },
                {
                  "caption": "Operation in sleep mode",
                  "mask": "0x3",
                  "name": "SLEEP",
                  "rw": "RW",
                  "values_ref": "BOD_SLEEP",
                  "description": "These bits select the BOD operation mode when the device is in Standby or Power-Down sleep mode. The Reset\nvalue is loaded from the SLEEP bit field in FUSE.BODCFG.\n\n\n| Value | Name    | Description                |\n| :---- | :------ | :------------------------- |\n| 0x0   | DIS     | Disabled                   |\n| 0x1   | ENABLED | Enabled in continuous mode |\n| 0x2   | SAMPLED | Enabled in sampled mode    |\n| 0x3   | -       | Reserved                   |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Bod level",
                  "mask": "0x7",
                  "name": "LVL",
                  "rw": "R",
                  "values_ref": "BOD_LVL",
                  "description": "This bit field controls the BOD threshold level.\nThe Reset value is loaded from the BOD Level (LVL) bits in the BOD Configuration Fuse (FUSE.BODCFG).\n\n\n| Value | Name      | Description |\n| :---- | :-------- | :---------- |\n| 0x0   | BODLEVEL0 | 1.8V        |\n| 0x2   | BODLEVEL2 | 2.6V        |\n| 0x7   | BODLEVEL7 | 4.2V        |\n\n\nNotes:\n* Refer to the BOD and POR Characteristics in Electrical Characteristics for further details\n* Values in the description are typical values"
                }
              ],
              "description": null
            },
            {
              "caption": "Voltage level monitor interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Configuration",
                  "mask": "0x6",
                  "name": "VLMCFG",
                  "rw": "RW",
                  "values_ref": "BOD_VLMCFG",
                  "description": "These bits select which incidents will trigger a VLM interrupt.\n\n\n| Value | Name  | Description                   |\n| :---- | :---- | :---------------------------- |\n| 0x0   | BELOW | VDD falls below VLM threshold |\n| 0x1   | ABOVE | VDD rises above VLM threshold |\n| 0x2   | CROSS | VDD crosses VLM threshold     |\n| Other | -     | Reserved                      |\n\n"
                },
                {
                  "caption": "voltage level monitor interrrupt enable",
                  "mask": "0x1",
                  "name": "VLMIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the VLM interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Voltage level monitor interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0xA",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Voltage level monitor interrupt flag",
                  "mask": "0x1",
                  "name": "VLMIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when a trigger from the VLM is given, as configured by the VLMCFG bit in the BOD.INTCTRL register.\nThe flag is only updated when the BOD is enabled."
                }
              ],
              "description": null
            },
            {
              "caption": "Voltage level monitor status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0xB",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Voltage level monitor status",
                  "mask": "0x1",
                  "name": "VLMS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is only valid when the BOD is enabled.\n\n\n| Value | Description                                  |\n| :---- | :------------------------------------------- |\n| 0     | The voltage is above the VLM threshold level |\n| 1     | The voltage is below the VLM threshold level |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Voltage level monitor Control",
              "reset": "0x00",
              "name": "VLMCTRLA",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "voltage level monitor level",
                  "mask": "0x3",
                  "name": "VLMLVL",
                  "rw": "RW",
                  "values_ref": "BOD_VLMLVL",
                  "description": "These bits select the VLM threshold relative to the BOD threshold (LVL in BOD.CTRLB).\n\n\n| Value | Description                           |\n| :---- | :------------------------------------ |\n| 0x0   | VLM threshold 5% above BOD threshold  |\n| 0x1   | VLM threshold 15% above BOD threshold |\n| 0x2   | VLM threshold 25% above BOD threshold |\n| other | Reserved                              |\n\n"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Configurable Custom Logic",
      "id": "I2128",
      "name": "CCL",
      "register_groups": [
        {
          "caption": "Configurable Custom Logic",
          "name": "CCL",
          "size": "0x10",
          "registers": [
            {
              "caption": "Control Register A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | The peripheral is disabled |\n| 1     | The peripheral is enabled  |\n\n"
                },
                {
                  "caption": "Run in Standby",
                  "mask": "0x40",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit indicates if the peripheral clock (CLK_PER) is kept running in Standby sleep mode. The setting is ignored for\nconfigurations where the CLK_PER is not required.\n\n\n| Value | Description                                        |\n| :---- | :------------------------------------------------- |\n| 0     | System clock is not required in Standby sleep mode |\n| 1     | System clock is required in Standby sleep mode     |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "LUT Control 0 A",
              "reset": "0x00",
              "name": "LUT0CTRLA",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Source Selection",
                  "mask": "0x40",
                  "name": "CLKSRC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects whether the peripheral clock (CLK_PER) or any source selected by the INSEL2 bit field of the\nLUTnCTRLC register (LUTn-TRUTHSEL[2]) is used as the clock (CLK_MUX_OUTn) for an LUT.\nThe CLK_MUX_OUTn of the even LUT is used for clocking the Sequencer block of an LUT pair.\n\n\n| Value | Description                           |\n| :---- | :------------------------------------ |\n| 0     | CLK_PER is clocking the LUTn          |\n| 1     | LUTn-TRUTHSEL[2] is clocking the LUTn |\n\n"
                },
                {
                  "caption": "Edge Detection Enable",
                  "mask": "0x80",
                  "name": "EDGEDET",
                  "rw": "RW",
                  "values_ref": "CCL_EDGEDET",
                  "description": "\n\n| Value | Description               |\n| :---- | :------------------------ |\n| 0     | Edge detector is disabled |\n| 1     | Edge detector is enabled  |\n\n"
                },
                {
                  "caption": "LUT Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description         |\n| :---- | :------------------ |\n| 0     | The LUT is disabled |\n| 1     | The LUT is enabled  |\n\n"
                },
                {
                  "caption": "Filter Selection",
                  "mask": "0x30",
                  "name": "FILTSEL",
                  "rw": "RW",
                  "values_ref": "CCL_FILTSEL",
                  "description": "This bit field selects the LUT output filter options.\n\n\n| Value | Name    | Description          |\n| :---- | :------ | :------------------- |\n| 0x0   | DISABLE | Filter disabled      |\n| 0x1   | SYNCH   | Synchronizer enabled |\n| 0x2   | FILTER  | Filter enabled       |\n| 0x3   | -       | Reserved             |\n\n"
                },
                {
                  "caption": "Output Enable",
                  "mask": "0x8",
                  "name": "OUTEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables the LUT output to the LUTnOUT pin. When written to '1', the pin configuration of the PORT I/O\nController is overridden.\n\n\n| Value | Description            |\n| :---- | :--------------------- |\n| 0     | Output to pin disabled |\n| 1     | Output to pin enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "LUT Control 0 B",
              "reset": "0x00",
              "name": "LUT0CTRLB",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "LUT Input 0 Source Selection",
                  "mask": "0xf",
                  "name": "INSEL0",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL0",
                  "description": "This bit field selects the source for input 0 of LUT n.\n\n\n| Value | Name     | Description                      |\n| :---- | :------- | :------------------------------- |\n| 0x0   | MASK     | Masked input                     |\n| 0x1   | FEEDBACK | Feedback input                   |\n| 0x2   | LINK     | Linked other LUT as input source |\n| 0x3   | EVENT0   | Event input source 0             |\n| 0x4   | EVENT1   | Event input source 1             |\n| 0x5   | IO       | I/O-pin LUTn-IN0 input source    |\n| 0x6   | AC0      | AC0 OUT input source             |\n| 0x7   | TCB0     | TCB0 WO input source             |\n| 0x8   | TCA0     | TCA0 WO0 input source            |\n| 0x9   | TCD0     | TCD0 WOA input source            |\n| 0xA   | USART0   | USART0 XCK input source          |\n| 0xB   | SPI0     | SPI0 SCK input source            |\n| Other | -        | Reserved                         |\n\n"
                },
                {
                  "caption": "LUT Input 1 Source Selection",
                  "mask": "0xf0",
                  "name": "INSEL1",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL1",
                  "description": "This bit field selects the source for input 1 of LUT n.\n\n\n| Value | Name     | Description                      |\n| :---- | :------- | :------------------------------- |\n| 0x0   | MASK     | Masked input                     |\n| 0x1   | FEEDBACK | Feedback input                   |\n| 0x2   | LINK     | Linked other LUT as input source |\n| 0x3   | EVENT0   | Event input source 0             |\n| 0x4   | EVENT1   | Event input source 1             |\n| 0x5   | IO       | I/O-pin LUTn-IN1 input source    |\n| 0x6   | AC0      | AC0 OUT input source             |\n| 0x7   | TCB0     | TCB0 WO input source             |\n| 0x8   | TCA0     | TCA0 WO1 input source            |\n| 0x9   | TCD0     | TCD0 WOB input source            |\n| 0xA   | USART0   | USART0 TXD input source          |\n| 0xB   | SPI0     | SPI0 MOSI input source           |\n| Other | -        | Reserved                         |\n\n"
                }
              ],
              "description": "Notes:\n1. SPI connections to the CCL work in Host SPI mode only.\n2. USART connections to the CCL work only when the USART is in one of the following modes:\n- Asynchronous USART\n- Synchronous USART Host"
            },
            {
              "caption": "LUT Control 0 C",
              "reset": "0x00",
              "name": "LUT0CTRLC",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "LUT Input 2 Source Selection",
                  "mask": "0xf",
                  "name": "INSEL2",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL2",
                  "description": "This bit field selects the source for input 2 of LUT n.\n\n\n| Value | Name     | Description                      |\n| :---- | :------- | :------------------------------- |\n| 0x0   | MASK     | Masked input                     |\n| 0x1   | FEEDBACK | Feedback input                   |\n| 0x2   | LINK     | Linked other LUT as input source |\n| 0x3   | EVENT0   | Event input source 0             |\n| 0x4   | EVENT1   | Event input source 1             |\n| 0x5   | IO       | I/O-pin LUTn-IN2 input source    |\n| 0x6   | AC0      | AC0 OUT input source             |\n| 0x7   | TCB0     | TCB0 WO input source             |\n| 0x8   | TCA0     | TCA0 WO2 input source            |\n| 0x9   | TCD0     | TCD0 WOA input source            |\n| 0xA   | -        | Reserved                         |\n| 0xB   | SPI0     | SPI0 MISO input source           |\n| Other | -        | Reserved                         |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "LUT Control 1 A",
              "reset": "0x00",
              "name": "LUT1CTRLA",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Source Selection",
                  "mask": "0x40",
                  "name": "CLKSRC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects whether the peripheral clock (CLK_PER) or any source selected by the INSEL2 bit field of the\nLUTnCTRLC register (LUTn-TRUTHSEL[2]) is used as the clock (CLK_MUX_OUTn) for an LUT.\nThe CLK_MUX_OUTn of the even LUT is used for clocking the Sequencer block of an LUT pair.\n\n\n| Value | Description                           |\n| :---- | :------------------------------------ |\n| 0     | CLK_PER is clocking the LUTn          |\n| 1     | LUTn-TRUTHSEL[2] is clocking the LUTn |\n\n"
                },
                {
                  "caption": "Edge Detection Enable",
                  "mask": "0x80",
                  "name": "EDGEDET",
                  "rw": "RW",
                  "values_ref": "CCL_EDGEDET",
                  "description": "\n\n| Value | Description               |\n| :---- | :------------------------ |\n| 0     | Edge detector is disabled |\n| 1     | Edge detector is enabled  |\n\n"
                },
                {
                  "caption": "LUT Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description         |\n| :---- | :------------------ |\n| 0     | The LUT is disabled |\n| 1     | The LUT is enabled  |\n\n"
                },
                {
                  "caption": "Filter Selection",
                  "mask": "0x30",
                  "name": "FILTSEL",
                  "rw": "RW",
                  "values_ref": "CCL_FILTSEL",
                  "description": "This bit field selects the LUT output filter options.\n\n\n| Value | Name    | Description          |\n| :---- | :------ | :------------------- |\n| 0x0   | DISABLE | Filter disabled      |\n| 0x1   | SYNCH   | Synchronizer enabled |\n| 0x2   | FILTER  | Filter enabled       |\n| 0x3   | -       | Reserved             |\n\n"
                },
                {
                  "caption": "Output Enable",
                  "mask": "0x8",
                  "name": "OUTEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables the LUT output to the LUTnOUT pin. When written to '1', the pin configuration of the PORT I/O\nController is overridden.\n\n\n| Value | Description            |\n| :---- | :--------------------- |\n| 0     | Output to pin disabled |\n| 1     | Output to pin enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "LUT Control 1 B",
              "reset": "0x00",
              "name": "LUT1CTRLB",
              "offset": "0xA",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "LUT Input 0 Source Selection",
                  "mask": "0xf",
                  "name": "INSEL0",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL0",
                  "description": "This bit field selects the source for input 0 of LUT n.\n\n\n| Value | Name     | Description                      |\n| :---- | :------- | :------------------------------- |\n| 0x0   | MASK     | Masked input                     |\n| 0x1   | FEEDBACK | Feedback input                   |\n| 0x2   | LINK     | Linked other LUT as input source |\n| 0x3   | EVENT0   | Event input source 0             |\n| 0x4   | EVENT1   | Event input source 1             |\n| 0x5   | IO       | I/O-pin LUTn-IN0 input source    |\n| 0x6   | AC0      | AC0 OUT input source             |\n| 0x7   | TCB0     | TCB0 WO input source             |\n| 0x8   | TCA0     | TCA0 WO0 input source            |\n| 0x9   | TCD0     | TCD0 WOA input source            |\n| 0xA   | USART0   | USART0 XCK input source          |\n| 0xB   | SPI0     | SPI0 SCK input source            |\n| Other | -        | Reserved                         |\n\n"
                },
                {
                  "caption": "LUT Input 1 Source Selection",
                  "mask": "0xf0",
                  "name": "INSEL1",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL1",
                  "description": "This bit field selects the source for input 1 of LUT n.\n\n\n| Value | Name     | Description                      |\n| :---- | :------- | :------------------------------- |\n| 0x0   | MASK     | Masked input                     |\n| 0x1   | FEEDBACK | Feedback input                   |\n| 0x2   | LINK     | Linked other LUT as input source |\n| 0x3   | EVENT0   | Event input source 0             |\n| 0x4   | EVENT1   | Event input source 1             |\n| 0x5   | IO       | I/O-pin LUTn-IN1 input source    |\n| 0x6   | AC0      | AC0 OUT input source             |\n| 0x7   | TCB0     | TCB0 WO input source             |\n| 0x8   | TCA0     | TCA0 WO1 input source            |\n| 0x9   | TCD0     | TCD0 WOB input source            |\n| 0xA   | USART0   | USART0 TXD input source          |\n| 0xB   | SPI0     | SPI0 MOSI input source           |\n| Other | -        | Reserved                         |\n\n"
                }
              ],
              "description": "Notes:\n1. SPI connections to the CCL work in Host SPI mode only.\n2. USART connections to the CCL work only when the USART is in one of the following modes:\n- Asynchronous USART\n- Synchronous USART Host"
            },
            {
              "caption": "LUT Control 1 C",
              "reset": "0x00",
              "name": "LUT1CTRLC",
              "offset": "0xB",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "LUT Input 2 Source Selection",
                  "mask": "0xf",
                  "name": "INSEL2",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL2",
                  "description": "This bit field selects the source for input 2 of LUT n.\n\n\n| Value | Name     | Description                      |\n| :---- | :------- | :------------------------------- |\n| 0x0   | MASK     | Masked input                     |\n| 0x1   | FEEDBACK | Feedback input                   |\n| 0x2   | LINK     | Linked other LUT as input source |\n| 0x3   | EVENT0   | Event input source 0             |\n| 0x4   | EVENT1   | Event input source 1             |\n| 0x5   | IO       | I/O-pin LUTn-IN2 input source    |\n| 0x6   | AC0      | AC0 OUT input source             |\n| 0x7   | TCB0     | TCB0 WO input source             |\n| 0x8   | TCA0     | TCA0 WO2 input source            |\n| 0x9   | TCD0     | TCD0 WOA input source            |\n| 0xA   | -        | Reserved                         |\n| 0xB   | SPI0     | SPI0 MISO input source           |\n| Other | -        | Reserved                         |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Sequential Control 0",
              "reset": "0x00",
              "name": "SEQCTRL0",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Sequential Selection",
                  "mask": "0x7",
                  "name": "SEQSEL",
                  "rw": "RW",
                  "values_ref": "CCL_SEQSEL",
                  "description": "This bit field selects how many consecutive ADC sampling results are accumulated automatically. When this bit is\nwritten to a value greater than 0x0, the according number of consecutive ADC sampling results are accumulated into\nthe ADC Result (ADCn.RES) register in one complete conversion.\n\n\n| Value | Name  | Description            |\n| :---- | :---- | :--------------------- |\n| 0x0   | NONE  | No accumulation        |\n| 0x1   | ACC2  | 2 results accumulated  |\n| 0x2   | ACC4  | 4 results accumulated  |\n| 0x3   | ACC8  | 8 results accumulated  |\n| 0x4   | ACC16 | 16 results accumulated |\n| 0x5   | ACC32 | 32 results accumulated |\n| 0x6   | ACC64 | 64 results accumulated |\n| 0x7   | -     | Reserved               |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Truth 0",
              "reset": null,
              "name": "TRUTH0",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "TRUTH0",
                  "caption": "Truth Table",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits determine the output of LUTn according to the LUTn-TRUTHSEL[2:0] inputs.\nBit Name Value Description\nTRUTHn[0]\n0 The output of LUTn is 0 when the inputs are 'b000\n1 The output of LUTn is 1 when the inputs are 'b000\nTRUTHn[1]\n0 The output of LUTn is 0 when the inputs are 'b001\n1 The output of LUTn is 1 when the inputs are 'b001\nTRUTHn[2]\n0 The output of LUTn is 0 when the inputs are 'b010\n1 The output of LUTn is 1 when the inputs are 'b010\nTRUTHn[3]\n0 The output of LUTn is 0 when the inputs are 'b011\n1 The output of LUTn is 1 when the inputs are 'b011\nTRUTHn[4]\n0 The output of LUTn is 0 when the inputs are 'b100\n1 The output of LUTn is 1 when the inputs are 'b100\nTRUTHn[5]\n0 The output of LUTn is 0 when the inputs are 'b101\n1 The output of LUTn is 1 when the inputs are 'b101\nTRUTHn[6]\n0 The output of LUTn is 0 when the inputs are 'b110\n1 The output of LUTn is 1 when the inputs are 'b110\nTRUTHn[7]\n0 The output of LUTn is 0 when the inputs are 'b111\n1 The output of LUTn is 1 when the inputs are 'b111"
                }
              ],
              "description": null
            },
            {
              "caption": "Truth 1",
              "reset": null,
              "name": "TRUTH1",
              "offset": "0xC",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "TRUTH1",
                  "caption": "Truth Table",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits determine the output of LUTn according to the LUTn-TRUTHSEL[2:0] inputs.\nBit Name Value Description\nTRUTHn[0]\n0 The output of LUTn is 0 when the inputs are 'b000\n1 The output of LUTn is 1 when the inputs are 'b000\nTRUTHn[1]\n0 The output of LUTn is 0 when the inputs are 'b001\n1 The output of LUTn is 1 when the inputs are 'b001\nTRUTHn[2]\n0 The output of LUTn is 0 when the inputs are 'b010\n1 The output of LUTn is 1 when the inputs are 'b010\nTRUTHn[3]\n0 The output of LUTn is 0 when the inputs are 'b011\n1 The output of LUTn is 1 when the inputs are 'b011\nTRUTHn[4]\n0 The output of LUTn is 0 when the inputs are 'b100\n1 The output of LUTn is 1 when the inputs are 'b100\nTRUTHn[5]\n0 The output of LUTn is 0 when the inputs are 'b101\n1 The output of LUTn is 1 when the inputs are 'b101\nTRUTHn[6]\n0 The output of LUTn is 0 when the inputs are 'b110\n1 The output of LUTn is 1 when the inputs are 'b110\nTRUTHn[7]\n0 The output of LUTn is 0 when the inputs are 'b111\n1 The output of LUTn is 1 when the inputs are 'b111"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Clock controller",
      "id": "I2600",
      "name": "CLKCTRL",
      "register_groups": [
        {
          "caption": "Clock controller",
          "name": "CLKCTRL",
          "size": "0x20",
          "registers": [
            {
              "caption": "MCLK Control A",
              "reset": "0x00",
              "name": "MCLKCTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "System clock out",
                  "mask": "0x80",
                  "name": "CLKOUT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', the system clock is output to the CLKOUT pin. The CLKOUT pin is available for devices\nwith 20 pins or more. See section 5.  I/O Multiplexing and Considerations for more information.\nWhen the device is in a sleep mode, there is no clock output unless a peripheral is using the system clock."
                },
                {
                  "caption": "clock select",
                  "mask": "0x3",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "CLKCTRL_CLKSEL",
                  "description": "This bit field selects the source for the Main Clock (CLK_MAIN).\n\n\n| Value | Name      | Description                                    |\n| :---- | :-------- | :--------------------------------------------- |\n| 0x0   | OSC20M    | 16/20 MHz internal oscillator                  |\n| 0x1   | OSCULP32K | 32.768 kHz internal ultra low-power oscillator |\n| 0x2   | XOSC32K   | 32.768 kHz external crystal oscillator         |\n| 0x3   | EXTCLK    | External clock                                 |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "MCLK Control B",
              "reset": "0x00",
              "name": "MCLKCTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Prescaler division",
                  "mask": "0x1e",
                  "name": "PDIV",
                  "rw": "RW",
                  "values_ref": "CLKCTRL_PDIV",
                  "description": "If the Prescaler Enable (PEN) bit is written to '1', this bit field defines the division ratio of the main clock prescaler.\nThis bit field can be written during run-time to vary the clock frequency of the system to suit the application\nrequirements.\nThe user software must ensure a correct configuration of input frequency (CLK_MAIN) and prescaler settings, such\nthat the resulting frequency of CLK_PER never exceeds the allowed maximum (see Electrical Characteristics).\n\n\n| Value | Description |\n| :---- | :---------- |\n| Value | Division    |\n| 0x0   | 2           |\n| 0x1   | 4           |\n| 0x2   | 8           |\n| 0x3   | 16          |\n| 0x4   | 32          |\n| 0x5   | 64          |\n| 0x8   | 6           |\n| 0x9   | 10          |\n| 0xA   | 12          |\n| 0xB   | 24          |\n| 0xC   | 48          |\n| other | Reserved    |\n\n"
                },
                {
                  "caption": "Prescaler enable",
                  "mask": "0x1",
                  "name": "PEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit must be written '1' to enable the prescaler. When enabled, the division ratio is selected by the PDIV bit field.\nWhen this bit is written to '0', the main clock will pass through undivided (CLK_PER=CLK_MAIN), regardless of the\nvalue of PDIV."
                }
              ],
              "description": null
            },
            {
              "caption": "MCLK Lock",
              "reset": null,
              "name": "MCLKLOCK",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "lock ebable",
                  "mask": "0x1",
                  "name": "LOCKEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' will lock the CLKCTRL.MCLKCTRLA and CLKCTRL.MCLKCTRLB registers and, if applicable,\nthe calibration settings for the current main clock source from further software updates. Once locked, the\nCLKCTRL.MCLKLOCK registers cannot be accessed until the next hardware Reset.\nThis protects the CLKCTRL.MCLKCTRLA and CLKCTRL.MCLKCTRLB registers and calibration settings for the main\nclock source from unintentional modification by software.\nAt Reset, the LOCKEN bit is loaded based on the OSCLOCK bit in FUSE.OSCCFG."
                }
              ],
              "description": null
            },
            {
              "caption": "MCLK Status",
              "reset": "0x00",
              "name": "MCLKSTATUS",
              "offset": "0x03",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "External Clock status",
                  "mask": "0x80",
                  "name": "EXTS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "\n\n| Value | Description            |\n| :---- | :--------------------- |\n| 0     | EXTCLK has not started |\n| 1     | EXTCLK has started     |\n\n"
                },
                {
                  "caption": "20MHz oscillator status",
                  "mask": "0x10",
                  "name": "OSC20MS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The Status bit will only be available if the source is requested as the main clock or by another module. If the oscillator\nRUNSTDBY bit is set, but the oscillator is unused/not requested, this bit will be '0'.\n\n\n| Value | Description          |\n| :---- | :------------------- |\n| 0     | OSC20M is not stable |\n| 1     | OSC20M is stable     |\n\n"
                },
                {
                  "caption": "32KHz oscillator status",
                  "mask": "0x20",
                  "name": "OSC32KS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The Status bit will only be available if the source is requested as the main clock or by another module. If the oscillator\nRUNSTDBY bit is set, but the oscillator is unused/not requested, this bit will be '0'.\n\n\n| Value | Description             |\n| :---- | :---------------------- |\n| 0     | OSCULP32K is not stable |\n| 1     | OSCULP32K is stable     |\n\n"
                },
                {
                  "caption": "System Oscillator changing",
                  "mask": "0x1",
                  "name": "SOSC",
                  "rw": "R",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                                       |\n| :---- | :------------------------------------------------------------------------------------------------ |\n| 0     | The clock source for CLK_MAIN is not undergoing a switch                                          |\n| 1     | The clock source for CLK_MAIN is undergoing a switch and will change as soon as the new source is |\n\n\nstable"
                },
                {
                  "caption": "32.768 kHz Crystal Oscillator status",
                  "mask": "0x40",
                  "name": "XOSC32KS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The Status bit will only be available if the source is requested as the main clock or by another module. If the oscillator\nRUNSTDBY bit is set, but the oscillator is unused/not requested, this bit will be '0'.\n\n\n| Value | Description           |\n| :---- | :-------------------- |\n| 0     | XOSC32K is not stable |\n| 1     | XOSC32K is stable     |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "OSC20M Calibration A",
              "reset": "0x00",
              "name": "OSC20MCALIBA",
              "offset": "0x11",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Calibration",
                  "mask": "0x3f",
                  "name": "CAL20M",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field changes the frequency around the current center frequency of the OSC20M for fine-tuning.\nAt Reset, the factory-calibrated values are loaded based on the FREQSEL bits in FUSE.OSCCFG."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC20M Calibration B",
              "reset": "0x00",
              "name": "OSC20MCALIBB",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Lock",
                  "mask": "0x80",
                  "name": "LOCK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is set, the calibration settings in CLKCTRL.OSC20MCALIBA and CLKCTRL.OSC20MCALIBB cannot\nbe changed.\nAt Reset, the value is loaded from the OSCLOCK bit in the Oscillator Configuration (FUSE.OSCCFG) fuse."
                },
                {
                  "caption": "Oscillator temperature coefficient",
                  "mask": "0xf",
                  "name": "TEMPCAL20M",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field tunes the slope of the temperature compensation.\nAt Reset, the factory-calibrated values are loaded based on the FREQSEL bits in FUSE.OSCCFG."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC20M Control A",
              "reset": null,
              "name": "OSC20MCTRLA",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run standby",
                  "mask": "0x2",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit forces the oscillator ON in all modes, even when unused by the system. In Standby sleep mode, this can be\nused to ensure immediate wake-up and not waiting for the oscillator start-up time.\nWhen not requested by peripherals, no oscillator output is provided.\nIt takes four oscillator cycles to open the clock gate after a request, but the oscillator analog start-up time will be\nremoved when this bit is set."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC32K Control A",
              "reset": "0x00",
              "name": "OSC32KCTRLA",
              "offset": "0x18",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run standby",
                  "mask": "0x2",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit forces the oscillator ON in all modes, even when unused by the system. In Standby sleep mode, this can be\nused to ensure immediate wake-up and not waiting for the oscillator start-up time.\nWhen not requested by peripherals, no oscillator output is provided.\nIt takes four oscillator cycles to open the clock gate after a request, but the oscillator analog start-up time will be\nremoved when this bit is set."
                }
              ],
              "description": null
            },
            {
              "caption": "XOSC32K Control A",
              "reset": "0x00",
              "name": "XOSC32KCTRLA",
              "offset": "0x1C",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Crystal startup time",
                  "mask": "0x30",
                  "name": "CSUT",
                  "rw": "RW",
                  "values_ref": "CLKCTRL_CSUT",
                  "description": "This bit field selects the start-up time for the XOSC32K. It is write-protected when the oscillator is enabled\n(ENABLE=1).\nIf SEL=1, the start-up time will not be applied.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0x0   | 1K    | 1k cycles   |\n| 0x1   | 16K   | 16k cycles  |\n| 0x2   | 32K   | 32k cycles  |\n| 0x3   | 64K   | 64k cycles  |\n\n"
                },
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', the configuration of the respective input pins is overridden to TOSC1 and TOSC2. Also,\nthe Source Select (SEL) and Crystal Start-Up Time (CSUT) bits become read-only.\nThis bit is I/O protected to prevent any unintentional enabling of the oscillator."
                },
                {
                  "caption": "Run standby",
                  "mask": "0x2",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' starts the crystal oscillator and forces the oscillator ON in all modes, even when unused by the\nsystem if the ENABLE bit is set. In Standby sleep mode, this can be used to ensure immediate wake-up and not\nwaiting for oscillator start-up time. When this bit is '0', the crystal oscillator is only running when requested, and the\nENABLE bit is set.\nThe output of XOSC32K is not sent to other peripherals unless it is requested by one or more peripherals.\nWhen the RUNSTDBY bit is set, there will only be a delay of two to three crystal oscillator cycles after a request until\nthe oscillator output is received, if the initial crystal start-up time has already completed.\nDepending on the RUNSTDBY bit, the oscillator will be turned ON all the time if the device is in Active, Idle, or\nStandby sleep mode, or only be enabled when requested.\nThis bit is I/O protected to prevent any unintentional enabling of the oscillator."
                },
                {
                  "caption": "Select",
                  "mask": "0x4",
                  "name": "SEL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects the external source type. It is write-protected when the oscillator is enabled (ENABLE=1).\n\n\n| Value | Description                 |\n| :---- | :-------------------------- |\n| 0     | External crystal            |\n| 1     | External clock on TOSC1 pin |\n\n"
                }
              ],
              "description": "The SEL and CSUT bits cannot be changed as long as the ENABLE bit is set, or the XOSC32K Stable (XOSC32KS)\nbit in CLKCTRL.MCLKSTATUS is high.\nTo change settings safely, write a '0' to the ENABLE bit and wait until XOSC32KS is '0' before re-enabling the\nXOSC32K with new settings."
            }
          ]
        }
      ]
    },
    {
      "caption": "CPU",
      "id": "I2100",
      "name": "CPU",
      "register_groups": [
        {
          "caption": "CPU",
          "name": "CPU",
          "size": "0x10",
          "registers": [
            {
              "caption": "Configuration Change Protection",
              "reset": "0x00",
              "name": "CCP",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CCP signature",
                  "mask": "0xff",
                  "name": "CCP",
                  "rw": "RW",
                  "values_ref": "CPU_CCP",
                  "description": "Writing the correct signature to this bit field allows changing protected I/O registers or executing protected\ninstructions within the next four CPU instructions executed.\nAll interrupts are ignored during these cycles. After these cycles are completed, the interrupts will automatically be\nhandled by the CPU, and any pending interrupts will be executed according to their level and priority.\nWhen the protected I/O register signature is written, CCP[0] will read '1' as long as the CCP feature is enabled.\nWhen the protected self-programming signature is written, CCP[1] will read '1' as long as the CCP feature is enabled.\nCCP[7:2] will always read '0'.\n\n\n| Value | Name  | Description                    |\n| :---- | :---- | :----------------------------- |\n| 0x9D  | SPM   | Allow self-programming         |\n| 0xD8  | IOREG | Unlock protected I/O registers |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Stack Pointer High",
              "reset": null,
              "name": "SPH",
              "offset": "0xE",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "SP",
                  "caption": "Stack Pointer Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the LSB of the 16-bit register."
                }
              ],
              "description": "The CPU.SP register holds the Stack Pointer (SP) that points to the top of the stack. After being reset, the SP points\nto the highest internal SRAM address.\nOnly the number of bits required to address the available data memory, including external memory (up to 64 KB), is\nimplemented for each device. Unused bits will always read '0'.\nThe CPU.SPL and CPU.SPH register pair represents the 16-bit value, CPU.SP. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nTo prevent corruption when updating the SP from software, a write to CPU.SPL will automatically disable interrupts\nfor the next four instructions or until the next I/O memory write, whichever comes first."
            },
            {
              "caption": "Stack Pointer Low",
              "reset": null,
              "name": "SPL",
              "offset": "0xD",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "SP",
                  "caption": "Stack Pointer Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the LSB of the 16-bit register."
                }
              ],
              "description": "The CPU.SP register holds the Stack Pointer (SP) that points to the top of the stack. After being reset, the SP points\nto the highest internal SRAM address.\nOnly the number of bits required to address the available data memory, including external memory (up to 64 KB), is\nimplemented for each device. Unused bits will always read '0'.\nThe CPU.SPL and CPU.SPH register pair represents the 16-bit value, CPU.SP. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nTo prevent corruption when updating the SP from software, a write to CPU.SPL will automatically disable interrupts\nfor the next four instructions or until the next I/O memory write, whichever comes first."
            },
            {
              "caption": "Status Register",
              "reset": "0x00",
              "name": "SREG",
              "offset": "0xF",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Carry Flag",
                  "mask": "0x1",
                  "name": "C",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when there is a carry in an arithmetic or logic operation, and is cleared otherwise."
                },
                {
                  "caption": "Half Carry Flag",
                  "mask": "0x20",
                  "name": "H",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when there is a half carry in arithmetic operations that support this, and is cleared otherwise. Half\ncarry is useful in BCD arithmetic."
                },
                {
                  "caption": "Global Interrupt Enable Flag",
                  "mask": "0x80",
                  "name": "I",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables interrupts on the device.\nWriting a '0' to this bit disables interrupts on the device, independent of the individual interrupt enable settings of the\nperipherals.\nThis bit is not cleared by hardware while entering an Interrupt Service Routine (ISR) or set when the RETI instruction\nis executed.\nThis bit can be set and cleared by software with the SEI and CLI instructions.\nChanging the I bit through the I/O register results in a one-cycle Wait state on the access."
                },
                {
                  "caption": "Negative Flag",
                  "mask": "0x4",
                  "name": "N",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when there is a negative result in an arithmetic or logic operation, and is cleared otherwise."
                },
                {
                  "caption": "N Exclusive Or V Flag",
                  "mask": "0x10",
                  "name": "S",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is always an Exclusive Or (XOR) between the Negative flag (N) and the Two's Complement Overflow flag\n(V)."
                },
                {
                  "caption": "Transfer Bit",
                  "mask": "0x40",
                  "name": "T",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The bit copy instructions, Bit Load (BLD) and Bit Store (BST), use the T bit as source or destination for the operated\nbit."
                },
                {
                  "caption": "Two's Complement Overflow Flag",
                  "mask": "0x8",
                  "name": "V",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when there is an overflow in arithmetic operations that support this, and is cleared otherwise."
                },
                {
                  "caption": "Zero Flag",
                  "mask": "0x2",
                  "name": "Z",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when there is a zero result in an arithmetic or logic operation, and is cleared otherwise."
                }
              ],
              "description": "The Status Register contains information about the result of the most recently executed arithmetic or logic\ninstructions. For details about the bits in this register and how they are influenced by different instructions, see the\nInstruction Set Summary section."
            }
          ]
        }
      ]
    },
    {
      "caption": "Interrupt Controller",
      "id": "I2104",
      "name": "CPUINT",
      "register_groups": [
        {
          "caption": "Interrupt Controller",
          "name": "CPUINT",
          "size": "0x4",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compact Vector Table",
                  "mask": "0x20",
                  "name": "CVT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is protected by the Configuration Change Protection mechanism.\n\n\n| Value | Description                               |\n| :---- | :---------------------------------------- |\n| 0     | Compact Vector Table function is disabled |\n| 1     | Compact Vector Table function is enabled  |\n\n"
                },
                {
                  "caption": "Interrupt Vector Select",
                  "mask": "0x40",
                  "name": "IVSEL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is protected by the Configuration Change Protection mechanism.\n\n\n| Value | Description                                                                |\n| :---- | :------------------------------------------------------------------------- |\n| 0     | Interrupt vectors are placed after the BOOT section of the Flash(1)        |\n| 1     | Interrupt vectors are placed at the start of the BOOT section of the Flash |\n\n\nNote:"
                },
                {
                  "caption": "Round-robin Scheduling Enable",
                  "mask": "0x1",
                  "name": "LVL0RR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is not protected by the Configuration Change Protection mechanism.\n\n\n| Value | Description                                                                                            |\n| :---- | :----------------------------------------------------------------------------------------------------- |\n| 0     | Priority is fixed for priority level 0 interrupt requests: The lowest interrupt vector address has the |\n\n\nhighest priority.\n1 The round robin priority scheme is enabled for priority level 0 interrupt requests"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Level 0 Priority",
              "reset": "0x00",
              "name": "LVL0PRI",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Interrupt Level Priority",
                  "mask": "0xff",
                  "name": "LVL0PRI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This register is used to modify the priority of the LVL0 interrupts. See the section Normal-Priority Interrupts for more\ninformation."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Level 1 Priority Vector",
              "reset": "0x00",
              "name": "LVL1VEC",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Interrupt Vector with High Priority",
                  "mask": "0xff",
                  "name": "LVL1VEC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field contains the number of the single vector with increased priority level 1 (LVL1). If this bit field has the\nvalue 0x00, no vector has LVL1. Consequently, the LVL1 interrupt is disabled."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Level 0 Interrupt Executing",
                  "mask": "0x1",
                  "name": "LVL0EX",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when a priority level 0 interrupt is executing, or when the interrupt handler has been interrupted by a\npriority level 1 interrupt or an NMI. The flag is cleared when returning (RETI) from the interrupt handler."
                },
                {
                  "caption": "Level 1 Interrupt Executing",
                  "mask": "0x2",
                  "name": "LVL1EX",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when a priority level 1 interrupt is executing, or when the interrupt handler has been interrupted by an\nNMI. The flag is cleared when returning (RETI) from the interrupt handler."
                },
                {
                  "caption": "Non-maskable Interrupt Executing",
                  "mask": "0x80",
                  "name": "NMIEX",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set if a non-maskable interrupt is executing. The flag is cleared when returning (RETI) from the interrupt\nhandler."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "CRCSCAN",
      "id": "I2122",
      "name": "CRCSCAN",
      "register_groups": [
        {
          "caption": "CRCSCAN",
          "name": "CRCSCAN",
          "size": "0x4",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable CRC scan",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the CRCSCAN peripheral with the current settings. It will stay '1' even after a CRC\ncheck has completed, but writing it to '1' again will start a new check.\nWriting the bit to '0' has no effect\nThe CRCSCAN can be configured to run a scan during the MCU start-up sequence to verify the Flash sections\nbefore letting the CPU start normal code execution (see the 27.3.1  Initialization section). If this feature is enabled,\nthe ENABLE bit will read as '1' when normal code execution starts.\nTo see whether the CRCSCAN peripheral is busy with an ongoing check, poll the BUSY bit in the Status register\n(CRCSCAN.STATUS)."
                },
                {
                  "caption": "Enable NMI Trigger",
                  "mask": "0x2",
                  "name": "NMIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', any CRC failure will trigger an NMI.\nThis bit can only be cleared by a system Reset - it is not cleared by a write to the RESET bit.\nThis bit can only be written to '1' when the CRCSCAN is not busy (the BUSY bit in CRCSCAN.STATUS is '0')."
                },
                {
                  "caption": "Reset CRC scan",
                  "mask": "0x80",
                  "name": "RESET",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' resets the CRCSCAN peripheral. The CRCSCAN Control registers and Status register\n(CRCSCAN.CTRLA, CRCSCAN.CTRLB, CRCSCAN.STATUS) will be cleared one clock cycle after the RESET bit is\nwritten to '1'.\nIf NMIEN is '0', this bit is writable both when the CRCSCAN is busy (the BUSY bit in CRCSCAN.STATUS is '1') and\nnot busy (the BUSY bit is '0'), and will take effect immediately.\nIf NMIEN is '1', this bit is only writable when the CRCSCAN is not busy (the BUSY bit in CRCSCAN.STATUS is '0').\nThe RESET bit is a strobe bit."
                }
              ],
              "description": "If an NMI has been triggered this register is not writable."
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CRC Flash Access Mode",
                  "mask": "0x30",
                  "name": "MODE",
                  "rw": "RW",
                  "values_ref": "CRCSCAN_MODE",
                  "description": "The CRC can be enabled during internal Reset initialization to verify Flash sections before letting the CPU start (see\nthe device data sheet fuse description). If the CRC is enabled during internal Reset initialization, the MODE bit field\nwill read out non-zero when normal code execution starts. To ensure proper operation of the CRC under code\nexecution, write the MODE bit to 0x0 again.\nValue Name Description\n0x0 PRIORITY The CRC module runs a single check with priority to Flash. The CPU is halted until the\nCRC completes.\nother - Reserved"
                },
                {
                  "caption": "CRC Source",
                  "mask": "0x3",
                  "name": "SRC",
                  "rw": "RW",
                  "values_ref": "CRCSCAN_SRC",
                  "description": "The SRC bit field selects which section of the Flash the CRC module will check. To set up section sizes, refer to the\nfuse description.\nThe CRC can be enabled during internal Reset initialization to verify Flash sections before letting the CPU start (see\nthe Fuses chapter). If the CRC is enabled during internal Reset initialization, the SRC bit field will read out as FLASH,\nBOOTAPP, or BOOT when normal code execution starts (depending on the configuration).\n\n\n| Value | Name  | Description                                                                            |\n| :---- | :---- | :------------------------------------------------------------------------------------- |\n| 0x0   | FLASH | The CRC is performed on the entire Flash (boot, application code, and application data |\n\n\nsections).\n0x1 BOOTAPP The CRC is performed on the boot and application code sections of Flash.\n0x2 BOOT The CRC is performed on the boot section of Flash.\n0x3 - Reserved."
                }
              ],
              "description": "The CRCSCAN.CTRLB register contains the mode and source settings for the CRC. It is not writable when the CRC\nis busy, or when an NMI has been triggered."
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x2",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CRC Busy",
                  "mask": "0x1",
                  "name": "BUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When this bit is read as '1', the CRCSCAN is busy. As long as the module is busy, the access to the control registers\nis limited."
                },
                {
                  "caption": "CRC Ok",
                  "mask": "0x2",
                  "name": "OK",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When this bit is read as '1', the previous CRC completed successfully. The bit is set to '1' by default before a CRC\nscan is run. The bit is not valid unless BUSY is '0'."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Digital to Analog Converter",
      "id": "I2121",
      "name": "DAC",
      "register_groups": [
        {
          "caption": "Digital to Analog Converter",
          "name": "DAC",
          "size": "0x4",
          "registers": [
            {
              "caption": "Control Register A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "DAC Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the DAC."
                },
                {
                  "caption": "Output Buffer Enable",
                  "mask": "0x40",
                  "name": "OUTEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the output buffer and sends the OUT signal to a pin."
                },
                {
                  "caption": "Run in Standby Mode",
                  "mask": "0x80",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If this bit is written to '1', the DAC or output buffer will not automatically be disabled when the device is entering\nStandby sleep mode."
                }
              ],
              "description": null
            },
            {
              "caption": "DATA Register",
              "reset": null,
              "name": "DATA",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "DATA",
                  "caption": "Data",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field contains the digital data, which will be converted to an analog voltage."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Event System",
      "id": "I2600",
      "name": "EVSYS",
      "register_groups": [
        {
          "caption": "Event System",
          "name": "EVSYS",
          "size": "0x40",
          "registers": [
            {
              "caption": "Asynchronous Channel 0 Generator Selection",
              "reset": "0x00",
              "name": "ASYNCCH0",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous Channel 0 Generator Selection",
                  "mask": "0xff",
                  "name": "ASYNCCH0",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCCH0",
                  "description": "\n\n| Value | ASYNCCH0 | ASYNCCH1 | ASYNCCH2 | ASYNCCH3 |\n| :---- | :------- | :------- | :------- | :------- |\n| 0x00  | OFF      | OFF      | OFF      | OFF      |\n\n\n0x01 CCL_LUT0\n0x02 CCL_LUT1\n0x03 AC0_OUT\n0x04 TCD0_CMPBCLR\n0x05 TCD0_CMPASET\n0x06 TCD0_CMPBSET\n0x07 TCD0_PROGEV\n0x08 RTC_OVF\n0x09 RTC_CMP\n0x0A PORTA_PIN0 PORTB_PIN0 PORTC_PIN0 PIT_DIV8192\n0x0B PORTA_PIN1 PORTB_PIN1 PORTC_PIN1 PIT_DIV4096\n0x0C PORTA_PIN2 PORTB_PIN2 PORTC_PIN2 PIT_DIV2048\n0x0D PORTA_PIN3 PORTB_PIN3 PORTC_PIN3 PIT_DIV1024\n0x0E PORTA_PIN4 PORTB_PIN4 PORTC_PIN4 PIT_DIV512\n0x0F PORTA_PIN5 PORTB_PIN5 PORTC_PIN5 PIT_DIV256\n0x10 PORTA_PIN6 PORTB_PIN6 - PIT_DIV128\n0x11 PORTA_PIN7 PORTB_PIN7 - PIT_DIV64\n0x12 UPDI - - -\nOther - - - -\nNote: Not all pins of a port are available on devices with low pin counts. Check the Pinout Diagram and/or the I/O\nMultiplexing table for details."
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous Channel 1 Generator Selection",
              "reset": "0x00",
              "name": "ASYNCCH1",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous Channel 1 Generator Selection",
                  "mask": "0xff",
                  "name": "ASYNCCH1",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCCH1",
                  "description": "\n\n| Value | ASYNCCH0 | ASYNCCH1 | ASYNCCH2 | ASYNCCH3 |\n| :---- | :------- | :------- | :------- | :------- |\n| 0x00  | OFF      | OFF      | OFF      | OFF      |\n\n\n0x01 CCL_LUT0\n0x02 CCL_LUT1\n0x03 AC0_OUT\n0x04 TCD0_CMPBCLR\n0x05 TCD0_CMPASET\n0x06 TCD0_CMPBSET\n0x07 TCD0_PROGEV\n0x08 RTC_OVF\n0x09 RTC_CMP\n0x0A PORTA_PIN0 PORTB_PIN0 PORTC_PIN0 PIT_DIV8192\n0x0B PORTA_PIN1 PORTB_PIN1 PORTC_PIN1 PIT_DIV4096\n0x0C PORTA_PIN2 PORTB_PIN2 PORTC_PIN2 PIT_DIV2048\n0x0D PORTA_PIN3 PORTB_PIN3 PORTC_PIN3 PIT_DIV1024\n0x0E PORTA_PIN4 PORTB_PIN4 PORTC_PIN4 PIT_DIV512\n0x0F PORTA_PIN5 PORTB_PIN5 PORTC_PIN5 PIT_DIV256\n0x10 PORTA_PIN6 PORTB_PIN6 - PIT_DIV128\n0x11 PORTA_PIN7 PORTB_PIN7 - PIT_DIV64\n0x12 UPDI - - -\nOther - - - -\nNote: Not all pins of a port are available on devices with low pin counts. Check the Pinout Diagram and/or the I/O\nMultiplexing table for details."
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous Channel 2 Generator Selection",
              "reset": "0x00",
              "name": "ASYNCCH2",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous Channel 2 Generator Selection",
                  "mask": "0xff",
                  "name": "ASYNCCH2",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCCH2",
                  "description": "\n\n| Value | ASYNCCH0 | ASYNCCH1 | ASYNCCH2 | ASYNCCH3 |\n| :---- | :------- | :------- | :------- | :------- |\n| 0x00  | OFF      | OFF      | OFF      | OFF      |\n\n\n0x01 CCL_LUT0\n0x02 CCL_LUT1\n0x03 AC0_OUT\n0x04 TCD0_CMPBCLR\n0x05 TCD0_CMPASET\n0x06 TCD0_CMPBSET\n0x07 TCD0_PROGEV\n0x08 RTC_OVF\n0x09 RTC_CMP\n0x0A PORTA_PIN0 PORTB_PIN0 PORTC_PIN0 PIT_DIV8192\n0x0B PORTA_PIN1 PORTB_PIN1 PORTC_PIN1 PIT_DIV4096\n0x0C PORTA_PIN2 PORTB_PIN2 PORTC_PIN2 PIT_DIV2048\n0x0D PORTA_PIN3 PORTB_PIN3 PORTC_PIN3 PIT_DIV1024\n0x0E PORTA_PIN4 PORTB_PIN4 PORTC_PIN4 PIT_DIV512\n0x0F PORTA_PIN5 PORTB_PIN5 PORTC_PIN5 PIT_DIV256\n0x10 PORTA_PIN6 PORTB_PIN6 - PIT_DIV128\n0x11 PORTA_PIN7 PORTB_PIN7 - PIT_DIV64\n0x12 UPDI - - -\nOther - - - -\nNote: Not all pins of a port are available on devices with low pin counts. Check the Pinout Diagram and/or the I/O\nMultiplexing table for details."
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous Channel 3 Generator Selection",
              "reset": "0x00",
              "name": "ASYNCCH3",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous Channel 3 Generator Selection",
                  "mask": "0xff",
                  "name": "ASYNCCH3",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCCH3",
                  "description": "\n\n| Value | ASYNCCH0 | ASYNCCH1 | ASYNCCH2 | ASYNCCH3 |\n| :---- | :------- | :------- | :------- | :------- |\n| 0x00  | OFF      | OFF      | OFF      | OFF      |\n\n\n0x01 CCL_LUT0\n0x02 CCL_LUT1\n0x03 AC0_OUT\n0x04 TCD0_CMPBCLR\n0x05 TCD0_CMPASET\n0x06 TCD0_CMPBSET\n0x07 TCD0_PROGEV\n0x08 RTC_OVF\n0x09 RTC_CMP\n0x0A PORTA_PIN0 PORTB_PIN0 PORTC_PIN0 PIT_DIV8192\n0x0B PORTA_PIN1 PORTB_PIN1 PORTC_PIN1 PIT_DIV4096\n0x0C PORTA_PIN2 PORTB_PIN2 PORTC_PIN2 PIT_DIV2048\n0x0D PORTA_PIN3 PORTB_PIN3 PORTC_PIN3 PIT_DIV1024\n0x0E PORTA_PIN4 PORTB_PIN4 PORTC_PIN4 PIT_DIV512\n0x0F PORTA_PIN5 PORTB_PIN5 PORTC_PIN5 PIT_DIV256\n0x10 PORTA_PIN6 PORTB_PIN6 - PIT_DIV128\n0x11 PORTA_PIN7 PORTB_PIN7 - PIT_DIV64\n0x12 UPDI - - -\nOther - - - -\nNote: Not all pins of a port are available on devices with low pin counts. Check the Pinout Diagram and/or the I/O\nMultiplexing table for details."
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous Channel Strobe",
              "reset": "0x00",
              "name": "ASYNCSTROBE",
              "offset": "0x00",
              "rw": "W",
              "size": 1,
              "bitfields": [
                {
                  "name": "ASYNCSTROBE",
                  "caption": "Asynchronous Channel Strobe",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "If the Strobe register location is written, each event channel will be inverted for one system clock cycle (i.e., a single\nevent is generated)."
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 0 Input Selection - TCB0",
              "reset": "0x00",
              "name": "ASYNCUSER0",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 0 Input Selection - TCB0",
                  "mask": "0xff",
                  "name": "ASYNCUSER0",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER0",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 1 Input Selection - ADC0",
              "reset": "0x00",
              "name": "ASYNCUSER1",
              "offset": "0x13",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 1 Input Selection - ADC0",
                  "mask": "0xff",
                  "name": "ASYNCUSER1",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER1",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0",
              "reset": "0x00",
              "name": "ASYNCUSER2",
              "offset": "0x14",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0",
                  "mask": "0xff",
                  "name": "ASYNCUSER2",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER2",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0",
              "reset": "0x00",
              "name": "ASYNCUSER3",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0",
                  "mask": "0xff",
                  "name": "ASYNCUSER3",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER3",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1",
              "reset": "0x00",
              "name": "ASYNCUSER4",
              "offset": "0x16",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1",
                  "mask": "0xff",
                  "name": "ASYNCUSER4",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER4",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1",
              "reset": "0x00",
              "name": "ASYNCUSER5",
              "offset": "0x17",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1",
                  "mask": "0xff",
                  "name": "ASYNCUSER5",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER5",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 6 Input Selection - TCD0 Event 0",
              "reset": "0x00",
              "name": "ASYNCUSER6",
              "offset": "0x18",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 6 Input Selection - TCD0 Event 0",
                  "mask": "0xff",
                  "name": "ASYNCUSER6",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER6",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 7 Input Selection - TCD0 Event 1",
              "reset": "0x00",
              "name": "ASYNCUSER7",
              "offset": "0x19",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 7 Input Selection - TCD0 Event 1",
                  "mask": "0xff",
                  "name": "ASYNCUSER7",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER7",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 8 Input Selection - Event Out 0",
              "reset": "0x00",
              "name": "ASYNCUSER8",
              "offset": "0x1A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 8 Input Selection - Event Out 0",
                  "mask": "0xff",
                  "name": "ASYNCUSER8",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER8",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 9 Input Selection - Event Out 1",
              "reset": "0x00",
              "name": "ASYNCUSER9",
              "offset": "0x1B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 9 Input Selection - Event Out 1",
                  "mask": "0xff",
                  "name": "ASYNCUSER9",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER9",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 10 Input Selection - Event Out 2",
              "reset": "0x00",
              "name": "ASYNCUSER10",
              "offset": "0x1C",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 10 Input Selection - Event Out 2",
                  "mask": "0xff",
                  "name": "ASYNCUSER10",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER10",
                  "description": "\n\n| ASYNCUSERn | User Multiplexer | Description               |\n| :--------- | :--------------- | :------------------------ |\n| 0          | TCB0             | Timer/Counter B 0         |\n| 1          | ADC0             | ADC 0                     |\n| 2          | CCL_LUT0EV0      | CCL LUT0 Event 0          |\n| 3          | CCL_LUT1EV0      | CCL LUT1 Event 0          |\n| 4          | CCL_LUT0EV1      | CCL LUT0 Event 1          |\n| 5          | CCL_LUT1EV1      | CCL LUT1 Event 1          |\n| 6          | TCD0_EV0         | Timer Counter D 0 Event 0 |\n| 7          | TCD0_EV1         | Timer Counter D 0 Event 1 |\n| 8          | EVOUT0           | Event OUT 0               |\n| 9          | EVOUT1           | Event OUT 1               |\n| 10         | EVOUT2           | Event OUT 2               |\n\n\n\n\n| Value | Name     |\n| :---- | :------- |\n| 0x0   | OFF      |\n| 0x1   | SYNCCH0  |\n| 0x2   | SYNCCH1  |\n| 0x3   | ASYNCCH0 |\n| 0x4   | ASYNCCH1 |\n| 0x5   | ASYNCCH2 |\n| 0x6   | ASYNCCH3 |\n| Other | -        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Synchronous Channel 0 Generator Selection",
              "reset": "0x00",
              "name": "SYNCCH0",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Synchronous Channel 0 Generator Selection",
                  "mask": "0xff",
                  "name": "SYNCCH0",
                  "rw": "RW",
                  "values_ref": "EVSYS_SYNCCH0",
                  "description": "Value SYNCCH0 SYNCCH1\n0x00 OFF\n0x01 TCB0\n0x02 TCA0_OVF_LUNF\n0x03 TCA0_HUNF\n0x04 TCA0_CMP0\n0x05 TCA0_CMP1\n0x06 TCA0_CMP2\n0x07 PORTC_PIN0 -\n0x08 PORTC_PIN1 PORTB_PIN0\n0x09 PORTC_PIN2 PORTB_PIN1\n0x0A PORTC_PIN3 PORTB_PIN2\n0x0B PORTC_PIN4 PORTB_PIN3\n0x0C PORTC_PIN5 PORTB_PIN4\n0x0D PORTA_PIN0 PORTB_PIN5\n0x0E PORTA_PIN1 PORTB_PIN6\n0x0F PORTA_PIN2 PORTB_PIN7\n0x10 PORTA_PIN3 -\n0x11 PORTA_PIN4 -\n0x12 PORTA_PIN5 -\n0x13 PORTA_PIN6 -\n0x14 PORTA_PIN7 -\nOther - -\nNote: Not all pins of a port are available on devices with low pin counts. Check the Pinout Diagram and/or the I/O\nMultiplexing table for details."
                }
              ],
              "description": null
            },
            {
              "caption": "Synchronous Channel 1 Generator Selection",
              "reset": "0x00",
              "name": "SYNCCH1",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Synchronous Channel 1 Generator Selection",
                  "mask": "0xff",
                  "name": "SYNCCH1",
                  "rw": "RW",
                  "values_ref": "EVSYS_SYNCCH1",
                  "description": "Value SYNCCH0 SYNCCH1\n0x00 OFF\n0x01 TCB0\n0x02 TCA0_OVF_LUNF\n0x03 TCA0_HUNF\n0x04 TCA0_CMP0\n0x05 TCA0_CMP1\n0x06 TCA0_CMP2\n0x07 PORTC_PIN0 -\n0x08 PORTC_PIN1 PORTB_PIN0\n0x09 PORTC_PIN2 PORTB_PIN1\n0x0A PORTC_PIN3 PORTB_PIN2\n0x0B PORTC_PIN4 PORTB_PIN3\n0x0C PORTC_PIN5 PORTB_PIN4\n0x0D PORTA_PIN0 PORTB_PIN5\n0x0E PORTA_PIN1 PORTB_PIN6\n0x0F PORTA_PIN2 PORTB_PIN7\n0x10 PORTA_PIN3 -\n0x11 PORTA_PIN4 -\n0x12 PORTA_PIN5 -\n0x13 PORTA_PIN6 -\n0x14 PORTA_PIN7 -\nOther - -\nNote: Not all pins of a port are available on devices with low pin counts. Check the Pinout Diagram and/or the I/O\nMultiplexing table for details."
                }
              ],
              "description": null
            },
            {
              "caption": "Synchronous Channel Strobe",
              "reset": "0x00",
              "name": "SYNCSTROBE",
              "offset": "0x01",
              "rw": "W",
              "size": 1,
              "bitfields": [
                {
                  "name": "SYNCSTROBE",
                  "caption": "Synchronous Channel Strobe",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "If the Strobe register location is written, each event channel will be inverted for one system clock cycle (i.e., a single\nevent is generated)."
                }
              ],
              "description": null
            },
            {
              "caption": "Synchronous User Ch 0 Input Selection - TCA0",
              "reset": "0x00",
              "name": "SYNCUSER0",
              "offset": "0x22",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Synchronous User Ch 0 Input Selection - TCA0",
                  "mask": "0xff",
                  "name": "SYNCUSER0",
                  "rw": "RW",
                  "values_ref": "EVSYS_SYNCUSER0",
                  "description": "SYNCUSERn User Multiplexer Description\n0 TCA0 Timer/Counter A\n1 USART0 USART\n\n\n| Value | Name    |\n| :---- | :------ |\n| 0x0   | OFF     |\n| 0x1   | SYNCCH0 |\n| 0x2   | SYNCCH1 |\n| Other | -       |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Synchronous User Ch 1 Input Selection - USART0",
              "reset": "0x00",
              "name": "SYNCUSER1",
              "offset": "0x23",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Synchronous User Ch 1 Input Selection - USART0",
                  "mask": "0xff",
                  "name": "SYNCUSER1",
                  "rw": "RW",
                  "values_ref": "EVSYS_SYNCUSER1",
                  "description": "SYNCUSERn User Multiplexer Description\n0 TCA0 Timer/Counter A\n1 USART0 USART\n\n\n| Value | Name    |\n| :---- | :------ |\n| 0x0   | OFF     |\n| 0x1   | SYNCCH0 |\n| 0x2   | SYNCCH1 |\n| Other | -       |\n\n"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Fuses",
      "id": "I2600",
      "name": "FUSE",
      "register_groups": [
        {
          "caption": "Fuses",
          "name": "FUSE",
          "size": "0x09",
          "registers": [
            {
              "caption": "Application Code Section End",
              "reset": "0x00",
              "name": "APPEND",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "APPEND",
                  "caption": "Application Code Section End",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field sets the end of the application code section in blocks of 256 bytes. The end of the application code\nsection will be set as (BOOT size) + (application code size). The remaining Flash will be application data. A value of\n0x00 defines the Flash from BOOTEND*256 to the end of Flash as the application code. When both FUSE.APPEND\nand FUSE.BOOTEND are 0x00, the entire Flash is the BOOT section."
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value."
            },
            {
              "caption": "BOD Configuration",
              "reset": "0x00",
              "name": "BODCFG",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "BOD Operation in Active Mode",
                  "mask": "0xc",
                  "name": "ACTIVE",
                  "rw": "RW",
                  "values_ref": "FUSE_ACTIVE",
                  "description": "This value is loaded into the ACTIVE bit field of the BOD Control A (BOD.CTRLA) register during Reset.\n\n\n| Value | Description                                    |\n| :---- | :--------------------------------------------- |\n| 0x0   | Disabled                                       |\n| 0x1   | Enabled                                        |\n| 0x2   | Sampled                                        |\n| 0x3   | Enabled with wake-up halted until BOD is ready |\n\n"
                },
                {
                  "caption": "BOD Level",
                  "mask": "0xe0",
                  "name": "LVL",
                  "rw": "RW",
                  "values_ref": "FUSE_LVL",
                  "description": "This value is loaded into the LVL bit field of the BOD Control B (BOD.CTRLB) register during Reset.\n\n\n| Value | Name      | Description |\n| :---- | :-------- | :---------- |\n| 0x0   | BODLEVEL0 | 1.8V        |\n| 0x2   | BODLEVEL2 | 2.6V        |\n| 0x7   | BODLEVEL7 | 4.2V        |\n\n\nNotes:\n* The values in the description are typical\n* Refer to the BOD and POR Characteristics in Electrical Characteristics for maximum and minimum values"
                },
                {
                  "caption": "BOD Sample Frequency",
                  "mask": "0x10",
                  "name": "SAMPFREQ",
                  "rw": "RW",
                  "values_ref": "FUSE_SAMPFREQ",
                  "description": "This value is loaded into the SAMPFREQ bit of the BOD Control A (BOD.CTRLA) register during Reset.\n\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0x0   | Sample frequency is 1 kHz  |\n| 0x1   | Sample frequency is 125 Hz |\n\n"
                },
                {
                  "caption": "BOD Operation in Sleep Mode",
                  "mask": "0x3",
                  "name": "SLEEP",
                  "rw": "RW",
                  "values_ref": "FUSE_SLEEP",
                  "description": "This value is loaded into the SLEEP bit field of the BOD Control A (BOD.CTRLA) register during Reset.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | Disabled    |\n| 0x1   | Enabled     |\n| 0x2   | Sampled     |\n| 0x3   | Reserved    |\n\n"
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value.\nThe bit values of this fuse register are written to the corresponding BOD configuration registers at the start-up."
            },
            {
              "caption": "Boot Section End",
              "reset": "0x00",
              "name": "BOOTEND",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "BOOTEND",
                  "caption": "Boot Section End",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field sets the end of the boot section in blocks of 256 bytes. A value of 0x00 defines the whole Flash as the\nBOOT section. When both FUSE.APPEND and FUSE.BOOTEND are 0x00, the entire Flash is the BOOT section."
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value."
            },
            {
              "caption": "Oscillator Configuration",
              "reset": "0x02",
              "name": "OSCCFG",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Frequency Select",
                  "mask": "0x3",
                  "name": "FREQSEL",
                  "rw": "RW",
                  "values_ref": "FUSE_FREQSEL",
                  "description": "This bit field selects the operation frequency of the 16/20 MHz internal oscillator (OSC20M) and determines the\nrespective factory calibration values to be written to CAL20M in CLKCTRL.OSC20MCALIBA and TEMPCAL20M in\nCLKCTRL.OSC20MCALIBB.\n\n\n| Value | Description                                          |\n| :---- | :--------------------------------------------------- |\n| 0x1   | Run at 16 MHz with corresponding factory calibration |\n| 0x2   | Run at 20 MHz with corresponding factory calibration |\n| Other | Reserved                                             |\n\n"
                },
                {
                  "caption": "Oscillator Lock",
                  "mask": "0x80",
                  "name": "OSCLOCK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This Fuse bit is loaded to LOCK in CLKCTRL.OSC20MCALIBB during Reset.\n\n\n| Value | Description                                                   |\n| :---- | :------------------------------------------------------------ |\n| 0     | Calibration registers of the OSC20M oscillator are accessible |\n| 1     | Calibration registers of the OSC20M oscillator are locked     |\n\n"
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value."
            },
            {
              "caption": "System Configuration 0",
              "reset": "0xC4",
              "name": "SYSCFG0",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CRC Source",
                  "mask": "0xc0",
                  "name": "CRCSRC",
                  "rw": "RW",
                  "values_ref": "FUSE_CRCSRC",
                  "description": "This bit field controls which section of the Flash will be checked by the CRCSCAN peripheral during Reset\ninitialization.\n\n\n| Value | Name    | Description                                                     |\n| :---- | :------ | :-------------------------------------------------------------- |\n| 0x0   | FLASH   | CRC of full Flash (boot, application code and application data) |\n| 0x1   | BOOT    | CRC of the boot section                                         |\n| 0x2   | BOOTAPP | CRC of application code and boot sections                       |\n| 0x3   | NOCRC   | No CRC                                                          |\n\n"
                },
                {
                  "caption": "EEPROM Save",
                  "mask": "0x1",
                  "name": "EESAVE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Note: If the device is locked, the EEPROM is always erased by a chip erase, regardless of this bit.\n\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0     | EEPROM erased during chip erase    |\n| 1     | EEPROM not erased under chip erase |\n\n"
                },
                {
                  "caption": "Reset Pin Configuration",
                  "mask": "0xc",
                  "name": "RSTPINCFG",
                  "rw": "RW",
                  "values_ref": "FUSE_RSTPINCFG",
                  "description": "This bit field selects the Reset/UPDI pin configuration.\n\n\n| Value | Description                                                                                                 |\n| :---- | :---------------------------------------------------------------------------------------------------------- |\n| 0x0   | GPIO                                                                                                        |\n| 0x1   | UPDI                                                                                                        |\n| 0x2   | RESET                                                                                                       |\n| Other | Reserved                                                                                                    |\n| Note: | When configuring the RESET pin as GPIO, there is a potential conflict between the GPIO actively driving the |\n\n\noutput, and a high-voltage UPDI enable sequence initiation. To avoid this, the GPIO output driver is disabled for 768\nOSC32K cycles after a System Reset. Enable any interrupts for this pin only after this period."
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value."
            },
            {
              "caption": "System Configuration 1",
              "reset": "0x07",
              "name": "SYSCFG1",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Startup Time",
                  "mask": "0x7",
                  "name": "SUT",
                  "rw": "RW",
                  "values_ref": "FUSE_SUT",
                  "description": "This bit field selects the start-up time between power-on and code execution.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | 0 ms        |\n| 0x1   | 1 ms        |\n| 0x2   | 2 ms        |\n| 0x3   | 4 ms        |\n| 0x4   | 8 ms        |\n| 0x5   | 16 ms       |\n| 0x6   | 32 ms       |\n| 0x7   | 64 ms       |\n\n"
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value."
            },
            {
              "caption": "TCD0 Configuration",
              "reset": "0x00",
              "name": "TCD0CFG",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare A Default Output Value",
                  "mask": "0x1",
                  "name": "CMPA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects the default state of Compare x after Reset, or when entering debug if FAULTDET is '1'.\n\n\n| Value | Description                    |\n| :---- | :----------------------------- |\n| 0     | Compare x default state is '0' |\n| 1     | Compare x default state is '1' |\n\n"
                },
                {
                  "caption": "Compare A Output Enable",
                  "mask": "0x10",
                  "name": "CMPAEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                         |\n| :---- | :---------------------------------- |\n| 0     | Compare x output on Pin is disabled |\n| 1     | Compare x output on Pin is enabled  |\n\n"
                },
                {
                  "caption": "Compare B Default Output Value",
                  "mask": "0x2",
                  "name": "CMPB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects the default state of Compare x after Reset, or when entering debug if FAULTDET is '1'.\n\n\n| Value | Description                    |\n| :---- | :----------------------------- |\n| 0     | Compare x default state is '0' |\n| 1     | Compare x default state is '1' |\n\n"
                },
                {
                  "caption": "Compare B Output Enable",
                  "mask": "0x20",
                  "name": "CMPBEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                         |\n| :---- | :---------------------------------- |\n| 0     | Compare x output on Pin is disabled |\n| 1     | Compare x output on Pin is enabled  |\n\n"
                },
                {
                  "caption": "Compare C Default Output Value",
                  "mask": "0x4",
                  "name": "CMPC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects the default state of Compare x after Reset, or when entering debug if FAULTDET is '1'.\n\n\n| Value | Description                    |\n| :---- | :----------------------------- |\n| 0     | Compare x default state is '0' |\n| 1     | Compare x default state is '1' |\n\n"
                },
                {
                  "caption": "Compare C Output Enable",
                  "mask": "0x40",
                  "name": "CMPCEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                         |\n| :---- | :---------------------------------- |\n| 0     | Compare x output on Pin is disabled |\n| 1     | Compare x output on Pin is enabled  |\n\n"
                },
                {
                  "caption": "Compare D Default Output Value",
                  "mask": "0x8",
                  "name": "CMPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects the default state of Compare x after Reset, or when entering debug if FAULTDET is '1'.\n\n\n| Value | Description                    |\n| :---- | :----------------------------- |\n| 0     | Compare x default state is '0' |\n| 1     | Compare x default state is '1' |\n\n"
                },
                {
                  "caption": "Compare D Output Enable",
                  "mask": "0x80",
                  "name": "CMPDEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                         |\n| :---- | :---------------------------------- |\n| 0     | Compare x output on Pin is disabled |\n| 1     | Compare x output on Pin is enabled  |\n\n"
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value.\nThe bit values of this fuse register are written to the corresponding bits in the TCD.FAULTCTRL register of TCD0 at\nstart-up."
            },
            {
              "caption": "Watchdog Configuration",
              "reset": "0x00",
              "name": "WDTCFG",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Watchdog Timeout Period",
                  "mask": "0xf",
                  "name": "PERIOD",
                  "rw": "RW",
                  "values_ref": "FUSE_PERIOD",
                  "description": "This value is loaded into the PERIOD bit field of the Watchdog Control A (WDT.CTRLA) register during Reset."
                },
                {
                  "caption": "Watchdog Window Timeout Period",
                  "mask": "0xf0",
                  "name": "WINDOW",
                  "rw": "RW",
                  "values_ref": "FUSE_WINDOW",
                  "description": "This value is loaded into the WINDOW bit field of the Watchdog Control A (WDT.CTRLA) register during Reset."
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value."
            }
          ]
        }
      ]
    },
    {
      "caption": "General Purpose IO",
      "id": "I2600",
      "name": "GPIO",
      "register_groups": [
        {
          "caption": "General Purpose IO",
          "name": "GPIO",
          "size": "0x4",
          "registers": [
            {
              "caption": "General Purpose IO Register 0",
              "reset": null,
              "name": "GPIOR0",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "GPIOR0",
                  "caption": "General Purpose I/O Register Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "These are general purpose registers that can be used to store data, such as global variables and flags, in the bit-\naccessible I/O memory space."
            },
            {
              "caption": "General Purpose IO Register 1",
              "reset": null,
              "name": "GPIOR1",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "GPIOR1",
                  "caption": "General Purpose I/O Register Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "These are general purpose registers that can be used to store data, such as global variables and flags, in the bit-\naccessible I/O memory space."
            },
            {
              "caption": "General Purpose IO Register 2",
              "reset": null,
              "name": "GPIOR2",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "GPIOR2",
                  "caption": "General Purpose I/O Register Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "These are general purpose registers that can be used to store data, such as global variables and flags, in the bit-\naccessible I/O memory space."
            },
            {
              "caption": "General Purpose IO Register 3",
              "reset": null,
              "name": "GPIOR3",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "GPIOR3",
                  "caption": "General Purpose I/O Register Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "These are general purpose registers that can be used to store data, such as global variables and flags, in the bit-\naccessible I/O memory space."
            }
          ]
        }
      ]
    },
    {
      "caption": "Lockbit",
      "id": "I2600",
      "name": "LOCKBIT",
      "register_groups": [
        {
          "caption": "Lockbit",
          "name": "LOCKBIT",
          "size": "0x01",
          "registers": [
            {
              "caption": "Lock bits",
              "reset": "0xC5",
              "name": "LOCKBIT",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Lock Bits",
                  "mask": "0xff",
                  "name": "LB",
                  "rw": "RW",
                  "values_ref": "LOCKBIT_LB",
                  "description": "When the part is locked, UPDI cannot access the system bus, so it cannot read out anything but the System\nInformation Block (SIB).\n\n\n| Value | Description                           |\n| :---- | :------------------------------------ |\n| 0xC5  | Valid key - memory access is unlocked |\n| other | Invalid key - memory access is locked |\n\n"
                }
              ],
              "description": "The default value given in this fuse description is the factory-programmed value and should not be mistaken for the\nReset value."
            }
          ]
        }
      ]
    },
    {
      "caption": "Non-volatile Memory Controller",
      "id": "I2109",
      "name": "NVMCTRL",
      "register_groups": [
        {
          "caption": "Non-volatile Memory Controller",
          "name": "NVMCTRL",
          "size": "0x10",
          "registers": [
            {
              "caption": "Address",
              "reset": null,
              "name": "ADDR",
              "offset": "0x8",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "ADDR",
                  "caption": "Interrupt Priority Level 0",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This register is used to modify the priority of the LVL0 interrupts. See the section Normal-Priority Interrupts for more\ninformation."
                },
                {
                  "name": "ADDR",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The NVMCTRL.ADDRL and NVMCTRL.ADDRH register pair represents the 16-bit value, NVMCTRL.ADDR. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\n+ 0x01."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0x7",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "NVMCTRL_CMD",
                  "description": "Write this bit field to issue a command. The Configuration Change Protection key for self-programming (SPM) has to\nbe written within four instructions before this write.\n\n\n| Value | Name  | Description                                                              |\n| :---- | :---- | :----------------------------------------------------------------------- |\n| 0x0   | -     | No command                                                               |\n| 0x1   | WP    | Write page buffer to memory (NVMCTRL.ADDR selects which memory)          |\n| 0x2   | ER    | Erase page (NVMCTRL.ADDR selects which memory)                           |\n| 0x3   | ERWP  | Erase and write page (NVMCTRL.ADDR selects which memory)                 |\n| 0x4   | PBC   | Page buffer clear                                                        |\n| 0x5   | CHER  | Chip erase: Erase Flash and EEPROM (unless EESAVE in FUSE.SYSCFG is '1') |\n| 0x6   | EEER  | EEPROM Erase                                                             |\n| 0x7   | WFU   | Write fuse (only accessible through UPDI)                                |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Application code write protect",
                  "mask": "0x1",
                  "name": "APCWP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' prevents further updates to the Application Code section.\nThis bit can only be written to '1'. It is cleared to '0' only by Reset."
                },
                {
                  "caption": "Boot Lock",
                  "mask": "0x2",
                  "name": "BOOTLOCK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' locks the BOOT section from reading and instruction fetching.\nIf this bit is '1', a read from the BOOT section will return '0'. A fetch from the BOOT section will also return '0' as\ninstruction.\nThis bit can be written from the BOOT section only. It can only be cleared to '0' by a Reset.\nThis bit will take effect only when the BOOT section is left the first time after the bit is written."
                }
              ],
              "description": null
            },
            {
              "caption": "Data",
              "reset": null,
              "name": "DATA",
              "offset": "0x6",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "DATA",
                  "caption": "Interrupt Priority Level 0",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This register is used to modify the priority of the LVL0 interrupts. See the section Normal-Priority Interrupts for more\ninformation."
                },
                {
                  "name": "DATA",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The NVMCTRL.DATAL and NVMCTRL.DATAH register pair represents the 16-bit value, NVMCTRL.DATA. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\n+ 0x01."
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "EEPROM Ready",
                  "mask": "0x1",
                  "name": "EEREADY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the interrupt, which indicates that the EEPROM is ready for new write/erase\noperations.\nThis is a level interrupt that will be triggered only when the EEREADY flag in the INTFLAGS register is set to '0'.\nThus, the interrupt must not be enabled before triggering an NVM command, as the EEREADY flag will not be set\nbefore the NVM command issued. The interrupt may be disabled in the interrupt handler."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "EEPROM Ready",
                  "mask": "0x1",
                  "name": "EEREADY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set continuously as long as the EEPROM is not busy. This flag is cleared by writing a '1' to it."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x2",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "EEPROM busy",
                  "mask": "0x2",
                  "name": "EEBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit will read '1' when the EEPROM is busy with a command."
                },
                {
                  "caption": "Flash busy",
                  "mask": "0x1",
                  "name": "FBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit will read '1' when the Flash is busy with a command."
                },
                {
                  "caption": "Write error",
                  "mask": "0x4",
                  "name": "WRERROR",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit will read '1' when a write error has happened. A write error could be writing to different sections before doing\na page write or writing to a protected area. This bit is valid for the last operation."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "I/O Ports",
      "id": "I2103",
      "name": "PORT",
      "register_groups": [
        {
          "caption": "I/O Ports",
          "name": "PORT",
          "size": "0x20",
          "registers": [
            {
              "caption": "Data Direction",
              "reset": null,
              "name": "DIR",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "DIR",
                  "caption": "Data Direction",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver for each PORTx pin.\nThis bit field does not control the digital input buffer. The digital input buffer for pin n (Pxn) can be configured in the\nInput/Sense Configuration (ISC) bit field in the Pin n Control (PORTx.PINnCTRL) register.\nThe available configuration for each bit n in this bit field is shown in the table below.\n\n\n| Value | Description                                                               |\n| :---- | :------------------------------------------------------------------------ |\n| 0     | Pxn is configured as an input-only pin, and the output driver is disabled |\n| 1     | Pxn is configured as an output pin, and the output driver is enabled      |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Data Direction Clear",
              "reset": null,
              "name": "DIRCLR",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "DIRCLR",
                  "caption": "Data Direction Clear",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver for each PORTx pin, without using a read-modify-write operation.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will clear the corresponding bit in PORTx.DIR, which will configure pin n (Pxn) as\nan input-only pin and disable the output driver.\nReading this bit field will return the value of PORTx.DIR."
                }
              ],
              "description": null
            },
            {
              "caption": "Data Direction Set",
              "reset": null,
              "name": "DIRSET",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "DIRSET",
                  "caption": "Data Direction Set",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver for each PORTx pin, without using a read-modify-write operation.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will set the corresponding bit in PORTx.DIR, which will configure pin n (Pxn) as an\noutput pin and enable the output driver.\nReading this bit field will return the value of PORTx.DIR."
                }
              ],
              "description": null
            },
            {
              "caption": "Data Direction Toggle",
              "reset": null,
              "name": "DIRTGL",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "DIRTGL",
                  "caption": "Data Direction Toggle",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver for each PORTx pin, without using a read-modify-write operation.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will toggle the corresponding bit in PORTx.DIR.\nReading this bit field will return the value of PORTx.DIR."
                }
              ],
              "description": null
            },
            {
              "caption": "Input Value",
              "reset": null,
              "name": "IN",
              "offset": "0x08",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "IN",
                  "caption": "Input Value",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field shows the state of the PORTx pins when the digital input buffer is enabled.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will toggle the corresponding bit in PORTx.OUT.\nIf the digital input buffer is disabled, the input is not sampled, and the bit value will not change. The digital input buffer\nfor pin n (Pxn) can be configured in the Input/Sense Configuration (ISC) bit field in the Pin n Control\n(PORTx.PINnCTRL) register.\nThe available states of each bit n in this bit field is shown in the table below.\n\n\n| Value | Description                      |\n| :---- | :------------------------------- |\n| 0     | The voltage level on Pxn is low  |\n| 1     | The voltage level on Pxn is high |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Pin Interrupt",
                  "mask": "0xff",
                  "name": "INT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Pin interrupt flag n is cleared by writing a '1' to it.\nPin interrupt flag n is set when the change or state of pin n (Pxn) matches the pin's Input/Sense Configuration (ISC)\nin PORTx.PINnCTRL.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will clear Pin interrupt flag n."
                }
              ],
              "description": null
            },
            {
              "caption": "Output Value",
              "reset": null,
              "name": "OUT",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "OUT",
                  "caption": "Output Value",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver level for each PORTx pin.\nThis configuration only has an effect when the output driver (PORTx.DIR) is enabled for the corresponding pin.\nThe available configuration for each bit n in this bit field is shown in the table below.\n\n\n| Value | Description                          |\n| :---- | :----------------------------------- |\n| 0     | The pin n (Pxn) output is driven low |\n| 1     | The Pxn output is driven high        |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Output Value Clear",
              "reset": null,
              "name": "OUTCLR",
              "offset": "0x06",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "OUTCLR",
                  "caption": "Output Value Clear",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver level for each PORTx pin, without using a read-modify-write operation.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will clear the corresponding bit in PORTx.OUT, which will configure the output for\npin n (Pxn) to be driven low.\nReading this bit field will return the value of PORTx.OUT."
                }
              ],
              "description": null
            },
            {
              "caption": "Output Value Set",
              "reset": null,
              "name": "OUTSET",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "OUTSET",
                  "caption": "Output Value Set",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver level for each PORTx pin, without using a read-modify-write operation.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will set the corresponding bit in PORTx.OUT, which will configure the output for pin\nn (Pxn) to be driven high.\nReading this bit field will return the value of PORTx.OUT."
                }
              ],
              "description": null
            },
            {
              "caption": "Output Value Toggle",
              "reset": null,
              "name": "OUTTGL",
              "offset": "0x07",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "OUTTGL",
                  "caption": "Output Value Toggle",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver level for each PORTx pin, without using a read-modify-write operation.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will toggle the corresponding bit in PORTx.OUT.\nReading this bit field will return the value of PORTx.OUT."
                }
              ],
              "description": null
            },
            {
              "caption": "Pin 0 Control",
              "reset": "0x00",
              "name": "PIN0CTRL",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the input and output for pin n are inverted or not.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Input and output values are not inverted |\n| 1     | Input and output values are inverted     |\n\n"
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": "This bit field controls the input and sense configuration of pin n. The sense configuration determines how a port\ninterrupt can be triggered.\n\n\n| Value | Name          | Description                                    |\n| :---- | :------------ | :--------------------------------------------- |\n| 0x0   | INTDISABLE    | Interrupt disabled but input buffer enabled    |\n| 0x1   | BOTHEDGES     | Interrupt enabled with sense on both edges     |\n| 0x2   | RISING        | Interrupt enabled with sense on rising edge    |\n| 0x3   | FALLING       | Interrupt enabled with sense on falling edge   |\n| 0x4   | INPUT_DISABLE | Interrupt and digital input buffer disabled(1) |\n| 0x5   | LEVEL         | Interrupt enabled with sense on low level      |\n| other | \u2014             | Reserved                                       |\n\n\nNote:"
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the internal pull-up of pin n is enabled or not when the pin is configured as input-only.\n\n\n| Value | Description      |\n| :---- | :--------------- |\n| 0     | Pull-up disabled |\n| 1     | Pull-up enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Pin 1 Control",
              "reset": "0x00",
              "name": "PIN1CTRL",
              "offset": "0x11",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the input and output for pin n are inverted or not.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Input and output values are not inverted |\n| 1     | Input and output values are inverted     |\n\n"
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": "This bit field controls the input and sense configuration of pin n. The sense configuration determines how a port\ninterrupt can be triggered.\n\n\n| Value | Name          | Description                                    |\n| :---- | :------------ | :--------------------------------------------- |\n| 0x0   | INTDISABLE    | Interrupt disabled but input buffer enabled    |\n| 0x1   | BOTHEDGES     | Interrupt enabled with sense on both edges     |\n| 0x2   | RISING        | Interrupt enabled with sense on rising edge    |\n| 0x3   | FALLING       | Interrupt enabled with sense on falling edge   |\n| 0x4   | INPUT_DISABLE | Interrupt and digital input buffer disabled(1) |\n| 0x5   | LEVEL         | Interrupt enabled with sense on low level      |\n| other | \u2014             | Reserved                                       |\n\n\nNote:"
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the internal pull-up of pin n is enabled or not when the pin is configured as input-only.\n\n\n| Value | Description      |\n| :---- | :--------------- |\n| 0     | Pull-up disabled |\n| 1     | Pull-up enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Pin 2 Control",
              "reset": "0x00",
              "name": "PIN2CTRL",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the input and output for pin n are inverted or not.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Input and output values are not inverted |\n| 1     | Input and output values are inverted     |\n\n"
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": "This bit field controls the input and sense configuration of pin n. The sense configuration determines how a port\ninterrupt can be triggered.\n\n\n| Value | Name          | Description                                    |\n| :---- | :------------ | :--------------------------------------------- |\n| 0x0   | INTDISABLE    | Interrupt disabled but input buffer enabled    |\n| 0x1   | BOTHEDGES     | Interrupt enabled with sense on both edges     |\n| 0x2   | RISING        | Interrupt enabled with sense on rising edge    |\n| 0x3   | FALLING       | Interrupt enabled with sense on falling edge   |\n| 0x4   | INPUT_DISABLE | Interrupt and digital input buffer disabled(1) |\n| 0x5   | LEVEL         | Interrupt enabled with sense on low level      |\n| other | \u2014             | Reserved                                       |\n\n\nNote:"
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the internal pull-up of pin n is enabled or not when the pin is configured as input-only.\n\n\n| Value | Description      |\n| :---- | :--------------- |\n| 0     | Pull-up disabled |\n| 1     | Pull-up enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Pin 3 Control",
              "reset": "0x00",
              "name": "PIN3CTRL",
              "offset": "0x13",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the input and output for pin n are inverted or not.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Input and output values are not inverted |\n| 1     | Input and output values are inverted     |\n\n"
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": "This bit field controls the input and sense configuration of pin n. The sense configuration determines how a port\ninterrupt can be triggered.\n\n\n| Value | Name          | Description                                    |\n| :---- | :------------ | :--------------------------------------------- |\n| 0x0   | INTDISABLE    | Interrupt disabled but input buffer enabled    |\n| 0x1   | BOTHEDGES     | Interrupt enabled with sense on both edges     |\n| 0x2   | RISING        | Interrupt enabled with sense on rising edge    |\n| 0x3   | FALLING       | Interrupt enabled with sense on falling edge   |\n| 0x4   | INPUT_DISABLE | Interrupt and digital input buffer disabled(1) |\n| 0x5   | LEVEL         | Interrupt enabled with sense on low level      |\n| other | \u2014             | Reserved                                       |\n\n\nNote:"
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the internal pull-up of pin n is enabled or not when the pin is configured as input-only.\n\n\n| Value | Description      |\n| :---- | :--------------- |\n| 0     | Pull-up disabled |\n| 1     | Pull-up enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Pin 4 Control",
              "reset": "0x00",
              "name": "PIN4CTRL",
              "offset": "0x14",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the input and output for pin n are inverted or not.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Input and output values are not inverted |\n| 1     | Input and output values are inverted     |\n\n"
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": "This bit field controls the input and sense configuration of pin n. The sense configuration determines how a port\ninterrupt can be triggered.\n\n\n| Value | Name          | Description                                    |\n| :---- | :------------ | :--------------------------------------------- |\n| 0x0   | INTDISABLE    | Interrupt disabled but input buffer enabled    |\n| 0x1   | BOTHEDGES     | Interrupt enabled with sense on both edges     |\n| 0x2   | RISING        | Interrupt enabled with sense on rising edge    |\n| 0x3   | FALLING       | Interrupt enabled with sense on falling edge   |\n| 0x4   | INPUT_DISABLE | Interrupt and digital input buffer disabled(1) |\n| 0x5   | LEVEL         | Interrupt enabled with sense on low level      |\n| other | \u2014             | Reserved                                       |\n\n\nNote:"
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the internal pull-up of pin n is enabled or not when the pin is configured as input-only.\n\n\n| Value | Description      |\n| :---- | :--------------- |\n| 0     | Pull-up disabled |\n| 1     | Pull-up enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Pin 5 Control",
              "reset": "0x00",
              "name": "PIN5CTRL",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the input and output for pin n are inverted or not.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Input and output values are not inverted |\n| 1     | Input and output values are inverted     |\n\n"
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": "This bit field controls the input and sense configuration of pin n. The sense configuration determines how a port\ninterrupt can be triggered.\n\n\n| Value | Name          | Description                                    |\n| :---- | :------------ | :--------------------------------------------- |\n| 0x0   | INTDISABLE    | Interrupt disabled but input buffer enabled    |\n| 0x1   | BOTHEDGES     | Interrupt enabled with sense on both edges     |\n| 0x2   | RISING        | Interrupt enabled with sense on rising edge    |\n| 0x3   | FALLING       | Interrupt enabled with sense on falling edge   |\n| 0x4   | INPUT_DISABLE | Interrupt and digital input buffer disabled(1) |\n| 0x5   | LEVEL         | Interrupt enabled with sense on low level      |\n| other | \u2014             | Reserved                                       |\n\n\nNote:"
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the internal pull-up of pin n is enabled or not when the pin is configured as input-only.\n\n\n| Value | Description      |\n| :---- | :--------------- |\n| 0     | Pull-up disabled |\n| 1     | Pull-up enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Pin 6 Control",
              "reset": "0x00",
              "name": "PIN6CTRL",
              "offset": "0x16",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the input and output for pin n are inverted or not.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Input and output values are not inverted |\n| 1     | Input and output values are inverted     |\n\n"
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": "This bit field controls the input and sense configuration of pin n. The sense configuration determines how a port\ninterrupt can be triggered.\n\n\n| Value | Name          | Description                                    |\n| :---- | :------------ | :--------------------------------------------- |\n| 0x0   | INTDISABLE    | Interrupt disabled but input buffer enabled    |\n| 0x1   | BOTHEDGES     | Interrupt enabled with sense on both edges     |\n| 0x2   | RISING        | Interrupt enabled with sense on rising edge    |\n| 0x3   | FALLING       | Interrupt enabled with sense on falling edge   |\n| 0x4   | INPUT_DISABLE | Interrupt and digital input buffer disabled(1) |\n| 0x5   | LEVEL         | Interrupt enabled with sense on low level      |\n| other | \u2014             | Reserved                                       |\n\n\nNote:"
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the internal pull-up of pin n is enabled or not when the pin is configured as input-only.\n\n\n| Value | Description      |\n| :---- | :--------------- |\n| 0     | Pull-up disabled |\n| 1     | Pull-up enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Pin 7 Control",
              "reset": "0x00",
              "name": "PIN7CTRL",
              "offset": "0x17",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the input and output for pin n are inverted or not.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Input and output values are not inverted |\n| 1     | Input and output values are inverted     |\n\n"
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": "This bit field controls the input and sense configuration of pin n. The sense configuration determines how a port\ninterrupt can be triggered.\n\n\n| Value | Name          | Description                                    |\n| :---- | :------------ | :--------------------------------------------- |\n| 0x0   | INTDISABLE    | Interrupt disabled but input buffer enabled    |\n| 0x1   | BOTHEDGES     | Interrupt enabled with sense on both edges     |\n| 0x2   | RISING        | Interrupt enabled with sense on rising edge    |\n| 0x3   | FALLING       | Interrupt enabled with sense on falling edge   |\n| 0x4   | INPUT_DISABLE | Interrupt and digital input buffer disabled(1) |\n| 0x5   | LEVEL         | Interrupt enabled with sense on low level      |\n| other | \u2014             | Reserved                                       |\n\n\nNote:"
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the internal pull-up of pin n is enabled or not when the pin is configured as input-only.\n\n\n| Value | Description      |\n| :---- | :--------------- |\n| 0     | Pull-up disabled |\n| 1     | Pull-up enabled  |\n\n"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Port Multiplexer",
      "id": "I2600",
      "name": "PORTMUX",
      "register_groups": [
        {
          "caption": "Port Multiplexer",
          "name": "PORTMUX",
          "size": "0x10",
          "registers": [
            {
              "caption": "Port Multiplexer Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Event Output 0",
                  "mask": "0x1",
                  "name": "EVOUT0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Write this bit to '1' to enable event output 0."
                },
                {
                  "caption": "Event Output 1",
                  "mask": "0x2",
                  "name": "EVOUT1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Write this bit to '1' to enable event output 1."
                },
                {
                  "caption": "Event Output 2",
                  "mask": "0x4",
                  "name": "EVOUT2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Write this bit to '1' to enable event output 2."
                },
                {
                  "caption": "Configurable Custom Logic LUT0",
                  "mask": "0x10",
                  "name": "LUT0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_LUT0",
                  "description": "Write this bit to '1' to select the alternative pin location for CCL LUT 0."
                },
                {
                  "caption": "Configurable Custom Logic LUT1",
                  "mask": "0x20",
                  "name": "LUT1",
                  "rw": "RW",
                  "values_ref": "PORTMUX_LUT1",
                  "description": "Write this bit to '1' to select the alternative pin location for CCL LUT 1."
                }
              ],
              "description": null
            },
            {
              "caption": "Port Multiplexer Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Port Multiplexer SPI0",
                  "mask": "0x4",
                  "name": "SPI0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_SPI0",
                  "description": "Write this bit to '1' to select alternative communication pins for SPI 0."
                },
                {
                  "caption": "Port Multiplexer TWI0",
                  "mask": "0x10",
                  "name": "TWI0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TWI0",
                  "description": "Write this bit to '1' to select alternative communication pins for TWI 0."
                },
                {
                  "caption": "Port Multiplexer USART0",
                  "mask": "0x1",
                  "name": "USART0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_USART0",
                  "description": "Write this bit to '1' to select alternative communication pins for USART 0."
                }
              ],
              "description": null
            },
            {
              "caption": "Port Multiplexer Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Port Multiplexer TCA0 Output 0",
                  "mask": "0x1",
                  "name": "TCA00",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA00",
                  "description": "Write this bit to '1' to select the alternative output pin for TCA0 waveform output 0.\nIn Split mode, this bit controls output from low byte compare channel 0."
                },
                {
                  "caption": "Port Multiplexer TCA0 Output 1",
                  "mask": "0x2",
                  "name": "TCA01",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA01",
                  "description": "Write this bit to '1' to select the alternative output pin for TCA0 waveform output 1.\nIn Split mode, this bit controls output from low byte compare channel 1."
                },
                {
                  "caption": "Port Multiplexer TCA0 Output 2",
                  "mask": "0x4",
                  "name": "TCA02",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA02",
                  "description": "Write this bit to '1' to select the alternative output pin for TCA0 waveform output 2.\nIn Split Mode, this bit controls output from low byte compare channel 2."
                },
                {
                  "caption": "Port Multiplexer TCA0 Output 3",
                  "mask": "0x8",
                  "name": "TCA03",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA03",
                  "description": "Write this bit to '1' to select the alternative output pin for TCA0 waveform output 3 in Split mode.\nNot applicable when TCA is in Normal mode."
                },
                {
                  "caption": "Port Multiplexer TCA0 Output 4",
                  "mask": "0x10",
                  "name": "TCA04",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA04",
                  "description": "Write this bit to '1' to select the alternative output pin for TCA0 waveform output 4 in Split mode.\nNot applicable when TCA is in Normal mode."
                },
                {
                  "caption": "Port Multiplexer TCA0 Output 5",
                  "mask": "0x20",
                  "name": "TCA05",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA05",
                  "description": "Write this bit to '1' to select the alternative output pin for TCA0 waveform output 5 in Split mode.\nNot applicable when TCA is in Normal mode."
                }
              ],
              "description": null
            },
            {
              "caption": "Port Multiplexer Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Port Multiplexer TCB",
                  "mask": "0x1",
                  "name": "TCB0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCB0",
                  "description": "Write this bit to '1' to select the alternative output pin for 16-bit timer/counter B 0."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Peripherial Touch Controller",
      "id": "I2120",
      "name": "PTC",
      "register_groups": null
    },
    {
      "caption": "Reset controller",
      "id": "I2111",
      "name": "RSTCTRL",
      "register_groups": [
        {
          "caption": "Reset controller",
          "name": "RSTCTRL",
          "size": "0x4",
          "registers": [
            {
              "caption": "Reset Flags",
              "reset": "0x00",
              "name": "RSTFR",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Brown out detector Reset flag",
                  "mask": "0x2",
                  "name": "BORF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a Brown-out Reset occurs."
                },
                {
                  "caption": "External Reset flag",
                  "mask": "0x4",
                  "name": "EXTRF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if an External Reset occurs."
                },
                {
                  "caption": "Power on Reset flag",
                  "mask": "0x1",
                  "name": "PORF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a POR occurs.\nAfter a POR, only the POR flag is set and all the other flags are cleared. No other flags can be set before a full\nsystem boot is run after the POR."
                },
                {
                  "caption": "Software Reset flag",
                  "mask": "0x10",
                  "name": "SWRF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a Software Reset occurs."
                },
                {
                  "caption": "UPDI Reset flag",
                  "mask": "0x20",
                  "name": "UPDIRF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a UPDI Reset occurs."
                },
                {
                  "caption": "Watch dog Reset flag",
                  "mask": "0x8",
                  "name": "WDRF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a Watchdog Reset occurs."
                }
              ],
              "description": "All flags are cleared by writing a '1' to them. They are also cleared by a Power-on Reset (POR), except for the\nPower-on Reset Flag (PORF)."
            },
            {
              "caption": "Software Reset",
              "reset": "0x00",
              "name": "SWRR",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Software reset enable",
                  "mask": "0x1",
                  "name": "SWRE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', a software Reset will occur.\nThis bit will always read as '0'."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Real-Time Counter",
      "id": "I2116",
      "name": "RTC",
      "register_groups": [
        {
          "caption": "Real-Time Counter",
          "name": "RTC",
          "size": "0x20",
          "registers": [
            {
              "caption": "Clock Select",
              "reset": "0x00",
              "name": "CLKSEL",
              "offset": "0x07",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Select",
                  "mask": "0x3",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "RTC_CLKSEL",
                  "description": "Writing these bits select the source for the RTC clock (CLK_RTC).\n\n\n| Value | Name    | Description                                          |\n| :---- | :------ | :--------------------------------------------------- |\n| 0x0   | INT32K  | 32.768 kHz from OSCULP32K                            |\n| 0x1   | INT1K   | 1.024 kHz from OSCULP32K                             |\n| 0x2   | TOSC32K | 32.768 kHz from XOSC32K or external clock from TOSC1 |\n| 0x3   | EXTCLK  | External clock from EXTCLK pin                       |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Compare",
              "reset": null,
              "name": "CMP",
              "offset": "0x0C",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMP",
                  "caption": "Compare Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the LSB of the 16-bit Compare register."
                },
                {
                  "name": "CMP",
                  "caption": "Compare High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Compare register."
                }
              ],
              "description": "The RTC.CMPL and RTC.CMPH register pair represents the 16-bit value, RTC.CMP. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Counter",
              "reset": null,
              "name": "CNT",
              "offset": "0x08",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CNT",
                  "caption": "Counter Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the LSB of the 16-bit Counter register."
                },
                {
                  "name": "CNT",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The RTC.CNTL and RTC.CNTH register pair represents the 16-bit value, RTC.CNT. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nDue to the synchronization between the RTC clock and main clock domains, there is a latency of two RTC clock\ncycles from updating the register until this has an effect. The application software needs to check that the CNTBUSY\nflag in RTC.STATUS is cleared before writing to this register."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Prescaling Factor",
                  "mask": "0x78",
                  "name": "PRESCALER",
                  "rw": "RW",
                  "values_ref": "RTC_PRESCALER",
                  "description": "These bits define the prescaling of the CLK_RTC clock signal. Due to synchronization between the RTC clock and\nthe peripheral clock, there is a latency of two RTC clock cycles from updating the register until this has an effect.\nApplication software needs to check that the CTRLABUSY flag in RTC.STATUS register is cleared before writing to\nthis register.\n\n\n| Value | Name     | Description                 |\n| :---- | :------- | :-------------------------- |\n| 0x0   | DIV1     | RTC clock/1 (no prescaling) |\n| 0x1   | DIV2     | RTC clock/2                 |\n| 0x2   | DIV4     | RTC clock/4                 |\n| 0x3   | DIV8     | RTC clock/8                 |\n| 0x4   | DIV16    | RTC clock/16                |\n| 0x5   | DIV32    | RTC clock/32                |\n| 0x6   | DIV64    | RTC clock/64                |\n| 0x7   | DIV128   | RTC clock/128               |\n| 0x8   | DIV256   | RTC clock/256               |\n| 0x9   | DIV512   | RTC clock/512               |\n| 0xA   | DIV1024  | RTC clock/1024              |\n| 0xB   | DIV2048  | RTC clock/2048              |\n| 0xC   | DIV4096  | RTC clock/4096              |\n| 0xD   | DIV8192  | RTC clock/8192              |\n| 0xE   | DIV16384 | RTC clock/16384             |\n| 0xF   | DIV32768 | RTC clock/32768             |\n\n"
                },
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "RTCEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | RTC peripheral is disabled |\n| 1     | RTC peripheral is enabled  |\n\n"
                },
                {
                  "caption": "Run In Standby",
                  "mask": "0x80",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0     | RTC disabled in Standby Sleep mode |\n| 1     | RTC enabled in Standby Sleep mode  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Debug control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run in debug",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare Match Interrupt enable",
                  "mask": "0x2",
                  "name": "CMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Enable interrupt-on-compare match (that is, when the value from the Count (RTC.CNT) register matches the value\nfrom the Compare (RTC.CMP) register).\n\n\n| Value | Description                             |\n| :---- | :-------------------------------------- |\n| 0     | The compare match interrupt is disabled |\n| 1     | The compare match interrupt is enabled  |\n\n"
                },
                {
                  "caption": "Overflow Interrupt enable",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Enable interrupt-on-counter overflow (that is, when the value from the Count (RTC.CNT) register matched the value\nfrom the Period (RTC.PER) register and wraps around to zero).\n\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0     | The overflow interrupt is disabled |\n| 1     | The overflow interrupt is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare Match Interrupt",
                  "mask": "0x2",
                  "name": "CMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when the value from the Count (RTC.CNT) register matches the value from the Compare (RTC.CMP)\nregister.\nWriting a '1' to this bit clears the flag."
                },
                {
                  "caption": "Overflow Interrupt Flag",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when the value from the Count (RTC.CNT) register has reached the value from the Period (RTC.PER)\nregister and wrapped to zero.\nWriting a '1' to this bit clears the flag."
                }
              ],
              "description": null
            },
            {
              "caption": "Period",
              "reset": null,
              "name": "PER",
              "offset": "0x0A",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "PER",
                  "caption": "Period Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the LSB of the 16-bit Period register."
                },
                {
                  "name": "PER",
                  "caption": "Period High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Period register."
                }
              ],
              "description": "The RTC.PERL and RTC.PERH register pair represents the 16-bit value, RTC.PER. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nDue to the synchronization between the RTC clock and main clock domains, there is a latency of two RTC clock\ncycles from updating the register until this has an effect. The application software needs to check that the PERBUSY\nflag in RTC.STATUS is cleared before writing to this register."
            },
            {
              "caption": "PIT Control A",
              "reset": "0x00",
              "name": "PITCTRLA",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Period",
                  "mask": "0x78",
                  "name": "PERIOD",
                  "rw": "RW",
                  "values_ref": "RTC_PERIOD",
                  "description": "Writing this bit field selects the number of RTC clock cycles between each interrupt.\n\n\n| Value | Name     | Description  |\n| :---- | :------- | :----------- |\n| 0x0   | OFF      | No interrupt |\n| 0x1   | CYC4     | 4 cycles     |\n| 0x2   | CYC8     | 8 cycles     |\n| 0x3   | CYC16    | 16 cycles    |\n| 0x4   | CYC32    | 32 cycles    |\n| 0x5   | CYC64    | 64 cycles    |\n| 0x6   | CYC128   | 128 cycles   |\n| 0x7   | CYC256   | 256 cycles   |\n| 0x8   | CYC512   | 512 cycles   |\n| 0x9   | CYC1024  | 1024 cycles  |\n| 0xA   | CYC2048  | 2048 cycles  |\n| 0xB   | CYC4096  | 4096 cycles  |\n| 0xC   | CYC8192  | 8192 cycles  |\n| 0xD   | CYC16384 | 16384 cycles |\n| 0xE   | CYC32768 | 32768 cycles |\n| 0xF   | -        | Reserved     |\n\n"
                },
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "PITEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                       |\n| :---- | :-------------------------------- |\n| 0     | Periodic Interrupt Timer disabled |\n| 1     | Periodic Interrupt Timer enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "PIT Debug control",
              "reset": "0x00",
              "name": "PITDBGCTRL",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run in debug",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "PIT Interrupt Control",
              "reset": "0x00",
              "name": "PITINTCTRL",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Periodic Interrupt",
                  "mask": "0x1",
                  "name": "PI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0     | The periodic interrupt is disabled |\n| 1     | The periodic interrupt is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "PIT Interrupt Flags",
              "reset": "0x00",
              "name": "PITINTFLAGS",
              "offset": "0x13",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Periodic Interrupt",
                  "mask": "0x1",
                  "name": "PI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when a periodic interrupt is issued.\nWriting a '1' clears the flag."
                }
              ],
              "description": null
            },
            {
              "caption": "PIT Status",
              "reset": "0x00",
              "name": "PITSTATUS",
              "offset": "0x11",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CTRLA Synchronization Busy Flag",
                  "mask": "0x1",
                  "name": "CTRLBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is '1' when the RTC is busy synchronizing the Periodic Interrupt Timer Control A (RTC.PITCTRLA) register in\nthe RTC clock domain."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x01",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Comparator Synchronization Busy Flag",
                  "mask": "0x8",
                  "name": "CMPBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is '1' when the RTC is busy synchronizing the Compare (RTC.CMP) register in the RTC clock domain."
                },
                {
                  "caption": "Count Synchronization Busy Flag",
                  "mask": "0x2",
                  "name": "CNTBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is '1' when the RTC is busy synchronizing the Count (RTC.CNT) register in the RTC clock domain."
                },
                {
                  "caption": "CTRLA Synchronization Busy Flag",
                  "mask": "0x1",
                  "name": "CTRLABUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is '1' when the RTC is busy synchronizing the Control A (RTC.CTRLA) register in the RTC clock domain."
                },
                {
                  "caption": "Period Synchronization Busy Flag",
                  "mask": "0x4",
                  "name": "PERBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is '1' when the RTC is busy synchronizing the Period (RTC.PER) register in the RTC clock domain."
                }
              ],
              "description": null
            },
            {
              "caption": "Temporary",
              "reset": null,
              "name": "TEMP",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "TEMP",
                  "caption": "Temporary",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                }
              ],
              "description": "The Temporary register is used by the CPU for 16-bit single-cycle access to the 16-bit registers of this peripheral. The\nregister is common for all the 16-bit registers of this peripheral and can be read and written by software. For more\ndetails on reading and writing 16-bit registers, refer to Accessing 16-Bit Registers in the AVR CPU section."
            }
          ]
        }
      ]
    },
    {
      "caption": "Signature row",
      "id": "I2600",
      "name": "SIGROW",
      "register_groups": [
        {
          "caption": "Signature row",
          "name": "SIGROW",
          "size": "0x40",
          "registers": [
            {
              "caption": "Device ID Byte 0",
              "reset": null,
              "name": "DEVICEID0",
              "offset": "0x00",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "DEVICEID0",
                  "caption": "Byte n of the Device ID",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has a device ID identifying this device and its properties such as memory sizes, pin count, and die\nrevision. This ID can be used to identify a device and hence, the available features by software. The Device ID\nconsists of three bytes: SIGROW.DEVICEID[2:0]."
            },
            {
              "caption": "Device ID Byte 1",
              "reset": null,
              "name": "DEVICEID1",
              "offset": "0x01",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "DEVICEID1",
                  "caption": "Byte n of the Device ID",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has a device ID identifying this device and its properties such as memory sizes, pin count, and die\nrevision. This ID can be used to identify a device and hence, the available features by software. The Device ID\nconsists of three bytes: SIGROW.DEVICEID[2:0]."
            },
            {
              "caption": "Device ID Byte 2",
              "reset": null,
              "name": "DEVICEID2",
              "offset": "0x02",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "DEVICEID2",
                  "caption": "Byte n of the Device ID",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has a device ID identifying this device and its properties such as memory sizes, pin count, and die\nrevision. This ID can be used to identify a device and hence, the available features by software. The Device ID\nconsists of three bytes: SIGROW.DEVICEID[2:0]."
            },
            {
              "caption": "OSC16 error at 3V",
              "reset": null,
              "name": "OSC16ERR3V",
              "offset": "0x22",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "OSC16ERR3V",
                  "caption": "OSC16 Error at 3V",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These registers contain the signed oscillator frequency error value relative to the nominal oscillator frequency when\nrunning at an internal 16 MHz at 3V, as measured during production."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC16 error at 5V",
              "reset": null,
              "name": "OSC16ERR5V",
              "offset": "0x23",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "OSC16ERR5V",
                  "caption": "OSC16 Error at 5V",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These registers contain the signed oscillator frequency error value relative to the nominal oscillator frequency when\nrunning at an internal 16 MHz at 5V, as measured during production."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC20 error at 3V",
              "reset": null,
              "name": "OSC20ERR3V",
              "offset": "0x24",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "OSC20ERR3V",
                  "caption": "OSC20 Error at 3V",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These registers contain the signed oscillator frequency error value relative to the nominal oscillator frequency when\nrunning at an internal 20 MHz at 3V, as measured during production."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC20 error at 5V",
              "reset": null,
              "name": "OSC20ERR5V",
              "offset": "0x25",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "OSC20ERR5V",
                  "caption": "OSC20 Error at 5V",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These registers contain the signed oscillator frequency error value relative to the nominal oscillator frequency when\nrunning at an internal 20 MHz at 5V, as measured during production."
                }
              ],
              "description": null
            },
            {
              "caption": "Serial Number Byte 0",
              "reset": null,
              "name": "SERNUM0",
              "offset": "0x03",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM0",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 1",
              "reset": null,
              "name": "SERNUM1",
              "offset": "0x04",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM1",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 2",
              "reset": null,
              "name": "SERNUM2",
              "offset": "0x05",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM2",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 3",
              "reset": null,
              "name": "SERNUM3",
              "offset": "0x06",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM3",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 4",
              "reset": null,
              "name": "SERNUM4",
              "offset": "0x07",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM4",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 5",
              "reset": null,
              "name": "SERNUM5",
              "offset": "0x08",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM5",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 6",
              "reset": null,
              "name": "SERNUM6",
              "offset": "0x09",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM6",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 7",
              "reset": null,
              "name": "SERNUM7",
              "offset": "0x0A",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM7",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 8",
              "reset": null,
              "name": "SERNUM8",
              "offset": "0x0B",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM8",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Serial Number Byte 9",
              "reset": null,
              "name": "SERNUM9",
              "offset": "0x0C",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "SERNUM9",
                  "caption": "Serial Number Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Each device has an individual serial number, representing a unique ID. This ID can be used to identify a specific\ndevice in the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
            },
            {
              "caption": "Temperature Sensor Calibration Byte 0",
              "reset": null,
              "name": "TEMPSENSE0",
              "offset": "0x20",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "TEMPSENSE0",
                  "caption": "Temperature Sensor Calibration Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Refer to the ADC section for a description of how to use this register."
                }
              ],
              "description": "The Temperature Sensor Calibration registers contain correction factors for temperature measurements from the on-\nchip sensor. The ADC.SIGROW.TEMPSENSE0 is a correction factor for the gain/slope (unsigned), and\nSIGROW.TEMPSENSE1 is a correction factor for the offset (signed)."
            },
            {
              "caption": "Temperature Sensor Calibration Byte 1",
              "reset": null,
              "name": "TEMPSENSE1",
              "offset": "0x21",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "name": "TEMPSENSE1",
                  "caption": "Temperature Sensor Calibration Byte n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Refer to the ADC section for a description of how to use this register."
                }
              ],
              "description": "The Temperature Sensor Calibration registers contain correction factors for temperature measurements from the on-\nchip sensor. The ADC.SIGROW.TEMPSENSE0 is a correction factor for the gain/slope (unsigned), and\nSIGROW.TEMPSENSE1 is a correction factor for the offset (signed)."
            }
          ]
        }
      ]
    },
    {
      "caption": "Sleep Controller",
      "id": "I2112",
      "name": "SLPCTRL",
      "register_groups": [
        {
          "caption": "Sleep Controller",
          "name": "SLPCTRL",
          "size": "0x2",
          "registers": [
            {
              "caption": "Control",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Sleep enable",
                  "mask": "0x1",
                  "name": "SEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit must be written to '1' before the SLEEP instruction is executed to make the MCU enter the selected Sleep\nmode."
                },
                {
                  "caption": "Sleep mode",
                  "mask": "0x6",
                  "name": "SMODE",
                  "rw": "RW",
                  "values_ref": "SLPCTRL_SMODE",
                  "description": "Writing these bits selects which sleep mode to enter when the Sleep Enable (SEN) bit is written to '1' and the SLEEP\ninstruction is executed.\n\n\n| Value | Name    | Description                   |\n| :---- | :------ | :---------------------------- |\n| 0x0   | IDLE    | Idle sleep mode enabled       |\n| 0x1   | STANDBY | Standby sleep mode enabled    |\n| 0x2   | PDOWN   | Power-Down sleep mode enabled |\n| other | -       | Reserved                      |\n\n"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Serial Peripheral Interface",
      "id": "I2107",
      "name": "SPI",
      "register_groups": [
        {
          "caption": "Serial Peripheral Interface",
          "name": "SPI",
          "size": "0x8",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable Double Speed",
                  "mask": "0x10",
                  "name": "CLK2X",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', the SPI speed (SCK frequency, after internal prescaler) is doubled in Host mode.\n\n\n| Value | Description                                       |\n| :---- | :------------------------------------------------ |\n| 0     | SPI speed (SCK frequency) is not doubled          |\n| 1     | SPI speed (SCK frequency) is doubled in Host mode |\n\n"
                },
                {
                  "caption": "Data Order Setting",
                  "mask": "0x40",
                  "name": "DORD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                   |\n| :---- | :-------------------------------------------- |\n| 0     | The MSb of the data word is transmitted first |\n| 1     | The LSb of the data word is transmitted first |\n\n"
                },
                {
                  "caption": "Enable Module",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description     |\n| :---- | :-------------- |\n| 0     | SPI is disabled |\n| 1     | SPI is enabled  |\n\n"
                },
                {
                  "caption": "Master Operation Enable",
                  "mask": "0x20",
                  "name": "MASTER",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects the desired SPI mode.\nIf SS is configured as input and driven low while this bit is '1', then this bit is cleared, and the IF in SPIn.INTFLAGS is\nset. The user has to write MASTER = 1 again to re-enable SPI Host mode.\nThis behavior is controlled by the Client Select Disable (SSD) bit in SPIn.CTRLB.\n\n\n| Value | Description              |\n| :---- | :----------------------- |\n| 0     | SPI Client mode selected |\n| 1     | SPI Host mode selected   |\n\n"
                },
                {
                  "caption": "Prescaler",
                  "mask": "0x6",
                  "name": "PRESC",
                  "rw": "RW",
                  "values_ref": "SPI_PRESC",
                  "description": "This bit field controls the SPI clock rate configured in Host mode. These bits have no effect in Client mode. The\nrelationship between SCK and the peripheral clock frequency (fCLK_PER) is shown below.\nThe output of the SPI prescaler can be doubled by writing the CLK2X bit to '1'.\n\n\n| Value | Name   | Description |\n| :---- | :----- | :---------- |\n| 0x0   | DIV4   | CLK_PER/4   |\n| 0x1   | DIV16  | CLK_PER/16  |\n| 0x2   | DIV64  | CLK_PER/64  |\n| 0x3   | DIV128 | CLK_PER/128 |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Buffer Mode Enable",
                  "mask": "0x80",
                  "name": "BUFEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables Buffer mode. This will enable two receive buffers and one transmit buffer. Both will have\nseparate interrupt flags, transmit complete and receive complete."
                },
                {
                  "caption": "Buffer Write Mode",
                  "mask": "0x40",
                  "name": "BUFWR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When writing this bit to '0', the first data transferred will be a dummy sample.\n\n\n| Value | Description                                                                                                 |\n| :---- | :---------------------------------------------------------------------------------------------------------- |\n| 0     | One SPI transfer must be completed before the data are copied into the shift register                       |\n| 1     | If writing to the Data register when the SPI is enabled and SS is high, the first write will go directly to |\n\n\nthe shift register"
                },
                {
                  "caption": "SPI Mode",
                  "mask": "0x3",
                  "name": "MODE",
                  "rw": "RW",
                  "values_ref": "SPI_MODE",
                  "description": "These bits select the Transfer mode. The four combinations of SCK phase and polarity concerning the serial data are\nshown below. These bits decide whether the first edge of a clock cycle (leading edge) is rising or falling and whether\ndata setup and sample occur on the leading or trailing edge. When the leading edge is rising, the SCK signal is low\nwhen idle, and when the leading edge is falling, the SCK signal is high when idle.\n\n\n| Value | Name  | Description                  |\n| :---- | :---- | :--------------------------- |\n| 0x0   | 0     | Leading edge: Rising, sample |\n\n\nTrailing edge: Falling, setup\n0x1 1 Leading edge: Rising, setup\nTrailing edge: Falling, sample\n0x2 2 Leading edge: Falling, sample\nTrailing edge: Rising, setup\n0x3 3 Leading edge: Falling, setup\nTrailing edge: Rising, sample"
                },
                {
                  "caption": "Slave Select Disable",
                  "mask": "0x4",
                  "name": "SSD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If this bit is set when operating as SPI Host (MASTER = 1 in SPIn.CTRLA), SS does not disable Host mode.\n\n\n| Value | Description                                               |\n| :---- | :-------------------------------------------------------- |\n| 0     | Enable the Client Select line when operating as SPI host  |\n| 1     | Disable the Client Select line when operating as SPI host |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Data",
              "reset": null,
              "name": "DATA",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "DATA",
                  "caption": "SPI Data",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "The DATA register is used for sending and receiving data. Writing to the register initiates the data transmission when\nin Host mode while preparing data for sending in Client mode. The byte written to the register shifts out on the SPI\noutput line when a transaction is initiated.\nThe SPIn.DATA register is not a physical register. Depending on what mode is configured, it is mapped to other\nregisters, as described below.\n* Normal mode:\n- Writing the DATA register will write the shift register\n- Reading from DATA will read from the Receive Data register\n* Buffer mode:\n- Writing the DATA register will write to the Transmit Data Buffer register\n- Reading from DATA will read from the Receive Data Buffer register. The contents of the Receive Data\nregister will then be moved to the Receive Data Buffer register."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": null,
              "name": "INTCTRL",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Data Register Empty Interrupt Enable",
                  "mask": "0x20",
                  "name": "DREIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In Buffer mode, this bit enables the Data Register Empty interrupt. The enabled interrupt will be triggered when the\nDREIF in the SPIn.INTFLAGS register is set. In the Non-Buffer mode, this bit is '0'."
                },
                {
                  "caption": "Interrupt Enable",
                  "mask": "0x1",
                  "name": "IE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables the SPI interrupt when the SPI is not in Buffer mode. The enabled interrupt will be triggered when\nRXCIF/IF is set in the SPIn.INTFLAGS register."
                },
                {
                  "caption": "Receive Complete Interrupt Enable",
                  "mask": "0x80",
                  "name": "RXCIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In Buffer mode, this bit enables the Receive Complete interrupt. The enabled interrupt will be triggered when the\nRXCIF in the SPIn.INTFLAGS register is set. In the Non-Buffer mode, this bit is '0'."
                },
                {
                  "caption": "Slave Select Trigger Interrupt Enable",
                  "mask": "0x10",
                  "name": "SSIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In Buffer mode, this bit enables the Client Select interrupt. The enabled interrupt will be triggered when the SSIF in\nthe SPIn.INTFLAGS register is set. In the Non-Buffer mode, this bit is '0'."
                },
                {
                  "caption": "Transfer Complete Interrupt Enable",
                  "mask": "0x40",
                  "name": "TXCIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In Buffer mode, this bit enables the Transfer Complete interrupt. The enabled interrupt will be triggered when the\nTXCIF in the SPIn.INTFLAGS register is set. In the Non-Buffer mode, this bit is '0'."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "INTFLAGS",
                  "caption": "SPI Data",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "The DATA register is used for sending and receiving data. Writing to the register initiates the data transmission when\nin Host mode while preparing data for sending in Client mode. The byte written to the register shifts out on the SPI\noutput line when a transaction is initiated.\nThe SPIn.DATA register is not a physical register. Depending on what mode is configured, it is mapped to other\nregisters, as described below.\n* Normal mode:\n- Writing the DATA register will write the shift register\n- Reading from DATA will read from the Receive Data register\n* Buffer mode:\n- Writing the DATA register will write to the Transmit Data Buffer register\n- Reading from DATA will read from the Receive Data Buffer register. The contents of the Receive Data\nregister will then be moved to the Receive Data Buffer register."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "System Configuration Registers",
      "id": "I2600",
      "name": "SYSCFG",
      "register_groups": [
        {
          "caption": "System Configuration Registers",
          "name": "SYSCFG",
          "size": "0x20",
          "registers": [
            {
              "caption": "External Break",
              "reset": "0x00",
              "name": "EXTBRK",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "External break enable",
                  "mask": "0x1",
                  "name": "ENEXTBRK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Revision ID",
              "reset": null,
              "name": "REVID",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "REVID",
                  "caption": "Revision ID",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field contains the device revision. 0x00 = A, 0x01 = B, and so on."
                }
              ],
              "description": "This register is read-only and displays the device revision ID."
            }
          ]
        }
      ]
    },
    {
      "caption": "16-bit Timer/Counter Type A",
      "id": "I2117",
      "name": "TCA",
      "register_groups": [
        {
          "caption": "16-bit Timer/Counter Type A - Single Mode",
          "name": "TCA_SINGLE",
          "size": "0x40",
          "registers": [
            {
              "caption": "Compare 0",
              "reset": null,
              "name": "CMP0",
              "offset": "0x28",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMP0",
                  "caption": "Compare Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit filed holds the LSB of the 16-bit Compare register."
                },
                {
                  "name": "CMP0",
                  "caption": "Compare High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Compare register."
                }
              ],
              "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators are used to\ngenerate waveforms.\nThe TCAn.CMPn registers are updated with the buffer value from their corresponding TCAn.CMPnBUF register when\nan UPDATE condition occurs.\nThe TCAn.CMPnL and TCAn.CMPnH register pair represents the 16-bit value, TCAn.CMPn. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Compare 0 Buffer",
              "reset": null,
              "name": "CMP0BUF",
              "offset": "0x38",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMP0BUF",
                  "caption": "Compare Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit Compare Buffer register."
                },
                {
                  "name": "CMP0BUF",
                  "caption": "Compare High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Compare Buffer register."
                }
              ],
              "description": "This register serves as the buffer for the associated Compare n (TCAn.CMPn) register. Writing to this register from\nthe CPU or UPDI will set the Compare Buffer valid (CMPnBV) bit in the TCAn.CTRLF register.\nThe TCAn.CMPnBUFL and TCAn.CMPnBUFH register pair represents the 16-bit value, TCAn.CMPnBUF. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\n+ 0x01."
            },
            {
              "caption": "Compare 1",
              "reset": null,
              "name": "CMP1",
              "offset": "0x2A",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMP1",
                  "caption": "Compare Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit filed holds the LSB of the 16-bit Compare register."
                },
                {
                  "name": "CMP1",
                  "caption": "Compare High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Compare register."
                }
              ],
              "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators are used to\ngenerate waveforms.\nThe TCAn.CMPn registers are updated with the buffer value from their corresponding TCAn.CMPnBUF register when\nan UPDATE condition occurs.\nThe TCAn.CMPnL and TCAn.CMPnH register pair represents the 16-bit value, TCAn.CMPn. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Compare 1 Buffer",
              "reset": null,
              "name": "CMP1BUF",
              "offset": "0x3A",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMP1BUF",
                  "caption": "Compare Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit Compare Buffer register."
                },
                {
                  "name": "CMP1BUF",
                  "caption": "Compare High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Compare Buffer register."
                }
              ],
              "description": "This register serves as the buffer for the associated Compare n (TCAn.CMPn) register. Writing to this register from\nthe CPU or UPDI will set the Compare Buffer valid (CMPnBV) bit in the TCAn.CTRLF register.\nThe TCAn.CMPnBUFL and TCAn.CMPnBUFH register pair represents the 16-bit value, TCAn.CMPnBUF. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\n+ 0x01."
            },
            {
              "caption": "Compare 2",
              "reset": null,
              "name": "CMP2",
              "offset": "0x2C",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMP2",
                  "caption": "Compare Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit filed holds the LSB of the 16-bit Compare register."
                },
                {
                  "name": "CMP2",
                  "caption": "Compare High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Compare register."
                }
              ],
              "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators are used to\ngenerate waveforms.\nThe TCAn.CMPn registers are updated with the buffer value from their corresponding TCAn.CMPnBUF register when\nan UPDATE condition occurs.\nThe TCAn.CMPnL and TCAn.CMPnH register pair represents the 16-bit value, TCAn.CMPn. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Compare 2 Buffer",
              "reset": null,
              "name": "CMP2BUF",
              "offset": "0x3C",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMP2BUF",
                  "caption": "Compare Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit Compare Buffer register."
                },
                {
                  "name": "CMP2BUF",
                  "caption": "Compare High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Compare Buffer register."
                }
              ],
              "description": "This register serves as the buffer for the associated Compare n (TCAn.CMPn) register. Writing to this register from\nthe CPU or UPDI will set the Compare Buffer valid (CMPnBV) bit in the TCAn.CTRLF register.\nThe TCAn.CMPnBUFL and TCAn.CMPnBUFH register pair represents the 16-bit value, TCAn.CMPnBUF. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\n+ 0x01."
            },
            {
              "caption": "Count",
              "reset": null,
              "name": "CNT",
              "offset": "0x20",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CNT",
                  "caption": "Counter Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit Counter register."
                },
                {
                  "name": "CNT",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The TCAn.CNTL and TCAn.CNTH register pair represents the 16-bit value, TCAn.CNT. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Selection",
                  "mask": "0xe",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_CLKSEL",
                  "description": "This bit field selects the clock frequency for the timer/counter.\n\n\n| Value | Name    | Description          |\n| :---- | :------ | :------------------- |\n| 0x0   | DIV1    | fTCA = fCLK_PER      |\n| 0x1   | DIV2    | fTCA = fCLK_PER/2    |\n| 0x2   | DIV4    | fTCA = fCLK_PER/4    |\n| 0x3   | DIV8    | fTCA = fCLK_PER/8    |\n| 0x4   | DIV16   | fTCA = fCLK_PER/16   |\n| 0x5   | DIV64   | fTCA = fCLK_PER/64   |\n| 0x6   | DIV256  | fTCA = fCLK_PER/256  |\n| 0x7   | DIV1024 | fTCA = fCLK_PER/1024 |\n\n"
                },
                {
                  "caption": "Module Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | The peripheral is disabled |\n| 1     | The peripheral is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Auto Lock Update",
                  "mask": "0x8",
                  "name": "ALUPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Auto-Lock Update bit controls the Lock Update (LUPD) bit in the TCAn.CTRLE register. When ALUPD is written\nto '1', the LUPD bit will be set to '1' until the Buffer Valid (CMPnBV) bits of all enabled compare channels are '1'. This\ncondition will clear the LUPD bit.\nIt will remain cleared until the next UPDATE condition, where the buffer values will be transferred to the CMPn\nregisters, and the LUPD bit will be set to '1' again. This makes sure that the CMPnBUF register values are not\ntransferred to the CMPn registers until all enabled compare buffers are written.\n\n\n| Value | Description                                                          |\n| :---- | :------------------------------------------------------------------- |\n| 0     | LUPD bit in the TCAn.CTRLE register is not altered by the system     |\n| 1     | LUPD bit in the TCAn.CTRLE register is set and cleared automatically |\n\n"
                },
                {
                  "caption": "Compare 0 Enable",
                  "mask": "0x10",
                  "name": "CMP0EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In the FRQ and PWM Waveform Generation modes, the Compare n Enable (CMPnEN) bits will make the waveform\noutput available on the pin corresponding to WOn, overriding the value in the corresponding PORT output register.\nThe corresponding pin direction must be configured as an output in the PORT peripheral.\n\n\n| Value | Description                                                                 |\n| :---- | :-------------------------------------------------------------------------- |\n| 0     | Waveform output WOn will not be available on the corresponding pin          |\n| 1     | Waveform output WOn will override the output value of the corresponding pin |\n\n"
                },
                {
                  "caption": "Compare 1 Enable",
                  "mask": "0x20",
                  "name": "CMP1EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In the FRQ and PWM Waveform Generation modes, the Compare n Enable (CMPnEN) bits will make the waveform\noutput available on the pin corresponding to WOn, overriding the value in the corresponding PORT output register.\nThe corresponding pin direction must be configured as an output in the PORT peripheral.\n\n\n| Value | Description                                                                 |\n| :---- | :-------------------------------------------------------------------------- |\n| 0     | Waveform output WOn will not be available on the corresponding pin          |\n| 1     | Waveform output WOn will override the output value of the corresponding pin |\n\n"
                },
                {
                  "caption": "Compare 2 Enable",
                  "mask": "0x40",
                  "name": "CMP2EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In the FRQ and PWM Waveform Generation modes, the Compare n Enable (CMPnEN) bits will make the waveform\noutput available on the pin corresponding to WOn, overriding the value in the corresponding PORT output register.\nThe corresponding pin direction must be configured as an output in the PORT peripheral.\n\n\n| Value | Description                                                                 |\n| :---- | :-------------------------------------------------------------------------- |\n| 0     | Waveform output WOn will not be available on the corresponding pin          |\n| 1     | Waveform output WOn will override the output value of the corresponding pin |\n\n"
                },
                {
                  "caption": "Waveform generation mode",
                  "mask": "0x7",
                  "name": "WGMODE",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_WGMODE",
                  "description": "This bit field selects the Waveform Generation mode and controls the counting sequence of the counter, TOP value,\nUPDATE condition, Interrupt condition, and the type of waveform generated.\nNo waveform generation is performed in the Normal mode of operation. For all other modes, the waveform generator\noutput will only be directed to the port pins if the corresponding CMPnEN bit has been set. The port pin direction must\nbe set as output.\nTable 20-6. Timer Waveform Generation Mode\n\n\n| Value | Group Configuration | Mode of Operation | TOP   | UPDATE | OVF            |\n| :---- | :------------------ | :---------------- | :---- | :----- | :------------- |\n| 0x0   | NORMAL              | Normal            | PER   | TOP(1) | TOP(1)         |\n| 0x1   | FRQ                 | Frequency         | CMP0  | TOP(1) | TOP(1)         |\n| 0x2   | -                   | Reserved          | -     | -      | -              |\n| 0x3   | SINGLESLOPE         | Single-slope PWM  | PER   | BOTTOM | BOTTOM         |\n| 0x4   | -                   | Reserved          | -     | -      | -              |\n| 0x5   | DSTOP               | Dual-slope PWM    | PER   | BOTTOM | TOP            |\n| 0x6   | DSBOTH              | Dual-slope PWM    | PER   | BOTTOM | TOP and BOTTOM |\n| 0x7   | DSBOTTOM            | Dual-slope PWM    | PER   | BOTTOM | BOTTOM         |\n\n\nNote:"
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Waveform Output Value",
                  "mask": "0x1",
                  "name": "CMP0OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The CMPnOV bits allow direct access to the waveform generator's output compare value when the timer/counter is\nnot enabled. This is used to set or clear the WG output value when the timer/counter is not running.\nNote: When the output is connected to the pad, overriding these bits will not work unless the CMPnEN bits in the\nTCAn.CTRLB register have been set. If the output is connected to CCL, the CMPnEN bits in the TCAn.CTRLB\nregister are bypassed."
                },
                {
                  "caption": "Compare 1 Waveform Output Value",
                  "mask": "0x2",
                  "name": "CMP1OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0OV."
                },
                {
                  "caption": "Compare 2 Waveform Output Value",
                  "mask": "0x4",
                  "name": "CMP2OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0OV."
                }
              ],
              "description": null
            },
            {
              "caption": "Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Split Mode Enable",
                  "mask": "0x1",
                  "name": "SPLITM",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit sets the timer/counter in Split mode operation and will work as two 8-bit timer/counters. The register map will\nchange compared to the normal 16-bit mode."
                }
              ],
              "description": null
            },
            {
              "caption": "Control E Clear",
              "reset": "0x00",
              "name": "CTRLECLR",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0xc",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_CMD",
                  "description": "This bit field is used for software control of update, restart, and Reset of the timer/counter. The command bit field is\nalways read as '0'.\n\n\n| Value | Name    | Description                                                |\n| :---- | :------ | :--------------------------------------------------------- |\n| 0x0   | NONE    | No command                                                 |\n| 0x1   | UPDATE  | Force update                                               |\n| 0x2   | RESTART | Force restart                                              |\n| 0x3   | RESET   | Force hard Reset (ignored if the timer/counter is enabled) |\n\n"
                },
                {
                  "caption": "Direction",
                  "mask": "0x1",
                  "name": "DIR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Normally this bit is controlled in hardware by the Waveform Generation mode or by event actions, but can also be\nchanged from the software.\n\n\n| Value | Description                                 |\n| :---- | :------------------------------------------ |\n| 0     | The counter is counting up (incrementing)   |\n| 1     | The counter is counting down (decrementing) |\n\n"
                },
                {
                  "caption": "Lock Update",
                  "mask": "0x2",
                  "name": "LUPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Lock update can be used to ensure that all buffers are valid before an update is performed.\n\n\n| Value | Description                                                                                     |\n| :---- | :---------------------------------------------------------------------------------------------- |\n| 0     | The buffered registers are updated as soon as an UPDATE condition has occurred                  |\n| 1     | No update of the buffered registers is performed, even though an UPDATE condition has occurred. |\n\n\nThis setting will not prevent an update issued by the Command bit field."
                }
              ],
              "description": "Use this register instead of a Read-Modify-Write (RMW) to clear individual bits by writing a '1' to its bit location."
            },
            {
              "caption": "Control E Set",
              "reset": "0x00",
              "name": "CTRLESET",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0xc",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_CMD",
                  "description": "This bit field is used for software control of update, restart, and Reset of the timer/counter. The command bit field is\nalways read as '0'.\n\n\n| Value | Name    | Description                                                |\n| :---- | :------ | :--------------------------------------------------------- |\n| 0x0   | NONE    | No command                                                 |\n| 0x1   | UPDATE  | Force update                                               |\n| 0x2   | RESTART | Force restart                                              |\n| 0x3   | RESET   | Force hard Reset (ignored if the timer/counter is enabled) |\n\n"
                },
                {
                  "caption": "Direction",
                  "mask": "0x1",
                  "name": "DIR",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_DIR",
                  "description": "Normally this bit is controlled in hardware by the Waveform Generation mode or by event actions, but can also be\nchanged from the software.\n\n\n| Value | Description                                 |\n| :---- | :------------------------------------------ |\n| 0     | The counter is counting up (incrementing)   |\n| 1     | The counter is counting down (decrementing) |\n\n"
                },
                {
                  "caption": "Lock Update",
                  "mask": "0x2",
                  "name": "LUPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Locking the update ensures that all buffers are valid before an update is performed.\n\n\n| Value | Description                                                                                     |\n| :---- | :---------------------------------------------------------------------------------------------- |\n| 0     | The buffered registers are updated as soon as an UPDATE condition has occurred                  |\n| 1     | No update of the buffered registers is performed, even though an UPDATE condition has occurred. |\n\n\nThis setting will not prevent an update issued by the Command bit field."
                }
              ],
              "description": "Use this register instead of a Read-Modify-Write (RMW) to set individual bits by writing a '1' to its bit location."
            },
            {
              "caption": "Control F Clear",
              "reset": "0x00",
              "name": "CTRLFCLR",
              "offset": "0x06",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Buffer Valid",
                  "mask": "0x2",
                  "name": "CMP0BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The CMPnBV bits are set when a new value is written to the corresponding TCAn.CMPnBUF register. These bits are\nautomatically cleared on an UPDATE condition."
                },
                {
                  "caption": "Compare 1 Buffer Valid",
                  "mask": "0x4",
                  "name": "CMP1BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0BV."
                },
                {
                  "caption": "Compare 2 Buffer Valid",
                  "mask": "0x8",
                  "name": "CMP2BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0BV."
                },
                {
                  "caption": "Period Buffer Valid",
                  "mask": "0x1",
                  "name": "PERBV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set when a new value is written to the TCAn.PERBUF register. This bit is automatically cleared on an\nUPDATE condition."
                }
              ],
              "description": "Use this register instead of a Read-Modify-Write (RMW) to clear individual bits by writing a '1' to its bit location."
            },
            {
              "caption": "Control F Set",
              "reset": "0x00",
              "name": "CTRLFSET",
              "offset": "0x07",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Buffer Valid",
                  "mask": "0x2",
                  "name": "CMP0BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The CMPnBV bits are set when a new value is written to the corresponding TCAn.CMPnBUF register. These bits are\nautomatically cleared on an UPDATE condition."
                },
                {
                  "caption": "Compare 1 Buffer Valid",
                  "mask": "0x4",
                  "name": "CMP1BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0BV."
                },
                {
                  "caption": "Compare 2 Buffer Valid",
                  "mask": "0x8",
                  "name": "CMP2BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0BV."
                },
                {
                  "caption": "Period Buffer Valid",
                  "mask": "0x1",
                  "name": "PERBV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set when a new value is written to the TCAn.PERBUF register. This bit is automatically cleared on an\nUPDATE condition."
                }
              ],
              "description": "Use this register instead of a Read-Modify-Write (RMW) to set individual bits by writing a '1' to its bit location."
            },
            {
              "caption": "Degbug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x0E",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Event Control",
              "reset": "0x00",
              "name": "EVCTRL",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Count on Event Input",
                  "mask": "0x1",
                  "name": "CNTEI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                  |\n| :---- | :----------------------------------------------------------- |\n| 0     | Count on Event input is disabled                             |\n| 1     | Count on Event input is enabled according to EVACT bit field |\n\n"
                },
                {
                  "caption": "Event Action",
                  "mask": "0x6",
                  "name": "EVACT",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_EVACT",
                  "description": "Writing these bits selects the clock source for this peripheral.\n\n\n| Value | Name    | Description           |\n| :---- | :------ | :-------------------- |\n| 0x0   | CLKDIV1 | CLK_PER               |\n| 0x1   | CLKDIV2 | CLK_PER/DIV2          |\n| 0x3   | CLKTCA  | Use TCA_CLK from TCA0 |\n| 0x4   | -       | Reserved              |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Interrupt",
                  "mask": "0x10",
                  "name": "CMP0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing the CMPn bit to '1' enables the interrupt from Compare Channel n."
                },
                {
                  "caption": "Compare 1 Interrupt",
                  "mask": "0x20",
                  "name": "CMP1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0."
                },
                {
                  "caption": "Compare 2 Interrupt",
                  "mask": "0x40",
                  "name": "CMP2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0."
                },
                {
                  "caption": "Overflow Interrupt",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing the OVF bit to '1' enables the overflow/underflow interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Interrupt",
                  "mask": "0x10",
                  "name": "CMP0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Compare Interrupt (CMPn) flag is set on a compare match on the corresponding compare channel.\nFor all modes of operation, the CMPn flag will be set when a compare match occurs between the Count (TCAn.CNT)\nregister and the corresponding Compare n (TCAn.CMPn) register. The CMPn flag is not cleared automatically. It will\nbe cleared only by writing a '1' to its bit location."
                },
                {
                  "caption": "Compare 1 Interrupt",
                  "mask": "0x20",
                  "name": "CMP1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See the CMP0 flag description."
                },
                {
                  "caption": "Compare 2 Interrupt",
                  "mask": "0x40",
                  "name": "CMP2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See the CMP0 flag description."
                },
                {
                  "caption": "Overflow Interrupt",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set either on a TOP (overflow) or BOTTOM (underflow) condition, depending on the WGMODE setting.\nThe OVF flag is not cleared automatically. It will be cleared only by writing a '1' to its bit location."
                }
              ],
              "description": null
            },
            {
              "caption": "Period",
              "reset": null,
              "name": "PER",
              "offset": "0x26",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "PER",
                  "caption": "Periodic Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit Period register."
                },
                {
                  "name": "PER",
                  "caption": "Periodic High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Period register."
                }
              ],
              "description": "The TCAn.PER register contains the 16-bit TOP value in the timer/counter in all modes of operation, except\nFrequency Waveform Generation (FRQ).\nThe TCAn.PERL and TCAn.PERH register pair represents the 16-bit value, TCAn.PER. The low byte [7:0] (suffix L)\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Period Buffer",
              "reset": null,
              "name": "PERBUF",
              "offset": "0x36",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "PERBUF",
                  "caption": "Period Buffer Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit Period Buffer register."
                },
                {
                  "name": "PERBUF",
                  "caption": "Period Buffer High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Period Buffer register."
                }
              ],
              "description": "This register serves as the buffer for the Period (TCAn.PER) register. Writing to this register from the CPU or UPDI\nwill set the Period Buffer Valid (PERBV) bit in the TCAn.CTRLF register.\nThe TCAn.PERBUFL and TCAn.PERBUFH register pair represents the 16-bit value, TCAn.PERBUF. The low byte\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Temporary data for 16-bit Access",
              "reset": null,
              "name": "TEMP",
              "offset": "0x0F",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "TEMP",
                  "caption": "Temporary Bits for 16-bit Access",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "The Temporary register is used by the CPU for 16-bit single-cycle access to the 16-bit registers of this peripheral. The\nregister is common for all the 16-bit registers of this peripheral and can be read and written by software. For more\ndetails on reading and writing 16-bit registers, refer to Accessing 16-Bit Registers in the AVR CPU section."
            }
          ]
        },
        {
          "caption": "16-bit Timer/Counter Type A - Split Mode",
          "name": "TCA_SPLIT",
          "size": "0x40",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Selection",
                  "mask": "0xe",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "TCA_SPLIT_CLKSEL",
                  "description": "This bit field selects the clock frequency for the timer/counter.\n\n\n| Value | Name    | Description          |\n| :---- | :------ | :------------------- |\n| 0x0   | DIV1    | fTCA = fCLK_PER      |\n| 0x1   | DIV2    | fTCA = fCLK_PER/2    |\n| 0x2   | DIV4    | fTCA = fCLK_PER/4    |\n| 0x3   | DIV8    | fTCA = fCLK_PER/8    |\n| 0x4   | DIV16   | fTCA = fCLK_PER/16   |\n| 0x5   | DIV64   | fTCA = fCLK_PER/64   |\n| 0x6   | DIV256  | fTCA = fCLK_PER/256  |\n| 0x7   | DIV1024 | fTCA = fCLK_PER/1024 |\n\n"
                },
                {
                  "caption": "Module Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | The peripheral is disabled |\n| 1     | The peripheral is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "High Compare 0 Enable",
                  "mask": "0x10",
                  "name": "HCMP0EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Setting the HCMPnEN bit in the FRQ or PWM Waveform Generation mode of operation will override the port output\nregister for the corresponding WO[n+3] pin."
                },
                {
                  "caption": "High Compare 1 Enable",
                  "mask": "0x20",
                  "name": "HCMP1EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See HCMP0EN."
                },
                {
                  "caption": "High Compare 2 Enable",
                  "mask": "0x40",
                  "name": "HCMP2EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See HCMP0EN."
                },
                {
                  "caption": "Low Compare 0 Enable",
                  "mask": "0x1",
                  "name": "LCMP0EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Setting the LCMPnEN bit in the FRQ or PWM Waveform Generation mode of operation will override the port output\nregister for the corresponding WOn pin."
                },
                {
                  "caption": "Low Compare 1 Enable",
                  "mask": "0x2",
                  "name": "LCMP1EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0EN."
                },
                {
                  "caption": "Low Compare 2 Enable",
                  "mask": "0x4",
                  "name": "LCMP2EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0EN."
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "High Compare 0 Output Value",
                  "mask": "0x10",
                  "name": "HCMP0OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The HCMPnOV bit allows direct access to the output compare value of the waveform generator when the timer/\ncounter is not enabled. This is used to set or clear the WO[n+3] output value when the timer/counter is not running."
                },
                {
                  "caption": "High Compare 1 Output Value",
                  "mask": "0x20",
                  "name": "HCMP1OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See HCMP0OV."
                },
                {
                  "caption": "High Compare 2 Output Value",
                  "mask": "0x40",
                  "name": "HCMP2OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See HCMP0OV."
                },
                {
                  "caption": "Low Compare 0 Output Value",
                  "mask": "0x1",
                  "name": "LCMP0OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The LCMPnOV bit allows direct access to the output compare value of the waveform generator when the timer/\ncounter is not enabled. This is used to set or clear the WOn output value when the timer/counter is not running.\nNote: When the output is connected to the pad, overriding these bits will not work unless the xCMPnEN bits in the\nTCAn.CTRLB register have been set. If the output is connected to CCL, the xCMPnEN bits in the TCAn.CTRLB\nregister are bypassed."
                },
                {
                  "caption": "Low Compare 1 Output Value",
                  "mask": "0x2",
                  "name": "LCMP1OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0OV."
                },
                {
                  "caption": "Low Compare 2 Output Value",
                  "mask": "0x4",
                  "name": "LCMP2OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0OV."
                }
              ],
              "description": null
            },
            {
              "caption": "Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Split Mode Enable",
                  "mask": "0x1",
                  "name": "SPLITM",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit sets the timer/counter in Split mode operation and will work as two 8-bit timer/counters. The register map will\nchange compared to the normal 16-bit mode."
                }
              ],
              "description": null
            },
            {
              "caption": "Control E Clear",
              "reset": "0x00",
              "name": "CTRLECLR",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0xc",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "TCA_SPLIT_CMD",
                  "description": "This bit field is used for software control of restart and reset of the timer/counter. The command bit field is always\nread as '0'.\n\n\n| Value | Name    | Description                                                |\n| :---- | :------ | :--------------------------------------------------------- |\n| 0x0   | NONE    | No command                                                 |\n| 0x1   | -       | Reserved                                                   |\n| 0x2   | RESTART | Force restart                                              |\n| 0x3   | RESET   | Force hard Reset (ignored if the timer/counter is enabled) |\n\n"
                }
              ],
              "description": "Use this register instead of a Read-Modify-Write (RMW) to clear individual bits by writing a '1' to its bit location."
            },
            {
              "caption": "Control E Set",
              "reset": "0x00",
              "name": "CTRLESET",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0xc",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "TCA_SPLIT_CMD",
                  "description": "This bit field is used for software control of restart and reset of the timer/counter. The command bit field is always\nread as '0'. The CMD bit field must be used together with the Command Enable (CMDEN) bits. Using the RESET\ncommand requires that both low byte and high byte timer/counter are selected with CMDEN.\n\n\n| Value | Name    | Description                                                |\n| :---- | :------ | :--------------------------------------------------------- |\n| 0x0   | NONE    | No command                                                 |\n| 0x1   | -       | Reserved                                                   |\n| 0x2   | RESTART | Force restart                                              |\n| 0x3   | RESET   | Force hard Reset (ignored if the timer/counter is enabled) |\n\n"
                }
              ],
              "description": "Use this register instead of a Read-Modify-Write (RMW) to set individual bits by writing a '1' to its bit location."
            },
            {
              "caption": "Degbug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x0E",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "High Compare",
              "reset": null,
              "name": "HCMP0",
              "offset": "0x29",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "HCMP0",
                  "caption": "Compare Value of Channel n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the compare value of channel n that is compared to TCAn.HCNT."
                }
              ],
              "description": "The TCAn.HCMPn register represents the compare value of Compare Channel n for the high byte timer. This register\nis continuously compared to the counter value of the high byte timer, TCAn.HCNT. Normally, the outputs from the\ncomparators are then used to generate waveforms."
            },
            {
              "caption": "High Compare",
              "reset": null,
              "name": "HCMP1",
              "offset": "0x2B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "HCMP1",
                  "caption": "Compare Value of Channel n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the compare value of channel n that is compared to TCAn.HCNT."
                }
              ],
              "description": "The TCAn.HCMPn register represents the compare value of Compare Channel n for the high byte timer. This register\nis continuously compared to the counter value of the high byte timer, TCAn.HCNT. Normally, the outputs from the\ncomparators are then used to generate waveforms."
            },
            {
              "caption": "High Compare",
              "reset": null,
              "name": "HCMP2",
              "offset": "0x2D",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "HCMP2",
                  "caption": "Compare Value of Channel n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the compare value of channel n that is compared to TCAn.HCNT."
                }
              ],
              "description": "The TCAn.HCMPn register represents the compare value of Compare Channel n for the high byte timer. This register\nis continuously compared to the counter value of the high byte timer, TCAn.HCNT. Normally, the outputs from the\ncomparators are then used to generate waveforms."
            },
            {
              "caption": "High Count",
              "reset": null,
              "name": "HCNT",
              "offset": "0x21",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "HCNT",
                  "caption": "Counter Value for High Byte Timer",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field defines the counter value in high byte timer."
                }
              ],
              "description": "The TCAn.HCNT register contains the counter value for the high byte timer. CPU and UPDI write access has priority\nover count, clear or reload of the counter."
            },
            {
              "caption": "High Period",
              "reset": null,
              "name": "HPER",
              "offset": "0x27",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "HPER",
                  "caption": "Period Value High Byte Timer",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the TOP value for the high byte timer."
                }
              ],
              "description": "The TCAn.HPER register contains the TOP value for the high byte timer."
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "High Underflow Interrupt Enable",
                  "mask": "0x2",
                  "name": "HUNF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing the HUNF bit to '1' enables the high byte underflow interrupt."
                },
                {
                  "caption": "Low Compare 0 Interrupt Enable",
                  "mask": "0x10",
                  "name": "LCMP0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing the LCMPn bit to '1' enables the low byte Compare Channel n interrupt."
                },
                {
                  "caption": "Low Compare 1 Interrupt Enable",
                  "mask": "0x20",
                  "name": "LCMP1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0."
                },
                {
                  "caption": "Low Compare 2 Interrupt Enable",
                  "mask": "0x40",
                  "name": "LCMP2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0."
                },
                {
                  "caption": "Low Underflow Interrupt Enable",
                  "mask": "0x1",
                  "name": "LUNF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing the LUNF bit to '1' enables the low byte underflow interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "High Underflow Interrupt Flag",
                  "mask": "0x2",
                  "name": "HUNF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set on a high byte timer BOTTOM (underflow) condition. HUNF is not automatically cleared and needs to\nbe cleared by software. This is done by writing a '1' to its bit location."
                },
                {
                  "caption": "Low Compare 2 Interrupt Flag",
                  "mask": "0x10",
                  "name": "LCMP0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Low byte Compare Interrupt (LCMPn) flag is set on a compare match on the corresponding compare channel in\nthe low byte timer.\nFor all modes of operation, the LCMPn flag will be set when a compare match occurs between the Low Byte Timer\nCounter (TCAn.LCNT) register and the corresponding Compare n (TCAn.LCMPn) register. The LCMPn flag will not\nbe cleared automatically and has to be cleared by software. This is done by writing a '1' to its bit location."
                },
                {
                  "caption": "Low Compare 1 Interrupt Flag",
                  "mask": "0x20",
                  "name": "LCMP1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0 flag description."
                },
                {
                  "caption": "Low Compare 0 Interrupt Flag",
                  "mask": "0x40",
                  "name": "LCMP2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0 flag description."
                },
                {
                  "caption": "Low Underflow Interrupt Flag",
                  "mask": "0x1",
                  "name": "LUNF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set on a low byte timer BOTTOM (underflow) condition. LUNF is not automatically cleared and needs to\nbe cleared by software. This is done by writing a '1' to its bit location."
                }
              ],
              "description": null
            },
            {
              "caption": "Low Compare",
              "reset": null,
              "name": "LCMP0",
              "offset": "0x28",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "LCMP0",
                  "caption": "Compare Value of Channel n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the compare value of channel n that is compared to TCAn.LCNT."
                }
              ],
              "description": "The TCAn.LCMPn register represents the compare value of Compare Channel n for the low byte timer. This register\nis continuously compared to the counter value of the low byte timer, TCAn.LCNT. Normally, the outputs from the\ncomparators are then used to generate waveforms."
            },
            {
              "caption": "Low Compare",
              "reset": null,
              "name": "LCMP1",
              "offset": "0x2A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "LCMP1",
                  "caption": "Compare Value of Channel n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the compare value of channel n that is compared to TCAn.LCNT."
                }
              ],
              "description": "The TCAn.LCMPn register represents the compare value of Compare Channel n for the low byte timer. This register\nis continuously compared to the counter value of the low byte timer, TCAn.LCNT. Normally, the outputs from the\ncomparators are then used to generate waveforms."
            },
            {
              "caption": "Low Compare",
              "reset": null,
              "name": "LCMP2",
              "offset": "0x2C",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "LCMP2",
                  "caption": "Compare Value of Channel n",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the compare value of channel n that is compared to TCAn.LCNT."
                }
              ],
              "description": "The TCAn.LCMPn register represents the compare value of Compare Channel n for the low byte timer. This register\nis continuously compared to the counter value of the low byte timer, TCAn.LCNT. Normally, the outputs from the\ncomparators are then used to generate waveforms."
            },
            {
              "caption": "Low Count",
              "reset": null,
              "name": "LCNT",
              "offset": "0x20",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "LCNT",
                  "caption": "Counter Value for Low Byte Timer",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field defines the counter value of the low byte timer."
                }
              ],
              "description": "The TCAn.LCNT register contains the counter value for the low byte timer. CPU and UPDI write access has priority\nover count, clear or reload of the counter."
            },
            {
              "caption": "Low Period",
              "reset": null,
              "name": "LPER",
              "offset": "0x26",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "LPER",
                  "caption": "Period Value Low Byte Timer",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the TOP value for the low byte timer."
                }
              ],
              "description": "The TCAn.LPER register contains the TOP value for the low byte timer."
            }
          ]
        }
      ]
    },
    {
      "caption": "16-bit Timer Type B",
      "id": "I2119",
      "name": "TCB",
      "register_groups": [
        {
          "caption": "16-bit Timer Type B",
          "name": "TCB",
          "size": "0x10",
          "registers": [
            {
              "caption": "Compare or Capture",
              "reset": null,
              "name": "CCMP",
              "offset": "0xC",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CCMP",
                  "caption": "Capture/Compare Value Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the LSB of the 16-bit compare, capture, and top value."
                },
                {
                  "name": "CCMP",
                  "caption": "Capture/Compare Value High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit compare, capture, and top value."
                }
              ],
              "description": "The TCBn.CCMPL and TCBn.CCMPH register pair represents the 16-bit value TCBn.CCMP. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nThis register has different functions depending on the mode of operation:\n* For Capture operation, these registers contain the captured value of the counter at the time the capture occurs\n* In Periodic Interrupt/Time-Out and Single-Shot mode, this register acts as the TOP value\n* In 8-bit PWM mode, TCBn.CCMPL and TCBn.CCMPH act as two independent registers: The period of the\nwaveform is controlled by CCMPL, while CCMPH controls the duty cycle."
            },
            {
              "caption": "Count",
              "reset": "0x0000",
              "name": "CNT",
              "offset": "0xA",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CNT",
                  "caption": "Count Value Low",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the LSB of the 16-bit Counter register."
                },
                {
                  "name": "CNT",
                  "caption": "Count Value High",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The TCBn.CNTL and TCBn.CNTH register pair represents the 16-bit value TCBn.CNT. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nCPU and UPDI write access has priority over internal updates of the register."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Select",
                  "mask": "0x6",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "TCB_CLKSEL",
                  "description": "Writing these bits selects the clock source for this peripheral.\n\n\n| Value | Name    | Description           |\n| :---- | :------ | :-------------------- |\n| 0x0   | CLKDIV1 | CLK_PER               |\n| 0x1   | CLKDIV2 | CLK_PER/DIV2          |\n| 0x3   | CLKTCA  | Use TCA_CLK from TCA0 |\n| 0x4   | -       | Reserved              |\n\n"
                },
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the Timer/Counter type B peripheral."
                },
                {
                  "caption": "Run Standby",
                  "mask": "0x40",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit will enable the peripheral to run in Standby sleep mode. Not applicable when CLKSEL is set to\n0x2 (CLK_TCA)."
                },
                {
                  "caption": "Synchronize Update",
                  "mask": "0x10",
                  "name": "SYNCUPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', the TCB will restart whenever TCA0 is restarted or overflows. This can be used to\nsynchronize capture with the PWM period. Not applicable when CLKSEL is set to 0x1 (CLK_PER/2)."
                }
              ],
              "description": null
            },
            {
              "caption": "Control Register B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous Enable",
                  "mask": "0x40",
                  "name": "ASYNC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' will allow asynchronous updates of the TCB output signal in Single-Shot mode.\n\n\n| Value | Description                                                           |\n| :---- | :-------------------------------------------------------------------- |\n| 0     | The output will go HIGH when the counter starts after synchronization |\n| 1     | The output will go HIGH when an event arrives                         |\n\n"
                },
                {
                  "caption": "Pin Output Enable",
                  "mask": "0x10",
                  "name": "CCMPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the waveform output and makes the waveform output available on the corresponding\npin, overriding the value in the corresponding PORT output register. Configure the corresponding pin direction as an\noutput in the PORT peripheral.\n\n\n| Value | Description                                                             |\n| :---- | :---------------------------------------------------------------------- |\n| 0     | Waveform output is not enabled on the corresponding pin                 |\n| 1     | Waveform output will override the output value of the corresponding pin |\n\n"
                },
                {
                  "caption": "Pin Initial State",
                  "mask": "0x20",
                  "name": "CCMPINIT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is used to set the initial output value of the pin when a pin output is used. This bit does not affect the 8-bit\nPWM mode and Single-Shot mode.\n\n\n| Value | Description               |\n| :---- | :------------------------ |\n| 0     | Initial pin state is LOW  |\n| 1     | Initial pin state is HIGH |\n\n"
                },
                {
                  "caption": "Timer Mode",
                  "mask": "0x7",
                  "name": "CNTMODE",
                  "rw": "RW",
                  "values_ref": "TCB_CNTMODE",
                  "description": "Writing these bits selects the Timer mode.\n\n\n| Value | Name    | Description                                              |\n| :---- | :------ | :------------------------------------------------------- |\n| 0x0   | INT     | Periodic Interrupt mode                                  |\n| 0x1   | TIMEOUT | Time-out Check mode                                      |\n| 0x2   | CAPT    | Input Capture on Event mode                              |\n| 0x3   | FRQ     | Input Capture Frequency Measurement mode                 |\n| 0x4   | PW      | Input Capture Pulse-Width Measurement mode               |\n| 0x5   | FRQPW   | Input Capture Frequency and Pulse-Width Measurement mode |\n| 0x6   | SINGLE  | Single-Shot mode                                         |\n| 0x7   | PWM8    | 8-Bit PWM mode                                           |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Debug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Event Control",
              "reset": "0x00",
              "name": "EVCTRL",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Event Input Enable",
                  "mask": "0x1",
                  "name": "CAPTEI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the input capture event."
                },
                {
                  "caption": "Event Edge",
                  "mask": "0x10",
                  "name": "EDGE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is used to select the event edge. The effect of this bit is dependent on the selected Count Mode (CNTMODE)\nbit field in TCBn.CTRLB. \u201c\u2014\u201d means that an event or edge does not affect this mode.\nCount Mode EDGE Positive Edge Negative Edge\nPeriodic Interrupt mode\n0 \u2014 \u2014\n1 \u2014 \u2014\nTimeout Check mode\n0 Start counter Stop counter\n1 Stop counter Start counter\nInput Capture on Event mode\n0 Input Capture, interrupt \u2014\n1 \u2014 Input Capture, interrupt\nInput Capture Frequency\nMeasurement mode\n0\nInput Capture, clear and restart\ncounter, interrupt\n\u2014\n1 \u2014\nInput Capture, clear and restart\ncounter, interrupt\nInput Capture Pulse-Width\nMeasurement mode\n0 Clear and restart counter Input Capture, interrupt\n1 Input Capture, interrupt Clear and restart counter\nInput Capture Frequency and Pulse-\nWidth Measurement mode\n0\n* On the 1st Positive: Clear and restart counter\n* On the following Negative: Input Capture\n* On the 2nd Positive: Stop counter, interrupt\n1\n* On the 1st Negative: Clear and restart counter\n* On the following Positive: Input Capture\n* On the 2nd Negative: Stop counter, interrupt\nSingle-Shot mode\n0 Start counter \u2014\n1 Start counter Start counter\n8-Bit PWM mode\n0 \u2014 \u2014\n1 \u2014 \u2014"
                },
                {
                  "caption": "Input Capture Noise Cancellation Filter",
                  "mask": "0x40",
                  "name": "FILTER",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the Input Capture Noise Cancellation unit."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Capture or Timeout",
                  "mask": "0x1",
                  "name": "CAPT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables interrupt on capture."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Capture or Timeout",
                  "mask": "0x1",
                  "name": "CAPT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set when a capture interrupt occurs. The interrupt conditions are dependent on the Counter Mode\n(CNTMODE) bit field in the Control B (TCBn.CTRLB) register.\nThis bit is cleared by writing a '1' to it or when the Capture register is read in Capture mode.\nTable 21-6. Interrupt Sources Set Conditions by Counter Mode\nCounter Mode Interrupt Set Condition\nTOP\nValue\nCAPT\nPeriodic Interrupt mode Set when the counter reaches TOP\nCCMP CNT == TOPTimeout Check mode Set when the counter reaches TOP\nSingle-Shot mode Set when the counter reaches TOP\nInput Capture Frequency\nMeasurement mode\nSet on edge when the Capture register is\nloaded, and the counter restarts; the flag\nclears when the capture is read\n--\nOn Event, copy CNT to\nCCMP, and restart\ncounting (CNT ==\nBOTTOM)\nInput Capture on Event\nmode\nSet when an event occurs and the Capture\nregister is loaded; the flag clears when the\ncapture is read\nOn Event, copy CNT to\nCCMP, and continue\ncounting\nInput Capture Pulse-Width\nMeasurement mode\nSet on edge when the Capture register is\nloaded; the previous edge initialized the count;\nthe flag clears when the capture is read\nInput Capture Frequency\nand Pulse-Width\nMeasurement mode\nSet on the second edge (positive or negative)\nwhen the counter is stopped; the flag clears\nwhen the capture is read\n8-Bit PWM mode Set when the counter reaches CCML CCML CNT == CCML"
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x7",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run",
                  "mask": "0x1",
                  "name": "RUN",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When the counter is running, this bit is set to '1'. When the counter is stopped, this bit is cleared to '0'.\nThe bit is read-only and cannot be set by UPDI."
                }
              ],
              "description": null
            },
            {
              "caption": "Temporary Value",
              "reset": null,
              "name": "TEMP",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "TEMP",
                  "caption": "Temporary Value",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "The Temporary register is used by the CPU for 16-bit single-cycle access to the 16-bit registers of this peripheral. The\nregister is common for all the 16-bit registers of this peripheral and can be read and written by software. For more\ndetails on reading and writing 16-bit registers, refer to Accessing 16-Bit Registers in the AVR CPU section."
            }
          ]
        }
      ]
    },
    {
      "caption": "Timer Counter D",
      "id": "I2129",
      "name": "TCD",
      "register_groups": [
        {
          "caption": "Timer Counter D",
          "name": "TCD",
          "size": "0x40",
          "registers": [
            {
              "caption": "Capture A",
              "reset": null,
              "name": "CAPTUREA",
              "offset": "0x22",
              "rw": "R",
              "size": 2,
              "bitfields": [
                {
                  "name": "CAPTUREA",
                  "caption": "Temporary",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                },
                {
                  "name": "CAPTUREA",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The TCDn.CAPTUREAL and TCDn.CAPTUREAH register pair represents the 12-bit TCDn.CAPTUREA value.\nFor capture operation, these registers constitute the second buffer level and access point for the CPU. The\nTCDn.CAPTUREA registers are updated with the buffer value when an update condition occurs. The CAPTURE A\nregister contains the TCD counter value when a trigger A or software capture A occurs.\nThe TCD counter value is synchronized to CAPTUREA by either software or an event.\nThe capture register is blocked for an update of new capture data until the higher byte of this register is read."
            },
            {
              "caption": "Capture B",
              "reset": null,
              "name": "CAPTUREB",
              "offset": "0x24",
              "rw": "R",
              "size": 2,
              "bitfields": [
                {
                  "name": "CAPTUREB",
                  "caption": "Temporary",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                },
                {
                  "name": "CAPTUREB",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The TCDn.CAPTUREBL and TCDn.CAPTUREBH register pair represents the 12-bit TCDn.CAPTUREB value.\nFor capture operation, these registers constitute the second buffer level and access point for the CPU. The\nTCDn.CAPTUREB registers are updated with the buffer value when an update condition occurs. The CAPTURE B\nregister contains the TCD counter value when a trigger B or software capture B occurs.\nThe TCD counter value is synchronized to CAPTUREB by either software or an event.\nThe capture register is blocked for an update of new capture data until the higher byte of this register is read."
            },
            {
              "caption": "Compare A Clear",
              "reset": null,
              "name": "CMPACLR",
              "offset": "0x2A",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMPACLR",
                  "caption": "Temporary",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                },
                {
                  "name": "CMPACLR",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The TCDn.CMPACLRL and TCDn.CMPACLRH register pair represents the 12-bit TCDn.CMPACLR value. This\nregister is continuously compared to the counter value. Then, the outputs from the comparators are used for\ngenerating waveforms."
            },
            {
              "caption": "Compare A Set",
              "reset": null,
              "name": "CMPASET",
              "offset": "0x28",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMPASET",
                  "caption": "Temporary",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                },
                {
                  "name": "CMPASET",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The TCDn.CMPASETL and TCDn.CMPASETH register pair represents the 12-bit TCDn.CMPASET value. This\nregister is continuously compared to the counter value. Then, the outputs from the comparators are used for\ngenerating waveforms."
            },
            {
              "caption": "Compare B Clear",
              "reset": null,
              "name": "CMPBCLR",
              "offset": "0x2E",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMPBCLR",
                  "caption": "Temporary",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                },
                {
                  "name": "CMPBCLR",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The TCDn.CMPBCLRL and TCDn.CMPBCLRH register pair represents the 12-bit TCDn.CMPBCLR value. This\nregister is continuously compared to the counter value. Then, the outputs from the comparators are used for\ngenerating waveforms."
            },
            {
              "caption": "Compare B Set",
              "reset": null,
              "name": "CMPBSET",
              "offset": "0x2C",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "CMPBSET",
                  "caption": "Temporary",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                },
                {
                  "name": "CMPBSET",
                  "caption": "Counter High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "These bits hold the MSB of the 16-bit Counter register."
                }
              ],
              "description": "The TCDn.CMPBSETL and TCDn.CMPBSETH register pair represents the 12-bit TCDn.CMPBSET value. This\nregister is continuously compared to the counter value. Then, the outputs from the comparators are used for\ngenerating waveforms."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "clock select",
                  "mask": "0x60",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "TCD_CLKSEL",
                  "description": "The Clock Select bit field selects the clock source of the TCD clock.\n\n\n| Value | Name   | Description                            |\n| :---- | :----- | :------------------------------------- |\n| 0x0   | 20MHZ  | Internal 16/20 MHz Oscillator (OSC20M) |\n| 0x1   | -      | Reserved                               |\n| 0x2   | EXTCLK | External Clock                         |\n| 0x3   | SYSCLK | System Clock                           |\n\n"
                },
                {
                  "caption": "counter prescaler",
                  "mask": "0x18",
                  "name": "CNTPRES",
                  "rw": "RW",
                  "values_ref": "TCD_CNTPRES",
                  "description": "The Counter Prescaler bit field selects the division factor of the TCD counter clock.\n\n\n| Value | Name  | Description        |\n| :---- | :---- | :----------------- |\n| 0x0   | DIV1  | Division factor 1  |\n| 0x1   | DIV4  | Division factor 4  |\n| 0x2   | DIV32 | Division factor 32 |\n| 0x3   | -     | Reserved           |\n\n"
                },
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When writing to this bit, it will automatically be synchronized to the TCD clock domain.\nThis bit can be changed as long as the synchronization of this bit is not ongoing. See the Enable Ready (ENRDY) bit\nin the Status (TCDn.STATUS) register.\nThis bit is not enable-protected.\n\n\n| Value | Name  | Description                     |\n| :---- | :---- | :------------------------------ |\n| 0     | NO    | The TCD is disabled.            |\n| 1     | YES   | The TCD is enabled and running. |\n\n"
                },
                {
                  "caption": "Syncronization prescaler",
                  "mask": "0x6",
                  "name": "SYNCPRES",
                  "rw": "RW",
                  "values_ref": "TCD_SYNCPRES",
                  "description": "The Synchronization Prescaler bit field selects the division factor of the TCD clock.\n\n\n| Value | Name  | Description       |\n| :---- | :---- | :---------------- |\n| 0x0   | DIV1  | Division factor 1 |\n| 0x1   | DIV2  | Division factor 2 |\n| 0x2   | DIV4  | Division factor 4 |\n| 0x3   | DIV8  | Division factor 8 |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Waveform generation mode",
                  "mask": "0x3",
                  "name": "WGMODE",
                  "rw": "RW",
                  "values_ref": "TCD_WGMODE",
                  "description": "This bit field selects the waveform generation.\n\n\n| Value | Name     | Description     |\n| :---- | :------- | :-------------- |\n| 0x0   | ONERAMP  | One Ramp mode   |\n| 0x1   | TWORAMP  | Two Ramp mode   |\n| 0x2   | FOURRAMP | Four Ramp mode  |\n| 0x3   | DS       | Dual Slope mode |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Auto update",
                  "mask": "0x2",
                  "name": "AUPDATE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If this bit is written to '1', synchronization at the end of the TCD cycle is automatically requested after the Compare B\nClear High (TCDn.CMPBCLRH) register is written.\nIf the fifty percent waveform is enabled by setting the FIFTY bit in this register, writing the Compare A Clear High\nregister will also request a synchronization at the end of the TCD cycle if the AUPDATE bit is set."
                },
                {
                  "caption": "Compare C output select",
                  "mask": "0x40",
                  "name": "CMPCSEL",
                  "rw": "RW",
                  "values_ref": "TCD_CMPCSEL",
                  "description": "This bit selects which waveform will be connected to output C.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0     | PWMA  | Waveform A  |\n| 1     | PWMB  | Waveform B  |\n\n"
                },
                {
                  "caption": "Compare D output select",
                  "mask": "0x80",
                  "name": "CMPDSEL",
                  "rw": "RW",
                  "values_ref": "TCD_CMPDSEL",
                  "description": "This bit selects which waveform will be connected to output D.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0     | PWMA  | Waveform A  |\n| 1     | PWMB  | Waveform B  |\n\n"
                },
                {
                  "caption": "Compare output value override",
                  "mask": "0x1",
                  "name": "CMPOVR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', default values of the Waveform Outputs A and B are overridden by the values written in\nthe Compare x Value in Active state bit fields in the Control D register. See the 22.5.4  CTRLD register description for\nmore details."
                },
                {
                  "caption": "Fifty percent waveform",
                  "mask": "0x8",
                  "name": "FIFTY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If the two waveforms have identical characteristics, this bit can be written to '1'. This will cause any values written to\nthe TCDn.CMPBSET/TCDn.CLR register to also be written to the TCDn.CMPASET/TCDn.CLR register."
                }
              ],
              "description": null
            },
            {
              "caption": "Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare A value",
                  "mask": "0xf",
                  "name": "CMPAVAL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field sets the logical value of the PWMx signal for the corresponding states in the TCD cycle.\nThese settings are valid only if the Compare Output Value Override (CMPOVR) bit in the Control C (TCDn.CTRLC)\nregister is written to '1'.\nTable 22-12. Two and Four Ramp Mode\nCMPxVAL DTA OTA DTB OTB\nPWMA CMPAVAL[0] CMPAVAL[1] CMPAVAL[2] CMPAVAL[3]\nPWMB CMPBVAL[0] CMPBVAL[1] CMPBVAL[2] CMPBVAL[3]\nWhen used in One Ramp mode, WOA will only use the setup for Dead Time A (DTA) and on time A (OTA) to set the\noutput. WOB will only use Dead Time B (DTB) and On Time B (OTB) values to set the output.\nTable 22-13. One Ramp Mode\nCMPxVAL DTA OTA DTB OTB\nPWMA CMPAVAL[1] CMPAVAL[0] - -\nPWMB - - CMPBVAL[3] CMPBVAL[2]"
                },
                {
                  "caption": "Compare B value",
                  "mask": "0xf0",
                  "name": "CMPBVAL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field sets the logical value of the PWMx signal for the corresponding states in the TCD cycle.\nThese settings are valid only if the Compare Output Value Override (CMPOVR) bit in the Control C (TCDn.CTRLC)\nregister is written to '1'.\nTable 22-12. Two and Four Ramp Mode\nCMPxVAL DTA OTA DTB OTB\nPWMA CMPAVAL[0] CMPAVAL[1] CMPAVAL[2] CMPAVAL[3]\nPWMB CMPBVAL[0] CMPBVAL[1] CMPBVAL[2] CMPBVAL[3]\nWhen used in One Ramp mode, WOA will only use the setup for Dead Time A (DTA) and on time A (OTA) to set the\noutput. WOB will only use Dead Time B (DTB) and On Time B (OTB) values to set the output.\nTable 22-13. One Ramp Mode\nCMPxVAL DTA OTA DTB OTB\nPWMA CMPAVAL[1] CMPAVAL[0] - -\nPWMB - - CMPBVAL[3] CMPBVAL[2]"
                }
              ],
              "description": null
            },
            {
              "caption": "Control E",
              "reset": "0x00",
              "name": "CTRLE",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Disable at end of cycle",
                  "mask": "0x80",
                  "name": "DISEOC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', the TCD will automatically disable at the end of the TCD cycle.\nNote that ENRDY in TCDn.STATUS will stay low until the TCD is disabled.\nWriting to this bit has effect only if there is no ongoing synchronization of the ENABLE value in TCDn.CTRLA with the\nTCD domain. See also the ENRDY bit in TCDn.STATUS."
                },
                {
                  "caption": "Restart strobe",
                  "mask": "0x4",
                  "name": "RESTART",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', a restart of the TCD counter is executed as soon as this bit is synchronized to the TCD\ndomain.\nWriting to this bit has effect only if there is no ongoing synchronization of a command. See also the CMDRDY bit in\nTCDn.STATUS."
                },
                {
                  "caption": "Software Capture A Strobe",
                  "mask": "0x8",
                  "name": "SCAPTUREA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', a software capture to the Capture A (TCDn.CAPTUREAL/H) register is triggered as\nsoon as synchronization to the TCD clock domain occurs.\nWriting to this bit has effect only if there is no ongoing synchronization of a command. See also the CMDRDY bit in\nTCDn.STATUS."
                },
                {
                  "caption": "Software Capture B Strobe",
                  "mask": "0x10",
                  "name": "SCAPTUREB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', a software capture to the Capture B (TCDn.CAPTUREBL/H) register is triggered as\nsoon as synchronization to the TCD clock domain occurs.\nWriting to this bit has effect only if there is no ongoing synchronization of a command. See also the CMDRDY bit in\nTCDn.STATUS."
                },
                {
                  "caption": "synchronize strobe",
                  "mask": "0x2",
                  "name": "SYNC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', the double-buffered registers will be loaded to the TCD domain as soon as this bit is\nsynchronized to the TCD domain.\nWriting to this bit has effect only if there is no ongoing synchronization of a command. See also the CMDRDY bit in\nTCDn.STATUS."
                },
                {
                  "caption": "synchronize end of cycle strobe",
                  "mask": "0x1",
                  "name": "SYNCEOC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', the double-buffered registers will be loaded to the TCD domain at the end of the next\nTCD cycle.\nWriting to this bit has effect only if there is no ongoing synchronization of a command. See also the CMDRDY bit in\nTCDn.STATUS."
                }
              ],
              "description": null
            },
            {
              "caption": "Debug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x1E",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When written to '1', the peripheral will continue operating in Debug mode when the CPU is halted.\n\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                },
                {
                  "caption": "Fault detection",
                  "mask": "0x4",
                  "name": "FAULTDET",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit defines how the peripheral behaves when stopped in Debug mode.\n\n\n| Value | Name  | Description                                                                          |\n| :---- | :---- | :----------------------------------------------------------------------------------- |\n| 0     | NONE  | No Fault is generated if TCD is stopped in Debug mode                                |\n| 1     | FAULT | A Fault is generated, and both trigger flags are set, if TCD is halted in Debug mode |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Dither Control A",
              "reset": "0x00",
              "name": "DITCTRL",
              "offset": "0x18",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "dither select",
                  "mask": "0x3",
                  "name": "DITHERSEL",
                  "rw": "RW",
                  "values_ref": "TCD_DITHERSEL",
                  "description": "This bit field selects which state of the TCD cycle will benefit from the dither function. See the 22.3.3.5  Dithering\nsection.\n\n\n| Value | Name       | Description            |\n| :---- | :--------- | :--------------------- |\n| 0x0   | ONTIMEB    | On time ramp B         |\n| 0x1   | ONTIMEAB   | On time ramp A and B   |\n| 0x2   | DEADTIMEB  | Dead time ramp B       |\n| 0x3   | DEADTIMEAB | Dead time ramp A and B |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Dither value",
              "reset": "0x00",
              "name": "DITVAL",
              "offset": "0x19",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Dither value",
                  "mask": "0xf",
                  "name": "DITHER",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field configures the fractional adjustment of the on time or off time, according to the Dither Selection\n(DITHERSEL) bit field in the Dither Control (TCDn.DITCTRL) register. The DITHER value is added to a 4-bit\naccumulator at the end of each TCD cycle. When the accumulator overflows, the frequency adjustment will occur.\nThe DITHER bit field is double-buffered, so the new value is copied when an update condition occurs."
                }
              ],
              "description": null
            },
            {
              "caption": "Delay Control",
              "reset": "0x00",
              "name": "DLYCTRL",
              "offset": "0x14",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Delay prescaler",
                  "mask": "0x30",
                  "name": "DLYPRESC",
                  "rw": "RW",
                  "values_ref": "TCD_DLYPRESC",
                  "description": "This bit field controls the prescaler settings for the blanking or output event delay.\n\n\n| Value | Name  | Description                 |\n| :---- | :---- | :-------------------------- |\n| 0x0   | DIV1  | Prescaler division factor 1 |\n| 0x1   | DIV2  | Prescaler division factor 2 |\n| 0x2   | DIV4  | Prescaler division factor 4 |\n| 0x3   | DIV8  | Prescaler division factor 8 |\n\n"
                },
                {
                  "caption": "Delay select",
                  "mask": "0x3",
                  "name": "DLYSEL",
                  "rw": "RW",
                  "values_ref": "TCD_DLYSEL",
                  "description": "This bit field controls what function must be used by the delay trigger, the blanking or output event delay.\n\n\n| Value | Name    | Description                  |\n| :---- | :------ | :--------------------------- |\n| 0x0   | OFF     | Delay functionality not used |\n| 0x1   | INBLANK | Input blanking enabled       |\n| 0x2   | EVENT   | Event delay enabled          |\n| 0x3   | -       | Reserved                     |\n\n"
                },
                {
                  "caption": "Delay trigger",
                  "mask": "0xc",
                  "name": "DLYTRIG",
                  "rw": "RW",
                  "values_ref": "TCD_DLYTRIG",
                  "description": "This bit field controls the trigger of the blanking or output event delay.\n\n\n| Value | Name    | Description                           |\n| :---- | :------ | :------------------------------------ |\n| 0x0   | CMPASET | CMPASET triggers delay                |\n| 0x1   | CMPACLR | CMPACLR triggers delay                |\n| 0x2   | CMPBSET | CMPBSET triggers delay                |\n| 0x3   | CMPBCLR | CMPASET triggers delay (end of cycle) |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Delay value",
              "reset": "0x00",
              "name": "DLYVAL",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Delay value",
                  "mask": "0xff",
                  "name": "DLYVAL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field configures the blanking/output event delay time or event output synchronization delay in a number of\nprescaled TCD cycles."
                }
              ],
              "description": null
            },
            {
              "caption": "EVCTRLA",
              "reset": "0x00",
              "name": "EVCTRLA",
              "offset": "0x08",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "event action",
                  "mask": "0x4",
                  "name": "ACTION",
                  "rw": "RW",
                  "values_ref": "TCD_ACTION",
                  "description": "This bit enables capturing on the event input. By default, the input will trigger a Fault, depending on the Input Control\nregister's Input mode. It is also possible to trigger a capture on the event input.\n\n\n| Value | Name    | Description                         |\n| :---- | :------ | :---------------------------------- |\n| 0     | FAULT   | Event triggers a Fault.             |\n| 1     | CAPTURE | Event triggers a Fault and capture. |\n\n"
                },
                {
                  "caption": "event config",
                  "mask": "0xc0",
                  "name": "CFG",
                  "rw": "RW",
                  "values_ref": "TCD_CFG",
                  "description": "When the input capture noise canceler is activated (FILTERON), the event input is filtered. The filter function requires\nfour successive equal valued samples of the trigger pin to change its output. The input capture is, therefore, delayed\nby four clock cycles when the noise canceler is enabled (FILTERON).\nWhen the Asynchronous Event is enabled (ASYNCON), the event input will affect the output directly.\n\n\n| Value | Name     | Description                                       |\n| :---- | :------- | :------------------------------------------------ |\n| 0x0   | NEITHER  | Neither filter nor asynchronous event is enabled. |\n| 0x1   | FILTERON | Input capture noise cancellation filter enabled.  |\n| 0x2   | ASYNCON  | Asynchronous event output qualification enabled.  |\n| other | -        | Reserved.                                         |\n\n"
                },
                {
                  "caption": "edge select",
                  "mask": "0x10",
                  "name": "EDGE",
                  "rw": "RW",
                  "values_ref": "TCD_EDGE",
                  "description": "This bit is used to select the active edge or level for the event input.\n\n\n| Value | Name      | Description                                                                          |\n| :---- | :-------- | :----------------------------------------------------------------------------------- |\n| 0     | FALL_LOW  | The falling edge or low level of the event input triggers a Capture or Fault action. |\n| 1     | RISE_HIGH | The rising edge or high level of the event input triggers a Capture or Fault action. |\n\n"
                },
                {
                  "caption": "Trigger event enable",
                  "mask": "0x1",
                  "name": "TRIGEI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables event as the trigger for input A."
                }
              ],
              "description": null
            },
            {
              "caption": "EVCTRLB",
              "reset": "0x00",
              "name": "EVCTRLB",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "event action",
                  "mask": "0x4",
                  "name": "ACTION",
                  "rw": "RW",
                  "values_ref": "TCD_ACTION",
                  "description": "This bit enables capturing on the event input. By default, the input will trigger a Fault, depending on the Input Control\nregister's Input mode. It is also possible to trigger a capture on the event input.\n\n\n| Value | Name    | Description                         |\n| :---- | :------ | :---------------------------------- |\n| 0     | FAULT   | Event triggers a Fault.             |\n| 1     | CAPTURE | Event triggers a Fault and capture. |\n\n"
                },
                {
                  "caption": "event config",
                  "mask": "0xc0",
                  "name": "CFG",
                  "rw": "RW",
                  "values_ref": "TCD_CFG",
                  "description": "When the input capture noise canceler is activated (FILTERON), the event input is filtered. The filter function requires\nfour successive equal valued samples of the trigger pin to change its output. The input capture is, therefore, delayed\nby four clock cycles when the noise canceler is enabled (FILTERON).\nWhen the Asynchronous Event is enabled (ASYNCON), the event input will affect the output directly.\n\n\n| Value | Name     | Description                                       |\n| :---- | :------- | :------------------------------------------------ |\n| 0x0   | NEITHER  | Neither filter nor asynchronous event is enabled. |\n| 0x1   | FILTERON | Input capture noise cancellation filter enabled.  |\n| 0x2   | ASYNCON  | Asynchronous event output qualification enabled.  |\n| other | -        | Reserved.                                         |\n\n"
                },
                {
                  "caption": "edge select",
                  "mask": "0x10",
                  "name": "EDGE",
                  "rw": "RW",
                  "values_ref": "TCD_EDGE",
                  "description": "This bit is used to select the active edge or level for the event input.\n\n\n| Value | Name      | Description                                                                          |\n| :---- | :-------- | :----------------------------------------------------------------------------------- |\n| 0     | FALL_LOW  | The falling edge or low level of the event input triggers a Capture or Fault action. |\n| 1     | RISE_HIGH | The rising edge or high level of the event input triggers a Capture or Fault action. |\n\n"
                },
                {
                  "caption": "Trigger event enable",
                  "mask": "0x1",
                  "name": "TRIGEI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables event as a trigger for input B."
                }
              ],
              "description": null
            },
            {
              "caption": "Fault Control",
              "reset": "0x00",
              "name": "FAULTCTRL",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare A value",
                  "mask": "0x1",
                  "name": "CMPA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field sets the default state from Reset, or when an input event triggers a fault causing changes to the output.\nThis bit field is reset to '0' after a Power-On Reset. At any other reset, the content is kept but during the reset\nsequence loaded from the TCD Configuration (FUSE.TCDCFG) fuse."
                },
                {
                  "caption": "Compare A enable",
                  "mask": "0x10",
                  "name": "CMPAEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field enables compare as output on the pin. This bit field is reset to '0' after a Power-On Reset. At any other\nreset, the content is kept but during the reset sequence loaded from the TCD Configuration (FUSE.TCDCFG) fuse."
                },
                {
                  "caption": "Compare B value",
                  "mask": "0x2",
                  "name": "CMPB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field sets the default state from Reset, or when an input event triggers a fault causing changes to the output.\nThis bit field is reset to '0' after a Power-On Reset. At any other reset, the content is kept but during the reset\nsequence loaded from the TCD Configuration (FUSE.TCDCFG) fuse."
                },
                {
                  "caption": "Compare B enable",
                  "mask": "0x20",
                  "name": "CMPBEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field enables compare as output on the pin. This bit field is reset to '0' after a Power-On Reset. At any other\nreset, the content is kept but during the reset sequence loaded from the TCD Configuration (FUSE.TCDCFG) fuse."
                },
                {
                  "caption": "Compare C value",
                  "mask": "0x4",
                  "name": "CMPC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field sets the default state from Reset, or when an input event triggers a fault causing changes to the output.\nThis bit field is reset to '0' after a Power-On Reset. At any other reset, the content is kept but during the reset\nsequence loaded from the TCD Configuration (FUSE.TCDCFG) fuse."
                },
                {
                  "caption": "Compare C enable",
                  "mask": "0x40",
                  "name": "CMPCEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field enables compare as output on the pin. This bit field is reset to '0' after a Power-On Reset. At any other\nreset, the content is kept but during the reset sequence loaded from the TCD Configuration (FUSE.TCDCFG) fuse."
                },
                {
                  "caption": "Compare D vaule",
                  "mask": "0x8",
                  "name": "CMPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field sets the default state from Reset, or when an input event triggers a fault causing changes to the output.\nThis bit field is reset to '0' after a Power-On Reset. At any other reset, the content is kept but during the reset\nsequence loaded from the TCD Configuration (FUSE.TCDCFG) fuse."
                },
                {
                  "caption": "Compare D enable",
                  "mask": "0x80",
                  "name": "CMPDEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field enables compare as output on the pin. This bit field is reset to '0' after a Power-On Reset. At any other\nreset, the content is kept but during the reset sequence loaded from the TCD Configuration (FUSE.TCDCFG) fuse."
                }
              ],
              "description": null
            },
            {
              "caption": "Input Control A",
              "reset": "0x00",
              "name": "INPUTCTRLA",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Input mode",
                  "mask": "0xf",
                  "name": "INPUTMODE",
                  "rw": "RW",
                  "values_ref": "TCD_INPUTMODE",
                  "description": "\n\n| Value | Name         | Description                                                                   |\n| :---- | :----------- | :---------------------------------------------------------------------------- |\n| 0x0   | NONE         | The input has no action                                                       |\n| 0x1   | JMPWAIT      | Stop the output, jump to the opposite compare cycle, and wait                 |\n| 0x2   | EXECWAIT     | Stop the output, execute the opposite compare cycle, and wait                 |\n| 0x3   | EXECFAULT    | Stop the output, execute the opposite compare cycle while the Fault is active |\n| 0x4   | FREQ         | Stop all outputs, maintain the frequency                                      |\n| 0x5   | EXECDT       | Stop all outputs, execute dead time while the Fault is active                 |\n| 0x6   | WAIT         | Stop all outputs, jump to the next compare cycle, and wait                    |\n| 0x7   | WAITSW       | Stop all outputs, wait for software action                                    |\n| 0x8   | EDGETRIG     | Stop the output on the edge, jump to the next compare cycle                   |\n| 0x9   | EDGETRIGFREQ | Stop the output on the edge, maintain the frequency                           |\n| 0xA   | LVLTRIGFREQ  | Stop the output at level, maintain the frequency                              |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Input Control B",
              "reset": "0x00",
              "name": "INPUTCTRLB",
              "offset": "0x11",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Input mode",
                  "mask": "0xf",
                  "name": "INPUTMODE",
                  "rw": "RW",
                  "values_ref": "TCD_INPUTMODE",
                  "description": "\n\n| Value | Name         | Description                                                                   |\n| :---- | :----------- | :---------------------------------------------------------------------------- |\n| 0x0   | NONE         | The input has no action                                                       |\n| 0x1   | JMPWAIT      | Stop the output, jump to the opposite compare cycle, and wait                 |\n| 0x2   | EXECWAIT     | Stop the output, execute the opposite compare cycle, and wait                 |\n| 0x3   | EXECFAULT    | Stop the output, execute the opposite compare cycle while the Fault is active |\n| 0x4   | FREQ         | Stop all outputs, maintain the frequency                                      |\n| 0x5   | EXECDT       | Stop all outputs, execute dead time while the Fault is active                 |\n| 0x6   | WAIT         | Stop all outputs, jump to the next compare cycle, and wait                    |\n| 0x7   | WAITSW       | Stop all outputs, wait for software action                                    |\n| 0x8   | EDGETRIG     | Stop the output on the edge, jump to the next compare cycle                   |\n| 0x9   | EDGETRIGFREQ | Stop the output on the edge, maintain the frequency                           |\n| 0xA   | LVLTRIGFREQ  | Stop the output at level, maintain the frequency                              |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x0C",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Overflow interrupt enable",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the restart-of-sequence interrupt or overflow interrupt."
                },
                {
                  "caption": "Trigger A interrupt enable",
                  "mask": "0x4",
                  "name": "TRIGA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the interrupt when trigger input A is received."
                },
                {
                  "caption": "Trigger B interrupt enable",
                  "mask": "0x8",
                  "name": "TRIGB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the interrupt when trigger input B is received."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x0D",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Overflow interrupt enable",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Overflow Flag (OVF) is set at the end of a TCD cycle. The flag is cleared by writing a '1' to its bit location."
                },
                {
                  "caption": "Trigger A interrupt enable",
                  "mask": "0x4",
                  "name": "TRIGA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Trigger A Interrupt (TRIGA) flag is set on a Trigger A or Capture A condition. The flag is cleared by writing a '1' to\nits bit location."
                },
                {
                  "caption": "Trigger B interrupt enable",
                  "mask": "0x8",
                  "name": "TRIGB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Trigger B Interrupt (TRIGB) flag is set on a Trigger B or Capture B condition. The flag is cleared by writing a '1' to\nits bit location."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x0E",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command ready",
                  "mask": "0x2",
                  "name": "CMDRDY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This status bit tells when a command is synced to the TCD domain and the system is ready to receive new\ncommands.\nThe following actions clear the CMDRDY bit:"
                },
                {
                  "caption": "Enable ready",
                  "mask": "0x1",
                  "name": "ENRDY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This status bit tells when the ENABLE value in TCDn.CTRLA is synced to the TCD domain and is ready to be written\nto again.\nThe following actions clear the ENRDY bit:"
                },
                {
                  "caption": "PWM activity on A",
                  "mask": "0x40",
                  "name": "PWMACTA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set by hardware each time the WOA output toggles from '0' to '1' or from '1' to '0'.\nThis status bit must be cleared by software by writing a '1' to it before new PWM activity can be detected."
                },
                {
                  "caption": "PWM activity on B",
                  "mask": "0x80",
                  "name": "PWMACTB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set by hardware each time the WOB output toggles from '0' to '1' or from '1' to '0'.\nThis status bit must be cleared by software by writing a '1' to it before new PWM activity can be detected."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Two-Wire Interface",
      "id": "I2110",
      "name": "TWI",
      "register_groups": [
        {
          "caption": "Two-Wire Interface",
          "name": "TWI",
          "size": "0x10",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "FM Plus Enable",
                  "mask": "0x2",
                  "name": "FMPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit selects the 1 MHz bus speed for the TWI in the default configuration.\n\n\n| Value | Name  | Description                             |\n| :---- | :---- | :-------------------------------------- |\n| 0     | OFF   | Operating in Standard mode or Fast mode |\n| 1     | ON    | Operating in Fast mode Plus             |\n\n"
                },
                {
                  "caption": "SDA Hold Time",
                  "mask": "0xc",
                  "name": "SDAHOLD",
                  "rw": "RW",
                  "values_ref": "TWI_SDAHOLD",
                  "description": "This bit field selects the SDA hold time for the TWI. See the Electrical Characteristics section for details.\n\n\n| Value | Name  | Description                                                 |\n| :---- | :---- | :---------------------------------------------------------- |\n| 0x0   | OFF   | Hold time OFF                                               |\n| 0x1   | 50NS  | Short hold time                                             |\n| 0x2   | 300NS | Meets the SMBus 2.0 specifications under typical conditions |\n| 0x3   | 500NS | Meets the SMBus 2.0 across all corners                      |\n\n"
                },
                {
                  "caption": "SDA Setup Time",
                  "mask": "0x10",
                  "name": "SDASETUP",
                  "rw": "RW",
                  "values_ref": "TWI_SDASETUP",
                  "description": "This bit is used in TWI Client mode to select the clock hold time and to ensure the minimum setup time on the SDA\nout signal.\n\n\n| Value | Name  | Description                          |\n| :---- | :---- | :----------------------------------- |\n| 0     | 4CYC  | SDA setup time is four clock cycles  |\n| 1     | 8CYC  | SDA setup time is eight clock cycles |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Debug Control Register",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Refer to the Debug Operation section for details.\n\n\n| Value | Description                                                             |\n| :---- | :---------------------------------------------------------------------- |\n| 0     | The TWI is halted in Break Debug mode and ignores events                |\n| 1     | The TWI will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Master Address",
              "reset": null,
              "name": "MADDR",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "MADDR",
                  "caption": "Address",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This register contains the address of the external client device. When this bit field is written, the TWI will issue a Start\ncondition, and the shift register performs a byte transmit operation on the bus depending on the bus state.\nThis register can be read at any time without interfering with the ongoing bus activity since a read access does not\ntrigger the host logic to perform any bus protocol related operations.\nThe host control logic uses the bit 0 of this register as the R/W direction bit."
                }
              ],
              "description": null
            },
            {
              "caption": "Master Baurd Rate Control",
              "reset": null,
              "name": "MBAUD",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "MBAUD",
                  "caption": "Baud Rate",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field is used to derive the SCL high and low time. It must be written while the host is disabled. The host can\nbe disabled by writing '0' to the Enable TWI Host (ENABLE) bit from the Host Control A (TWIn.MCTRLA) register.\nRefer to the Clock Generation section for more information on how to calculate the frequency of the SCL."
                }
              ],
              "description": null
            },
            {
              "caption": "Master Control A",
              "reset": "0x00",
              "name": "MCTRLA",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable TWI Master",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the TWI as host."
                },
                {
                  "caption": "Quick Command Enable",
                  "mask": "0x10",
                  "name": "QCEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the Quick Command mode. If the Quick Command mode is enabled and a client\nacknowledges the address, the corresponding Read Interrupt Flag (RIF) or Write Interrupt Flag (WIF) will be set\ndepending on the value of the R/W bit.\nThe software must issue a Stop command by writing to the Command (MCMD) bit field in the Host Control B\n(TWIn.MCTRLB) register."
                },
                {
                  "caption": "Read Interrupt Enable",
                  "mask": "0x80",
                  "name": "RIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "A TWI host read interrupt will be generated only if this bit and the Global Interrupt Enable (I) bit in the Status\n(CPU.SREG) register are set to '1'.\nWriting a '1' to this bit enables the interrupt on the Read Interrupt Flag (RIF) in the Host Status (TWIn.MSTATUS)\nregister. When the host read interrupt occurs, the RIF flag is set to '1'."
                },
                {
                  "caption": "Smart Mode Enable",
                  "mask": "0x2",
                  "name": "SMEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the Host Smart mode. When the Smart mode is enabled, the existing value in the\nAcknowledge Action (ACKACT) bit from the Host Control B (TWIn.MCTRLB) register is sent immediately after\nreading the Host Data (TWIn.MDATA) register."
                },
                {
                  "caption": "Inactive Bus Timeout",
                  "mask": "0xc",
                  "name": "TIMEOUT",
                  "rw": "RW",
                  "values_ref": "TWI_TIMEOUT",
                  "description": "Setting this bit field to a nonzero value will enable the inactive bus time-out supervisor. If the bus is inactive for longer\nthan the TIMEOUT setting, the bus state logic will enter the Idle state.\n\n\n| Value | Name     | Description                                            |\n| :---- | :------- | :----------------------------------------------------- |\n| 0x0   | DISABLED | Bus time-out disabled - I2C                            |\n| 0x1   | 50US     | 50 \u00b5s - SMBus (assume the baud rate is set to 100 kHz) |\n| 0x2   | 100US    | 100 \u00b5s (assume the baud rate is set to 100 kHz)        |\n| 0x3   | 200US    | 200 \u00b5s (assume the baud rate is set to 100 kHz)        |\n\n"
                },
                {
                  "caption": "Write Interrupt Enable",
                  "mask": "0x40",
                  "name": "WIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "A TWI host write interrupt will be generated only if this bit and the Global Interrupt Enable (I) bit in the Status\n(CPU.SREG) register are set to '1'.\nWriting a '1' to this bit enables the interrupt on the Write Interrupt Flag (WIF) in the Host Status (TWIn.MSTATUS)\nregister. When the host write interrupt occurs, the WIF flag is set to '1'."
                }
              ],
              "description": null
            },
            {
              "caption": "Master Control B",
              "reset": "0x00",
              "name": "MCTRLB",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Acknowledge Action",
                  "mask": "0x4",
                  "name": "ACKACT",
                  "rw": "RW",
                  "values_ref": "TWI_ACKACT",
                  "description": "The ACKACT(1) bit represents the behavior in the Host mode under certain conditions defined by the bus state and\nthe software interaction. If the Smart Mode Enable (SMEN) bit in the Host Control A (TWIn.MCTRLA) register is set\nto '1', the acknowledge action is performed when the Host Data (TWIn.MDATA) register is read, else a command\nmust be written to the Command (MCDM) bit field in the Host Control B (TWIn.MCTRLB) register.\nThe acknowledge action is not performed when the Host Data (TWIn.MDATA) register is written since the host is\nsending data.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0     | ACK   | Send ACK    |\n| 1     | NACK  | Send NACK   |\n\n"
                },
                {
                  "caption": "Flush",
                  "mask": "0x8",
                  "name": "FLUSH",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit clears the internal state of the host and the bus states changes to Idle. The TWI will transmit invalid data if\nthe Host Data (TWIn.MDATA) register is written before the Host Address (TWIn.MADDR) register.\nWriting a '1' to this bit generates a strobe for one clock cycle, disabling the host and then re-enabling the host. Writing\na '0' to this bit has no effect."
                },
                {
                  "caption": "Command",
                  "mask": "0x3",
                  "name": "MCMD",
                  "rw": "RW",
                  "values_ref": "TWI_MCMD",
                  "description": "The MCMD(1) bit field is a strobe. This bit field is always read as '0'.\nWriting to this bit field triggers a host operation, as defined by the table below.\nTable 26-2. Command Settings\nMCMD[1:0] Group\nConfiguration\nDIR Description\n0x0 NOACT X Reserved\n0x1 REPSTART X Execute Acknowledge Action followed by repeated Start condition\n0x2 RECVTRANS\nW Execute Acknowledge Action (no action) followed by a byte write operation(2)\nR Execute Acknowledge Action followed by a byte read operation\n0x3 STOP X Execute Acknowledge Action followed by issuing a Stop condition\nNotes:"
                }
              ],
              "description": null
            },
            {
              "caption": "Master Data",
              "reset": null,
              "name": "MDATA",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "MDATA",
                  "caption": "Data",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field provides direct access to the host's physical shift register, which is used to shift out data on the bus\n(transmit) and to shift in data received from the bus (receive). The direct access implies that the MDATA register\ncannot be accessed during byte transmissions.\nReading valid data or writing data to be transmitted can only be successful when the CLKHOLD bit is read as '1' or\nwhen an interrupt occurs.\nA write access to the MDATA register will command the host to perform a byte transmit operation on the bus, directly\nfollowed by receiving the Acknowledge bit from the client. This is independent of the Acknowledge Action (ACKACT)\nbit from the Host Control B (TWIn.MCTRLB) register. The write operation is performed regardless of winning or losing\narbitration before the Write Interrupt Flag (WIF) is set to '1'.\nIf the Smart Mode Enable (SMEN) bit in the Host Control A (TWIn.MCTRLA) register is set to '1', a read access to\nthe MDATA register will command the host to perform an acknowledge action. This is dependent on the setting of the\nAcknowledge Action (ACKACT) bit from the Host Control B (TWIn.MCTRLB) register.\nNotes:"
                }
              ],
              "description": null
            },
            {
              "caption": "Master Status",
              "reset": "0x00",
              "name": "MSTATUS",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Arbitration Lost",
                  "mask": "0x8",
                  "name": "ARBLOST",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is read as '1', it indicates that the host has lost arbitration. This can happen in one of the following\ncases:"
                },
                {
                  "caption": "Bus Error",
                  "mask": "0x4",
                  "name": "BUSERR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The BUSERR flag indicates that an illegal bus operation has occurred. An illegal bus operation is detected if a\nprotocol violating the Start (S), repeated Start (Sr), or Stop (P) conditions is detected on the TWI bus lines. A Start\ncondition directly followed by a Stop condition is one example of a protocol violation.\nThe BUSERR flag can be cleared by choosing one of the following methods:"
                },
                {
                  "caption": "Bus State",
                  "mask": "0x3",
                  "name": "BUSSTATE",
                  "rw": "RW",
                  "values_ref": "TWI_BUSSTATE",
                  "description": "This bit field indicates the current TWI bus state.\n\n\n| Value | Name    | Description               |\n| :---- | :------ | :------------------------ |\n| 0x0   | UNKNOWN | Unknown bus state         |\n| 0x1   | IDLE    | Idle bus state            |\n| 0x2   | OWNER   | This TWI controls the bus |\n| 0x3   | BUSY    | Busy bus state            |\n\n"
                },
                {
                  "caption": "Clock Hold",
                  "mask": "0x20",
                  "name": "CLKHOLD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is read as '1', it indicates that the host is currently holding the SCL low, stretching the TWI clock period.\nThis bit can be cleared by choosing one of the methods described for the RIF flag."
                },
                {
                  "caption": "Read Interrupt Flag",
                  "mask": "0x80",
                  "name": "RIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set to '1' when the host byte read operation is completed.\nThe RIF flag can be used for a host read interrupt. More information can be found in the Read Interrupt Enable\n(RIEN) bit from the Host Control A (TWIn.MCTRLA) register.\nThis flag is automatically cleared when accessing several other TWI registers. The RIF flag can be cleared by\nchoosing one of the following methods:"
                },
                {
                  "caption": "Received Acknowledge",
                  "mask": "0x10",
                  "name": "RXACK",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When this flag is read as '0', it indicates that the most recent Acknowledge bit from the client was ACK, and the client\nis ready for more data.\nWhen this flag is read as '1', it indicates that the most recent Acknowledge bit from the client was NACK, and the\nclient is not able to or does not need to receive more data."
                },
                {
                  "caption": "Write Interrupt Flag",
                  "mask": "0x40",
                  "name": "WIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set to '1' when a host transmit address or byte write operation is completed, regardless of the occurrence\nof a bus error or arbitration lost condition.\nThe WIF flag can be used for a host write interrupt. More information can be found from the Write Interrupt Enable\n(WIEN) bit in the Host Control A (TWIn.MCTRLA) register.\nThis flag can be cleared by choosing one of the methods described for the RIF flag."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Address",
              "reset": null,
              "name": "SADDR",
              "offset": "0xC",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "SADDR",
                  "caption": "Address",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "The Client Address (TWIn.SADDR) register is used by the client address match logic to determine if a host device\nhas addressed the TWI client. The Address or Stop Interrupt Flag (APIF) and the Address or Stop (AP) bit in the\nClient Status (TWIn.SSTATUS) register are set to '1' if an address packet is received.\nThe upper seven bits (ADDR[7:1]) of the TWIn.SADDR register represent the main client address.\nThe Least Significant bit (ADDR[0]) of the TWIn.SADDR register is used for the recognition of the General Call\nAddress (0x00) of the I2C protocol. This feature is enabled when this bit is set to '1'."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Address Mask",
              "reset": null,
              "name": "SADDRMASK",
              "offset": "0xE",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Address Enable",
                  "mask": "0x1",
                  "name": "ADDREN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If this bit is written to '0', the TWIn.SADDRMASK register acts as a mask to the TWIn.SADDR register.\nIf this bit is written to '1', the client address match logic responds to the two unique addresses in the client\nTWIn.SADDR and TWIn.SADDRMASK registers."
                },
                {
                  "caption": "Address Mask",
                  "mask": "0xfe",
                  "name": "ADDRMASK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The ADDRMASK bit field acts as a second address match or an address mask register depending on the ADDREN\nbit.\nIf the ADDREN bit is written to '0', the ADDRMASK bit field can be loaded with a 7-bit Client Address mask. Each of\nthe bits in the Client Address Mask (TWIn.SADDRMASK) register can mask (disable) the corresponding address bits\nin the TWI Client Address (TWIn.SADDR) register. When a bit from the mask is written to '1', the address match logic\nignores the comparison between the incoming address bit and the corresponding bit in the Client Address\n(TWIn.SADDR) register. In other words, masked bits will always match, making it possible to recognize the ranges of\naddresses.\nIf the ADDREN bit is written to '1', the Client Address Mask (TWIn.SADDRMASK) register can be loaded with a\nsecond client address in addition to the Client Address (TWIn.SADDR) register. In this mode, the client will have two\nunique addresses, one in the Client Address (TWIn.SADDR) register and the other one in the Client Address Mask\n(TWIn.SADDRMASK) register."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Control A",
              "reset": "0x00",
              "name": "SCTRLA",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Address/Stop Interrupt Enable",
                  "mask": "0x40",
                  "name": "APIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables an interrupt on the Address or Stop Interrupt Flag (APIF) from the Client Status\n(TWIn.SSTATUS) register.\nA TWI client address or stop interrupt will be generated only if this bit, the APIF flag, and the Global Interrupt Enable\n(I) bit in the Status (CPU.SREG) register are all '1'.\nNotes:"
                },
                {
                  "caption": "Data Interrupt Enable",
                  "mask": "0x80",
                  "name": "DIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables an interrupt on the Data Interrupt Flag (DIF) from the Client Status (TWIn.SSTATUS)\nregister.\nA TWI client data interrupt will be generated only if this bit, the DIF flag, and the Global Interrupt Enable (I) bit in\nStatus (CPU.SREG) register are all '1'."
                },
                {
                  "caption": "Enable TWI Slave",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the TWI client."
                },
                {
                  "caption": "Stop Interrupt Enable",
                  "mask": "0x20",
                  "name": "PIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' allows the Address or Stop Interrupt Flag (APIF) in the Client Status (TWIn.SSTATUS) register to\nbe set when a Stop condition occurs. To use this feature, the main clock frequency must be at least four times the\nSCL frequency."
                },
                {
                  "caption": "Promiscuous Mode Enable",
                  "mask": "0x4",
                  "name": "PMEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If this bit is written to '1', the client address match logic responds to all received addresses.\nIf this bit is written to '0', the address match logic uses the Client Address (TWIn.SADDR) register to determine which\naddress to recognize as the client's address."
                },
                {
                  "caption": "Smart Mode Enable",
                  "mask": "0x2",
                  "name": "SMEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the client Smart mode. When the Smart mode is enabled, issuing a command by writing\nto the Command (SCMD) bit field in the Client Control B (TWIn.SCTRLB) register or accessing the Client Data\n(TWIn.SDATA) register resets the interrupt, and the operation continues. If the Smart mode is disabled, the client\nalways waits for a new client command before continuing."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Control B",
              "reset": "0x00",
              "name": "SCTRLB",
              "offset": "0xA",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Acknowledge Action",
                  "mask": "0x4",
                  "name": "ACKACT",
                  "rw": "RW",
                  "values_ref": "TWI_ACKACT",
                  "description": "The ACKACT(1) bit represents the behavior of the client device under certain conditions defined by the bus protocol\nstate and the software interaction. If the Smart Mode Enable (SMEN) bit in the Client Control A (TWIn.SCTRLA)\nregister is set to '1', the acknowledge action is performed when the Client Data (TWIn.SDATA) register is read, else a\ncommand must be written to the Command (SCMD) bit field in the Client Control B (TWIn.SCTRLB) register.\nThe acknowledge action is not performed when the Client Data (TWIn.SDATA) register is written since the client is\nsending data.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0     | ACK   | Send ACK    |\n| 1     | NACK  | Send NACK   |\n\n"
                },
                {
                  "caption": "Command",
                  "mask": "0x3",
                  "name": "SCMD",
                  "rw": "RW",
                  "values_ref": "TWI_SCMD",
                  "description": "The SCMD(1) bit field is a strobe. This bit field is always read as '0'.\nWriting to this bit field triggers a client operation as defined by the table below.\nTable 26-3. Command Settings\nValue Name DIR Description\n0x0 NOACT X No action\n0x1 \u2014 X Reserved\n0x2 COMPTRANS\nW\nExecute Acknowledge Action succeeded by waiting\nfor any Start (S/Sr) condition Used to complete a transaction\nR Wait for any Start (S/Sr) condition\n0x3 RESPONSE\nW Execute Acknowledge Action succeeded by reception of next byte\nR\nUsed in response to an address interrupt (APIF): Execute Acknowledge Action\nsucceeded by client data interrupt.\nUsed in response to a data interrupt (DIF): Execute a byte read operation followed by\nAcknowledge Action.\nNote: 1. The ACKACT bit and the SCMD bit field can be written at the same time. The ACKACT will be updated\nbefore the command is triggered."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Data",
              "reset": null,
              "name": "SDATA",
              "offset": "0xD",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "SDATA",
                  "caption": "Data",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field provides access to the client data register.\nReading valid data or writing data to be transmitted can only be achieved when the SCL is held low by the client (i.e.,\nwhen the client CLKHOLD bit is set to '1'). It is not necessary to check the Clock Hold (CLKHOLD) bit from the Client\nStatus (TWIn.SSTATUS) register in software before accessing the SDATA register if the software keeps track of the\npresent protocol state by using interrupts or observing the interrupt flags.\nIf the Smart Mode Enable (SMEN) bit in the Client Control A (TWIn.SCTRLA) register is set to '1', a read access to\nthe SDATA register, when the clock hold is active, auto-triggers bus operations and will command the client to\nperform an acknowledge action. This is dependent on the setting of the Acknowledge Action (ACKACT) bit from the\nClient Control B (TWIn.SCTRLB) register."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Status",
              "reset": "0x00",
              "name": "SSTATUS",
              "offset": "0xB",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Slave Address or Stop",
                  "mask": "0x1",
                  "name": "AP",
                  "rw": "R",
                  "values_ref": "TWI_AP",
                  "description": "When the TWI client Address or Stop Interrupt Flag (APIF) is set to '1', this bit determines whether the interrupt is\ndue to an address detection or a Stop condition.\n\n\n| Value | Name  | Description                                                |\n| :---- | :---- | :--------------------------------------------------------- |\n| 0     | STOP  | A Stop condition generated the interrupt on the APIF flag  |\n| 1     | ADR   | Address detection generated the interrupt on the APIF flag |\n\n"
                },
                {
                  "caption": "Address/Stop Interrupt Flag",
                  "mask": "0x40",
                  "name": "APIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set to '1' when the client address has been received or by a Stop condition.\nThe APIF flag can generate a client address or stop interrupt. More information can be found in the Address or Stop\nInterrupt Enable (APIEN) bit from the Client Control A (TWIn.SCTRLA) register.\nThis flag can be cleared by choosing one of the methods described for the DIF flag."
                },
                {
                  "caption": "Bus Error",
                  "mask": "0x4",
                  "name": "BUSERR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The BUSERR flag indicates that an illegal bus operation has occurred. Illegal bus operation is detected if a protocol\nviolating the Start (S), repeated Start (Sr), or Stop (P) conditions is detected on the TWI bus lines. A Start condition\ndirectly followed by a Stop condition is one example of a protocol violation.\nWriting a '1' to this bit will clear the BUSERR flag.\nThe TWI bus error detector is part of the TWI host circuitry. For the bus errors to be detected by the client, the TWI\nhost must be enabled, and the main clock frequency must be at least four times the SCL frequency. The TWI host\ncan be enabled by writing a '1' to the ENABLE bit in the TWIn.MCTRLA register."
                },
                {
                  "caption": "Clock Hold",
                  "mask": "0x20",
                  "name": "CLKHOLD",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When this bit is read as '1', it indicates that the client is currently holding the SCL low, stretching the TWI clock\nperiod.\nThis bit is set to '1' when an address or data interrupt occurs. Resetting the corresponding interrupt will indirectly set\nthis bit to '0'."
                },
                {
                  "caption": "Collision",
                  "mask": "0x8",
                  "name": "COLL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is read as '1', it indicates that the client has not been able to do one of the following:"
                },
                {
                  "caption": "Data Interrupt Flag",
                  "mask": "0x80",
                  "name": "DIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set to '1' when the client byte transmit or receive operation is completed without any bus errors. This flag\ncan be set to '1' with an unsuccessful transaction in case of collision detection. More information can be found in the\nCollision (COLL) bit description.\nThe DIF flag can generate a client data interrupt. More information can be found in Data Interrupt Enable (DIEN) bit\nfrom the Client Control A (TWIn.SCTRLA) register.\nThis flag is automatically cleared when accessing several other TWI registers. The DIF flag can be cleared by\nchoosing one of the following methods:"
                },
                {
                  "caption": "Read/Write Direction",
                  "mask": "0x2",
                  "name": "DIR",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit indicates the current TWI bus direction. The DIR bit reflects the direction bit value from the last address\npacket received from a host TWI device.\nWhen this bit is read as '1', it indicates that a host read operation is in progress.\nWhen this bit is read as '0', it indicates that a host write operation is in progress."
                },
                {
                  "caption": "Received Acknowledge",
                  "mask": "0x10",
                  "name": "RXACK",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When this flag is read as '0', it indicates that the most recent Acknowledge bit from the host was ACK.\nWhen this flag is read as '1', it indicates that the most recent Acknowledge bit from the host was NACK."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Universal Synchronous and Asynchronous Receiver and Transmitter",
      "id": "I2108",
      "name": "USART",
      "register_groups": [
        {
          "caption": "Universal Synchronous and Asynchronous Receiver and Transmitter",
          "name": "USART",
          "size": "0x10",
          "registers": [
            {
              "caption": "Baud Rate",
              "reset": "0x0000",
              "name": "BAUD",
              "offset": "0x8",
              "rw": "RW",
              "size": 2,
              "bitfields": [
                {
                  "name": "BAUD",
                  "caption": "USART Baud Rate Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit Baud register."
                },
                {
                  "name": "BAUD",
                  "caption": "USART Baud Rate High Byte",
                  "mask": "0xff00",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the MSB of the 16-bit Baud register."
                }
              ],
              "description": "The USARTn.BAUDL and USARTn.BAUDH register pair represents the 16-bit value, USARTn.BAUD. The low byte\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nOngoing transmissions of the transmitter and receiver will be corrupted if the baud rate is changed. Writing to this\nregister will trigger an immediate update of the baud rate prescaler. For more information on how to set the baud rate,\nsee Table 24-1."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Auto-baud Error Interrupt Enable",
                  "mask": "0x4",
                  "name": "ABEIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the Auto-baud Error Interrupt is enabled or not. When enabled, the interrupt will be triggered\nwhen the ISFIF bit in the USARTn.STATUS register is set.\n\n\n| Value | Description                               |\n| :---- | :---------------------------------------- |\n| 0     | The Auto-Baud Error Interrupt is disabled |\n| 1     | The Auto-Baud Error Interrupt is enabled  |\n\n"
                },
                {
                  "caption": "Data Register Empty Interrupt Enable",
                  "mask": "0x20",
                  "name": "DREIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the Data Register Empty Interrupt is enabled or not. When enabled, the interrupt will be\ntriggered when the DREIF bit in the USARTn.STATUS register is set.\n\n\n| Value | Description                                   |\n| :---- | :-------------------------------------------- |\n| 0     | The Data Register Empty Interrupt is disabled |\n| 1     | The Data Register Empty Interrupt is enabled  |\n\n"
                },
                {
                  "caption": "Loop-back Mode Enable",
                  "mask": "0x8",
                  "name": "LBME",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the Loop-back mode is enabled or not. When enabled, an internal connection between the\nTXD pin and the USART receiver is created, and the input from the RXD pin to the USART receiver is disconnected.\n\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | Loop-back mode is disabled |\n| 1     | Loop-back mode is enabled  |\n\n"
                },
                {
                  "caption": "RS485 Mode internal transmitter",
                  "mask": "0x3",
                  "name": "RS485",
                  "rw": "RW",
                  "values_ref": "USART_RS485",
                  "description": "This bit field enables the RS-485 and selects the operation mode. Writing RS485[0] to '1' enables the RS-485 mode,\nwhich automatically drives the XDIR pin high one clock cycle before starting transmission and pulls it low again when\nthe transmission is complete. Writing RS485[1] to '1' enables the RS-485 mode, which automatically sets the TXD\npin to output one clock cycle before starting transmission and sets it back to input when the transmission is complete."
                },
                {
                  "caption": "Receive Complete Interrupt Enable",
                  "mask": "0x80",
                  "name": "RXCIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the Receive Complete Interrupt is enabled or not. When enabled, the interrupt will be\ntriggered when the RXCIF bit in the USARTn.STATUS register is set.\n\n\n| Value | Description                                |\n| :---- | :----------------------------------------- |\n| 0     | The Receive Complete Interrupt is disabled |\n| 1     | The Receive Complete Interrupt is enabled  |\n\n"
                },
                {
                  "caption": "Receiver Start Frame Interrupt Enable",
                  "mask": "0x10",
                  "name": "RXSIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the Receiver Start Frame Interrupt is enabled or not. When enabled, the interrupt will be\ntriggered when the RXSIF bit in the USARTn.STATUS register is set.\n\n\n| Value | Description                                    |\n| :---- | :--------------------------------------------- |\n| 0     | The Receiver Start Frame Interrupt is disabled |\n| 1     | The Receiver Start Frame Interrupt is enabled  |\n\n"
                },
                {
                  "caption": "Transmit Complete Interrupt Enable",
                  "mask": "0x40",
                  "name": "TXCIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the Transmit Complete Interrupt is enabled or not. When enabled, the interrupt will be\ntriggered when the TXCIF bit in the USARTn.STATUS register is set.\n\n\n| Value | Description                                 |\n| :---- | :------------------------------------------ |\n| 0     | The Transmit Complete Interrupt is disabled |\n| 1     | The Transmit Complete Interrupt is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Multi-processor Communication Mode",
                  "mask": "0x1",
                  "name": "MPCM",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the Multi-Processor Communication mode is enabled or not. Refer to 24.3.4.3\nMultiprocessor Communication for more information.\n\n\n| Value | Description                                    |\n| :---- | :--------------------------------------------- |\n| 0     | Multi-Processor Communication mode is disabled |\n| 1     | Multi-Processor Communication mode is enabled  |\n\n"
                },
                {
                  "caption": "Open Drain Mode Enable",
                  "mask": "0x8",
                  "name": "ODME",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether Open Drain mode is enabled or not. See the One-Wire Mode section for more information.\n\n\n| Value | Description                 |\n| :---- | :-------------------------- |\n| 0     | Open Drain mode is disabled |\n| 1     | Open Drain mode is enabled  |\n\n"
                },
                {
                  "caption": "Reciever enable",
                  "mask": "0x80",
                  "name": "RXEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the USART receiver is enabled or not. Refer to 24.3.2.4.2  Disabling the Receiver for more\ninformation.\n\n\n| Value | Description                    |\n| :---- | :----------------------------- |\n| 0     | The USART receiver is disabled |\n| 1     | The USART receiver is enabled  |\n\n"
                },
                {
                  "caption": "Receiver Mode",
                  "mask": "0x6",
                  "name": "RXMODE",
                  "rw": "RW",
                  "values_ref": "USART_RXMODE",
                  "description": "Writing this bit field selects the receiver mode of the USART.\n* Writing the bits to 0x00 enables Normal-Speed (NORMAL) mode. When the USART Communication Mode\n(CMODE) bit field in the Control C (USARTn.CTRLC) register is configured to Asynchronous USART\n(ASYNCHRONOUS) or Infrared Communication (IRCOM), always write the RXMODE bit field to 0x00.\n* Writing the bits to 0x01 enables Double-Speed (CLK2X) mode. Refer to 24.3.3.2.4  Double-Speed Operation for\nmore information.\n* Writing the bits to 0x02 enables Generic Auto-Baud (GENAUTO) mode. Refer to the Auto-Baud section for\nmore information.\n* Writing the bits to 0x03 enables Lin Constrained Auto-Baud (LINAUTO) mode. Refer to the Auto-Baud section\nfor more information.\n\n\n| Value | Name    | Description                    |\n| :---- | :------ | :----------------------------- |\n| 0x00  | NORMAL  | Normal-Speed mode              |\n| 0x01  | CLK2X   | Double-Speed mode              |\n| 0x02  | GENAUTO | Generic Auto-Baud mode         |\n| 0x03  | LINAUTO | LIN Constrained Auto-Baud mode |\n\n"
                },
                {
                  "caption": "Start Frame Detection Enable",
                  "mask": "0x10",
                  "name": "SFDEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the USART Start-of-Frame Detection mode is enabled or not. Refer to 24.3.4.2  Start-of-\nFrame Detection for more information.\n\n\n| Value | Description                                         |\n| :---- | :-------------------------------------------------- |\n| 0     | The USART Start-of-Frame Detection mode is disabled |\n| 1     | The USART Start-of-Frame Detection mode is enabled  |\n\n"
                },
                {
                  "caption": "Transmitter Enable",
                  "mask": "0x40",
                  "name": "TXEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the USART transmitter is enabled or not. Refer to 24.3.2.3.1  Disabling the Transmitter for\nmore information.\n\n\n| Value | Description                       |\n| :---- | :-------------------------------- |\n| 0     | The USART transmitter is disabled |\n| 1     | The USART transmitter is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x03",
              "name": "CTRLC",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "CTRLC",
                  "caption": "USART Baud Rate Low Byte",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field holds the LSB of the 16-bit Baud register."
                }
              ],
              "description": "This register description is valid for all modes except the Host SPI mode. When the USART Communication Mode\n(CMODE) bit field in this register is written to 'MSPI', see CTRLC - Host SPI mode for the correct description."
            },
            {
              "caption": "Debug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0xB",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Event Control",
              "reset": "0x00",
              "name": "EVCTRL",
              "offset": "0xC",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "IrDA Event Input Enable",
                  "mask": "0x1",
                  "name": "IREI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the IrDA event input is enabled or not. See 24.3.3.2.7  IRCOM Mode of Operation for more\ninformation.\n\n\n| Value | Description                  |\n| :---- | :--------------------------- |\n| 0     | IrDA Event input is enabled  |\n| 1     | IrDA Event input is disabled |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Receive Data High Byte",
              "reset": "0x00",
              "name": "RXDATAH",
              "offset": "0x1",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Buffer Overflow",
                  "mask": "0x40",
                  "name": "BUFOVF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set if a buffer overflow is detected. A buffer overflow occurs when the receive buffer is full, a new frame is\nwaiting in the receive shift register, and a new Start bit is detected. This flag is cleared when the Receiver Data\n(USARTn.RXDATAL and USARTn.RXDATAH) registers are read.\nThis flag is not used in the Host SPI mode of operation."
                },
                {
                  "caption": "Receiver Data Register",
                  "mask": "0x1",
                  "name": "DATA8",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When using a 9-bit frame size, this bit holds the ninth bit (MSb) of the received data.\nWhen the Receiver Mode (RXMODE) bit field in the Control B (USARTn.CTRLB) register is configured to LIN\nConstrained Auto-Baud (LINAUTO) mode, this bit indicates if the received data are within the response space of a\nLIN frame. This bit is cleared if the received data are in the protected identifier field and is otherwise set."
                },
                {
                  "caption": "Frame Error",
                  "mask": "0x4",
                  "name": "FERR",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set if the first Stop bit is '0' and cleared when it is correctly read as '1'.\nThis flag is not used in the Host SPI mode of operation."
                },
                {
                  "caption": "Parity Error",
                  "mask": "0x2",
                  "name": "PERR",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set if parity checking is enabled and the received data has a parity error, or else, this flag cleared. For\ndetails on parity calculation, refer to 24.3.4.1  Parity.\nThis flag is not used in the Host SPI mode of operation."
                },
                {
                  "caption": "Receive Complete Interrupt Flag",
                  "mask": "0x80",
                  "name": "RXCIF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when there are unread data in the receive buffer and cleared when the receive buffer is empty."
                }
              ],
              "description": "This register contains the MSb of the data received by the USART receiver, as well as status bits reflecting the status\nof the received data frame. The USART receiver is double-buffered, and this register always represents the data and\nstatus bits for the oldest received frame. If the data and status bits for only one frame is present in the receive buffer,\nthis register contains that data.\nThe buffer shifts out the data either when RXDATAL or RXDATAH is read, depending on the configuration. The\nregister, which does not lead to data being shifted, must be read first to be able to read both bytes before shifting.\nWhen the Character Size (CHSIZE) bits in the Control C (USARTn.CTRLC) register is configured to 9-bit (low byte\nfirst), a read of RXDATAH shifts the receive buffer, or else, RXDATAL shifts the buffer."
            },
            {
              "caption": "Receive Data Low Byte",
              "reset": "0x00",
              "name": "RXDATAL",
              "offset": "0x0",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "RX Data",
                  "mask": "0xff",
                  "name": "DATA",
                  "rw": "R",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "This register contains the eight LSbs of the data received by the USART receiver. The USART receiver is double-\nbuffered, and this register always represents the data for the oldest received frame. If the data for only one frame is\npresent in the receive buffer, this register contains that data.\nThe buffer shifts out the data either when RXDATAL or RXDATAH is read, depending on the configuration. The\nregister, which does not lead to data being shifted, must be read first to be able to read both bytes before shifting.\nWhen the Character Size (CHSIZE) bit field in the Control C (USARTn.CTRLC) register is configured to 9-bit (low\nbyte first), a read of RXDATAH shifts the receive buffer, or else, RXDATAL shifts the buffer."
            },
            {
              "caption": "IRCOM Receiver Pulse Length Control",
              "reset": "0x00",
              "name": "RXPLCTRL",
              "offset": "0xE",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Receiver Pulse Lenght",
                  "mask": "0x7f",
                  "name": "RXPL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This 7-bit value sets the filter coefficient for the IRCOM transceiver. Setting this register will only have an effect if\nIRCOM mode is selected by a USART, and it must be configured before the USART receiver is enabled (RXEN).\n\n\n| Value | Description        |\n| :---- | :----------------- |\n| 0x00  | Filtering disabled |\n\n\n0x01-\n0x7F\nFiltering enabled. The value of RXPL+1 represents the number of samples required for a received\npulse to be accepted."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Break Detected Flag",
                  "mask": "0x2",
                  "name": "BDF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set if an auto-baud mode is enabled and a valid break and synchronization character is detected, and is\ncleared when the next data are received. It can also be cleared by writing a '1' to it. See the Auto-Baud section for\nmore information."
                },
                {
                  "caption": "Data Register Empty Flag",
                  "mask": "0x20",
                  "name": "DREIF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when the Transmit Data (USARTn.TXDATAL and USARTn.TXDATAH) registers are empty and\ncleared when they contain data that has not yet been moved into the transmit shift register."
                },
                {
                  "caption": "Inconsistent Sync Field Interrupt Flag",
                  "mask": "0x8",
                  "name": "ISFIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set if an auto-baud mode is enabled, and the synchronization field is too short or too long to give a valid\nbaud setting. It will also be set when USART is set to LINAUTO mode, and the SYNC character differs from data\nvalue 0x55. This flag is cleared by writing a '1' to it. See the Auto-Baud section for more information."
                },
                {
                  "caption": "Receive Complete Interrupt Flag",
                  "mask": "0x80",
                  "name": "RXCIF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when there are unread data in the receive buffer and cleared when the receive buffer is empty."
                },
                {
                  "caption": "Receive Start Interrupt",
                  "mask": "0x10",
                  "name": "RXSIF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when Start-of-Frame detection is enabled, the device is in Standby sleep mode, and a valid start bit is\ndetected. It is cleared by writing a '1' to it.\nThis flag is not used in the Host SPI mode operation."
                },
                {
                  "caption": "Transmit Interrupt Flag",
                  "mask": "0x40",
                  "name": "TXCIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when the entire frame in the Transmit Shift register has been shifted out, and there are no new data in\nthe transmit buffer (TXDATAL and TXDATAH) registers. It is cleared by writing a '1' to it."
                },
                {
                  "caption": "Wait For Break",
                  "mask": "0x1",
                  "name": "WFB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit controls whether the Wait For Break feature is enabled or not. Refer to the Auto-Baud section for more\ninformation.\n\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | Wait For Break is disabled |\n| 1     | Wait For Break is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Transmit Data High Byte",
              "reset": "0x00",
              "name": "TXDATAH",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Transmit Data Register (CHSIZE=9bit)",
                  "mask": "0x1",
                  "name": "DATA8",
                  "rw": "RW",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "The data written to this register is automatically loaded into the TX Buffer and through to the dedicated Shift register.\nThe shift register outputs each of the bits serially to the TXD pin.\nWhen using a 9-bit frame size, the ninth bit (MSb) must be written to the Transmit Data Register High Byte\n(USARTn.TXDATAH). In that case, the buffer shifts data either when the Transmit Data Register Low Byte\n(USARTn.TXDATAL) or the Transmit Data Register High Byte (USARTn.TXDATAH) is written, depending on the\nconfiguration. The register, which does not lead to data being shifted, must be written first to be able to write both\nregisters before shifting.\nWhen the Character Size (CHSIZE) bit field in the Control C (USARTn.CTRLC) register is configured to 9-bit (low\nbyte first), a write of the Transmit Data Register High Byte shifts the transmit buffer. Otherwise, the Transmit Data\nRegister Low Byte shifts the buffer.\nThis register may only be written when the Data Register Empty Interrupt Flag (DREIF) in the Status\n(USARTn.STATUS) register is set."
            },
            {
              "caption": "Transmit Data Low Byte",
              "reset": "0x00",
              "name": "TXDATAL",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Transmit Data Register",
                  "mask": "0xff",
                  "name": "DATA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "The data written to this register is automatically loaded into the TX Buffer and through to the dedicated Shift register.\nThe shift register outputs each of the bits serially to the TXD pin.\nWhen using a 9-bit frame size, the ninth bit (MSb) must be written to the Transmit Data Register High Byte\n(USARTn.TXDATAH). In that case, the buffer shifts data either when the Transmit Data Register Low Byte\n(USARTn.TXDATAL) or the Transmit Data Register High Byte (USARTn.TXDATAH) is written, depending on the\nconfiguration. The register, which does not lead to data being shifted, must be written first to be able to write both\nregisters before shifting.\nWhen the Character Size (CHSIZE) bit field in the Control C (USARTn.CTRLC) register is configured to 9-bit (low\nbyte first), a write of the Transmit Data Register High Byte shifts the transmit buffer. Otherwise, the Transmit Data\nRegister Low Byte shifts the buffer.\nThis register may only be written when the Data Register Empty Interrupt Flag (DREIF) in the Status\n(USARTn.STATUS) register is set."
            },
            {
              "caption": "IRCOM Transmitter Pulse Length Control",
              "reset": "0x00",
              "name": "TXPLCTRL",
              "offset": "0xD",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Transmit pulse length",
                  "mask": "0xff",
                  "name": "TXPL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This 8-bit value sets the pulse modulation scheme for the transmitter. Setting this register will only have an effect if\nIRCOM mode is selected by the USART, and it must be configured before the USART transmitter is enabled (TXEN).\n\n\n| Value | Description                                           |\n| :---- | :---------------------------------------------------- |\n| 0x00  | 3/16 of the baud rate period pulse modulation is used |\n\n\n0x01-\n0xFE\nFixed pulse length coding is used. The 8-bit value sets the number of peripheral clock periods for the\npulse. The start of the pulse will be synchronized with the rising edge of the baud rate clock.\n0xFF Pulse coding disabled. RX and TX signals pass through the IRCOM module unaltered. This enables\nother features through the IRCOM module, such as half-duplex USART, loop-back testing, and USART\nRX input from an event channel."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "User Row",
      "id": "I2600",
      "name": "USERROW",
      "register_groups": [
        {
          "caption": "User Row",
          "name": "USERROW",
          "size": "0x20",
          "registers": [
            {
              "caption": "User Row Byte 0",
              "reset": null,
              "name": "USERROW0",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 1",
              "reset": null,
              "name": "USERROW1",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 2",
              "reset": null,
              "name": "USERROW2",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 3",
              "reset": null,
              "name": "USERROW3",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 4",
              "reset": null,
              "name": "USERROW4",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 5",
              "reset": null,
              "name": "USERROW5",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 6",
              "reset": null,
              "name": "USERROW6",
              "offset": "0x06",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 7",
              "reset": null,
              "name": "USERROW7",
              "offset": "0x07",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 8",
              "reset": null,
              "name": "USERROW8",
              "offset": "0x08",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 9",
              "reset": null,
              "name": "USERROW9",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 10",
              "reset": null,
              "name": "USERROW10",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 11",
              "reset": null,
              "name": "USERROW11",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 12",
              "reset": null,
              "name": "USERROW12",
              "offset": "0x0C",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 13",
              "reset": null,
              "name": "USERROW13",
              "offset": "0x0D",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 14",
              "reset": null,
              "name": "USERROW14",
              "offset": "0x0E",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 15",
              "reset": null,
              "name": "USERROW15",
              "offset": "0x0F",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 16",
              "reset": null,
              "name": "USERROW16",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 17",
              "reset": null,
              "name": "USERROW17",
              "offset": "0x11",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 18",
              "reset": null,
              "name": "USERROW18",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 19",
              "reset": null,
              "name": "USERROW19",
              "offset": "0x13",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 20",
              "reset": null,
              "name": "USERROW20",
              "offset": "0x14",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 21",
              "reset": null,
              "name": "USERROW21",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 22",
              "reset": null,
              "name": "USERROW22",
              "offset": "0x16",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 23",
              "reset": null,
              "name": "USERROW23",
              "offset": "0x17",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 24",
              "reset": null,
              "name": "USERROW24",
              "offset": "0x18",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 25",
              "reset": null,
              "name": "USERROW25",
              "offset": "0x19",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 26",
              "reset": null,
              "name": "USERROW26",
              "offset": "0x1A",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 27",
              "reset": null,
              "name": "USERROW27",
              "offset": "0x1B",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 28",
              "reset": null,
              "name": "USERROW28",
              "offset": "0x1C",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 29",
              "reset": null,
              "name": "USERROW29",
              "offset": "0x1D",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 30",
              "reset": null,
              "name": "USERROW30",
              "offset": "0x1E",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 31",
              "reset": null,
              "name": "USERROW31",
              "offset": "0x1F",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            }
          ]
        }
      ]
    },
    {
      "caption": "Virtual Ports",
      "id": "I2103",
      "name": "VPORT",
      "register_groups": [
        {
          "caption": "Virtual Ports",
          "name": "VPORT",
          "size": "0x4",
          "registers": [
            {
              "caption": "Data Direction",
              "reset": null,
              "name": "DIR",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "DIR",
                  "caption": "Data Direction",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver for each PORTx pin.\nThis bit field does not control the digital input buffer. The digital input buffer for pin n (Pxn) can be configured in the\nInput/Sense Configuration (ISC) bit field in the Pin n Control (PORTx.PINnCTRL) register.\nThe available configuration for each bit n in this bit field is shown in the table below.\n\n\n| Value | Description                                                               |\n| :---- | :------------------------------------------------------------------------ |\n| 0     | Pxn is configured as an input-only pin, and the output driver is disabled |\n| 1     | Pxn is configured as an output pin, and the output driver is enabled      |\n\n"
                }
              ],
              "description": "Access to the Virtual PORT registers has the same outcome as access to the regular registers but allows for memory\nspecific instructions, such as bit manipulation instructions, which cannot be used in the extended I/O Register space\nwhere the regular PORT registers reside."
            },
            {
              "caption": "Input Value",
              "reset": null,
              "name": "IN",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "IN",
                  "caption": "Input Value",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field shows the state of the PORTx pins when the digital input buffer is enabled.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will toggle the corresponding bit in PORTx.OUT.\nIf the digital input buffer is disabled, the input is not sampled, and the bit value will not change. The digital input buffer\nfor pin n (Pxn) can be configured in the Input/Sense Configuration (ISC) bit field in the Pin n Control\n(PORTx.PINnCTRL) register.\nThe available states of each bit n in this bit field is shown in the table below.\n\n\n| Value | Description                      |\n| :---- | :------------------------------- |\n| 0     | The voltage level on Pxn is low  |\n| 1     | The voltage level on Pxn is high |\n\n"
                }
              ],
              "description": "Access to the Virtual PORT registers has the same outcome as access to the regular registers but allows for memory\nspecific instructions, such as bit manipulation instructions, which cannot be used in the extended I/O Register space\nwhere the regular PORT registers reside."
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Pin Interrupt",
                  "mask": "0xff",
                  "name": "INT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Pin interrupt flag n is cleared by writing a '1' to it.\nPin interrupt flag n is set when the change or state of pin n (Pxn) matches the pin's Input/Sense Configuration (ISC)\nin PORTx.PINnCTRL.\nWriting a '0' to bit n in this bit field has no effect.\nWriting a '1' to bit n in this bit field will clear Pin interrupt flag n."
                }
              ],
              "description": "Access to the Virtual PORT registers has the same outcome as access to the regular registers but allows for memory\nspecific instructions, such as bit manipulation instructions, which cannot be used in the extended I/O Register space\nwhere the regular PORT registers reside."
            },
            {
              "caption": "Output Value",
              "reset": null,
              "name": "OUT",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "name": "OUT",
                  "caption": "Output Value",
                  "mask": "0xff",
                  "rw": "unknown",
                  "values_ref": null,
                  "description": "This bit field controls the output driver level for each PORTx pin.\nThis configuration only has an effect when the output driver (PORTx.DIR) is enabled for the corresponding pin.\nThe available configuration for each bit n in this bit field is shown in the table below.\n\n\n| Value | Description                          |\n| :---- | :----------------------------------- |\n| 0     | The pin n (Pxn) output is driven low |\n| 1     | The Pxn output is driven high        |\n\n"
                }
              ],
              "description": "Access to the Virtual PORT registers has the same outcome as access to the regular registers but allows for memory\nspecific instructions, such as bit manipulation instructions, which cannot be used in the extended I/O Register space\nwhere the regular PORT registers reside."
            }
          ]
        }
      ]
    },
    {
      "caption": "Voltage reference",
      "id": "I2600",
      "name": "VREF",
      "register_groups": [
        {
          "caption": "Voltage reference",
          "name": "VREF",
          "size": "0x2",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "ADC0 reference select",
                  "mask": "0x70",
                  "name": "ADC0REFSEL",
                  "rw": "RW",
                  "values_ref": "VREF_ADC0REFSEL",
                  "description": "This bit field selects the reference voltage for the ADC0.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | 0.55V       |\n| 0x1   | 1.1V        |\n| 0x2   | 2.5V        |\n| 0x3   | 4.3V        |\n| 0x4   | 1.5V        |\n| other | Reserved    |\n\n"
                },
                {
                  "caption": "DAC0/AC0 reference select",
                  "mask": "0x7",
                  "name": "DAC0REFSEL",
                  "rw": "RW",
                  "values_ref": "VREF_DAC0REFSEL",
                  "description": "This bit field selects the reference voltage for DAC0 and AC0.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | 0.55V       |\n| 0x1   | 1.1V        |\n| 0x2   | 2.5V        |\n| 0x3   | 4.3V        |\n| 0x4   | 1.5V        |\n| other | Reserved    |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "ADC0 reference enable",
                  "mask": "0x2",
                  "name": "ADC0REFEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit forces the voltage reference for the ADC0 to be running, even if it is not requested.\nWriting a '0' to this bit allows automatic enable/disable of the reference source by the peripheral."
                },
                {
                  "caption": "DAC0/AC0 reference enable",
                  "mask": "0x1",
                  "name": "DAC0REFEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit forces the voltage reference for the DAC0 and AC0 to be running, even if it is not requested.\nWriting a '0' to this bit allows automatic enable/disable of the reference source by the peripheral."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Watch-Dog Timer",
      "id": "I2127",
      "name": "WDT",
      "register_groups": [
        {
          "caption": "Watch-Dog Timer",
          "name": "WDT",
          "size": "0x2",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Period",
                  "mask": "0xf",
                  "name": "PERIOD",
                  "rw": "RW",
                  "values_ref": "WDT_PERIOD",
                  "description": "Writing a non-zero value to this bit enables the WDT, and selects the time-out period in Normal mode accordingly. In\nWindow mode, these bits select the duration of the open window.\nThe bits are optionally lock-protected:\n* If LOCK in WDT.STATUS is '1', all bits are change-protected (Access = R)\n* If LOCK in WDT.STATUS is '0', all bits can be changed (Access = R/W)\n\n\n| Value | Name   | Description |\n| :---- | :----- | :---------- |\n| 0x0   | OFF    | -           |\n| 0x1   | 8CLK   | 0.008s      |\n| 0x2   | 16CLK  | 0.016s      |\n| 0x3   | 32CLK  | 0.031s      |\n| 0x4   | 64CLK  | 0.063s      |\n| 0x5   | 128CLK | 0.125s      |\n| 0x6   | 256CLK | 0.25s       |\n| 0x7   | 512CLK | 0.5s        |\n| 0x8   | 1KCLK  | 1s          |\n| 0x9   | 2KCLK  | 2s          |\n| 0xA   | 4KCLK  | 4s          |\n| 0xB   | 8KCLK  | 8s          |\n| other | -      | Reserved    |\n\n"
                },
                {
                  "caption": "Window",
                  "mask": "0xf0",
                  "name": "WINDOW",
                  "rw": "RW",
                  "values_ref": "WDT_WINDOW",
                  "description": "Writing a non-zero value to these bits enables the Window mode, and selects the duration of the closed period\naccordingly.\nThe bits are optionally lock-protected:\n* If LOCK bit in WDT.STATUS is '1', all bits are change-protected (Access = R)\n* If LOCK bit in WDT.STATUS is '0', all bits can be changed (Access = R/W)\n\n\n| Value | Name   | Description |\n| :---- | :----- | :---------- |\n| 0x0   | OFF    | -           |\n| 0x1   | 8CLK   | 0.008s      |\n| 0x2   | 16CLK  | 0.016s      |\n| 0x3   | 32CLK  | 0.031s      |\n| 0x4   | 64CLK  | 0.063s      |\n| 0x5   | 128CLK | 0.125s      |\n| 0x6   | 256CLK | 0.25s       |\n| 0x7   | 512CLK | 0.5s        |\n| 0x8   | 1KCLK  | 1s          |\n| 0x9   | 2KCLK  | 2s          |\n| 0xA   | 4KCLK  | 4s          |\n| 0xB   | 8KCLK  | 8s          |\n| other | -      | Reserved    |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Lock enable",
                  "mask": "0x80",
                  "name": "LOCK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' write-protects the WDT.CTRLA register.\nIt is only possible to write this bit to '1'. This bit can be cleared in Debug mode only.\nIf the PERIOD bits in WDT.CTRLA are different from zero after boot code, the lock will be automatically set.\nThis bit is under CCP."
                },
                {
                  "caption": "Syncronization busy",
                  "mask": "0x1",
                  "name": "SYNCBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is set after writing to the WDT.CTRLA register, while the data is being synchronized from the system clock\ndomain to the WDT clock domain.\nThis bit is cleared by the system after the synchronization is finished.\nThis bit is not under CCP."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "id": "UPDI",
      "caption": "Unified Program and Debug Interface",
      "name": "UPDI",
      "register_groups": [
        {
          "caption": "Unified Program and Debug Interface",
          "name": "UPDI",
          "size": "0x0D",
          "registers": [
            {
              "caption": "Status A",
              "reset": "0x20",
              "name": "STATUSA",
              "offset": "0x0",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "UPDI Revision",
                  "mask": "0xf0",
                  "name": "UPDIREV",
                  "rw": "R",
                  "description": "This bit field contains the revision of the current UPDI implementation."
                }
              ],
              "description": null
            },
            {
              "caption": "Status B",
              "reset": "0x00",
              "name": "STATUSB",
              "offset": "0x1",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "UPDI Error Signature",
                  "mask": "0x7",
                  "name": "PESIG",
                  "rw": "R",
                  "description": "This bit field describes the UPDI error signature and is set when an internal UPDI Error condition occurs. The PESIG\nbit field is cleared on a read from the debugger.\nTable 33-7. Valid Error Signatures\nPESIG[2:0] Error Type Error Description\n0x0 No error No error detected (Default)\n0x1 Parity error Wrong sampling of the Parity bit\n0x2 Frame error Wrong sampling of the Stop bits\n0x3 Access Layer Time-Out Error UPDI can get no data or response from the Access layer\n0x4 Clock Recovery error Wrong sampling of the Start bit\n0x5 - Reserved\n0x6 Bus error Address error or access privilege error\n0x7 Contention error Signalize Driving Contention on the UPDI pin"
                }
              ],
              "description": null
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inter-Byte Delay Enable",
                  "mask": "0x80",
                  "name": "IBDLY",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit enables a fixed-length inter-byte delay between each data byte transmitted from the UPDI\nwhen doing multibyte LD(S). The fixed length is two IDLE bits."
                },
                {
                  "caption": "Parity Disable",
                  "mask": "0x20",
                  "name": "PARD",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit will disable the parity detection in the UPDI by ignoring the Parity bit. This feature is\nrecommended to be used only during testing."
                },
                {
                  "caption": "Disable Time-Out Detection",
                  "mask": "0x10",
                  "name": "DTD",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit will disable the time-out detection on the PHY layer, which requests a response from the ACC\nlayer within a specified time (65536 UPDI clock cycles)."
                },
                {
                  "caption": "Response Signature Disable",
                  "mask": "0x8",
                  "name": "RSD",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit will disable any response signatures generated by the UPDI. This reduces the protocol\noverhead to a minimum when writing large blocks of data to the NVM space. When accessing the system bus, the\nUPDI may experience delays. If the delay is predictable, the response signature may be disabled. Otherwise, a loss\nof data may occur."
                },
                {
                  "caption": "Guard Time Value",
                  "mask": "0x7",
                  "name": "GTVAL",
                  "rw": "RW",
                  "description": "This bit field selects the guard time value that will be used by the UPDI when the transmission direction switches from\nRX to TX.\n\n\n| Value | Description                           |\n| :---- | :------------------------------------ |\n| 0x0   | UPDI guard time: 128 cycles (default) |\n| 0x1   | UPDI guard time: 64 cycles            |\n| 0x2   | UPDI guard time: 32 cycles            |\n| 0x3   | UPDI guard time: 16 cycles            |\n| 0x4   | UPDI guard time: 8 cycles             |\n| 0x5   | UPDI guard time: 4 cycles             |\n| 0x6   | UPDI guard time: 2 cycles             |\n| 0x7   | Reserved                              |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Disable Nack Response",
                  "mask": "0x10",
                  "name": "NACKDIS",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit disables the NACK signature sent by the UPDI when a System Reset is issued during ongoing\nLD(S) and ST(S) operations."
                },
                {
                  "caption": "Collision and Contention Detection Disable",
                  "mask": "0x8",
                  "name": "CCDETDIS",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit disables the contention detection. Writing a '0' to this bit enables the contention detection."
                },
                {
                  "caption": "UPDI Disalbe",
                  "mask": "0x4",
                  "name": "UPDIDIS",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit disables the UPDI PHY interface. The clock request from the UPDI is lowered, and the UPDI is\nreset. All the UPDI PHY configurations and keys will be reset when the UPDI is disabled."
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Disable Nack Response",
                  "mask": "0x10",
                  "name": "NACKDIS",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit disables the NACK signature sent by the UPDI when a System Reset is issued during ongoing\nLD(S) and ST(S) operations."
                },
                {
                  "caption": "Collision and Contention Detection Disable",
                  "mask": "0x8",
                  "name": "CCDETDIS",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit disables the contention detection. Writing a '0' to this bit enables the contention detection."
                },
                {
                  "caption": "UPDI Disable",
                  "mask": "0x4",
                  "name": "UPDIDIS",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit disables the UPDI PHY interface. The clock request from the UPDI is lowered, and the UPDI is\nreset. All the UPDI PHY configurations and keys will be reset when the UPDI is disabled."
                }
              ],
              "description": null
            },
            {
              "caption": "ASI Key Status",
              "reset": "0x00",
              "name": "ASI_KEY_STATUS",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "User Row Write Key Status",
                  "mask": "0x20",
                  "name": "UROWWRITE",
                  "rw": "RW",
                  "description": "This bit is set to '1' if the UROWWRITE key is successfully decoded. This bit must be written as the final part of the\nuser row write procedure to correctly reset the programming session."
                },
                {
                  "caption": "NVM Programming Key Status",
                  "mask": "0x10",
                  "name": "NVMPROG",
                  "rw": "R",
                  "description": "This bit is set to '1' if the NVMPROG key is successfully decoded. The bit is cleared when the NVM Programming\nsequence is initiated, and the NVMPROG bit in ASI_SYS_STATUS is set."
                },
                {
                  "caption": "Chip Erase Key Status",
                  "mask": "0x8",
                  "name": "CHIPERASE",
                  "rw": "R",
                  "description": "This bit is set to '1' if the Chip Erase key is successfully decoded. The bit is cleared by the Reset Request issued as\npart of the Chip Erase sequence described in the Chip Erase section."
                }
              ],
              "description": null
            },
            {
              "caption": "ASI Reset Request",
              "reset": "0x00",
              "name": "ASI_RESET_REQ",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Reset Request",
                  "mask": "0xff",
                  "name": "RSTREQ",
                  "rw": "RW",
                  "description": "The UPDI will not be reset when issuing a System Reset from this register.\n\n\n| Value | Name  | Description           |\n| :---- | :---- | :-------------------- |\n| 0x00  | RUN   | Clear Reset condition |\n| 0x59  | RESET | Normal Reset          |\n| Other | -     | Reserved              |\n\n"
                }
              ],
              "description": "A Reset is signalized to the System when writing the Reset signature to this register."
            },
            {
              "caption": "ASI Control A",
              "reset": "0x03",
              "name": "ASI_CTRLA",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "UPDI Clock Divider Select",
                  "mask": "0x3",
                  "name": "UPDICLKSEL",
                  "rw": "RW",
                  "description": "Writing these bits selects the UPDI clock output frequency. The default setting after Reset and enable is 4 MHz. Any\nother clock output selection is only recommended when the BOD is at the highest level. For all other BOD settings,\nthe default 4 MHz selection is recommended.\n\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0x0   | Reserved                           |\n| 0x1   | 16 MHz UPDI clock                  |\n| 0x2   | 8 MHz UPDI clock                   |\n| 0x3   | 4 MHz UPDI clock (Default Setting) |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "ASI System Control A",
              "reset": "0x00",
              "name": "ASI_SYS_CTRLA",
              "offset": "0xA",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "User Row Programming Done",
                  "mask": "0x2",
                  "name": "UROWWRITE_FINAL",
                  "rw": "RW",
                  "description": "This bit must be written when the user row data have been written to the RAM. Writing a '1' to this bit will start the\nprocess of programming the user row data to the Flash.\nIf this bit is written before the user row data is written to the RAM by the UPDI, the CPU will proceed without the\nwritten data.\nThis bit is writable only if the USERROW-Write key is successfully decoded."
                },
                {
                  "caption": "Request System Clock",
                  "mask": "0x1",
                  "name": "CLKREQ",
                  "rw": "RW",
                  "description": "If this bit is written to '1', the ASI is requesting the system clock, independent of the system sleep modes. This makes\nit possible for the UPDI to access the ACC layer, also if the system is in a sleep mode.\nWriting a '0' to this bit will lower the clock request.\nThis bit will be reset when the UPDI is disabled.\nThis bit is set by default when the UPDI is enabled in any programming mode (Fuse, high-voltage)."
                }
              ],
              "description": null
            },
            {
              "caption": " ASI System Status",
              "reset": "0x01",
              "name": "ASI_SYS_STATUS",
              "offset": "0xb",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "System Reset Active",
                  "mask": "0x20",
                  "name": "RSTSYS",
                  "rw": "R",
                  "description": "When this bit is set to '1', there is an active Reset on the system domain. When this bit is set to '0', the system is not\nin the Reset state.\nThis bit is set to '0' on read.\nA Reset held from the ASI_RESET_REQ register will also affect this bit."
                },
                {
                  "caption": "System Domain in Sleep",
                  "mask": "0x10",
                  "name": "INSLEEP",
                  "rw": "R",
                  "description": "When this bit is set to '1', the system domain is in Idle or deeper Sleep mode. When this bit is set to '0', the system is\nnot in any sleep mode."
                },
                {
                  "caption": "Start NVM Programming",
                  "mask": "0x8",
                  "name": "NVMPROG",
                  "rw": "R",
                  "description": "When this bit is set to '1', NVM Programming can start from the UPDI.\nWhen the programming is complete, reset the system through the UPDI Reset register."
                },
                {
                  "caption": "Start User Row Programming",
                  "mask": "0x4",
                  "name": "UROWPROG",
                  "rw": "R",
                  "description": "When this bit is set to '1', User Row Programming can start from the UPDI.\nWhen the User Row data have been written to the RAM, the UROWDONE bit in the ASI_SYS_CTRLA register must\nbe written."
                },
                {
                  "caption": "NVM Lock Status",
                  "mask": "0x1",
                  "name": "LOCKSTATUS",
                  "rw": "R",
                  "description": "When this bit is set to '1', the device is locked. If a chip erase is done, and the lock bits are set to '0', this bit will be\nread as '0'."
                }
              ],
              "description": null
            },
            {
              "caption": "ASI CRC Status",
              "reset": "0x00",
              "name": "ASI_CRC_STATUS",
              "offset": "0xc",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CRC Execution Status",
                  "mask": "0x7",
                  "name": "CRC_STATUS",
                  "rw": "R",
                  "description": "This bit field signalizes the status of the CRC conversion. This bit field is one-hot encoded.\n\n\n| Value | Description                             |\n| :---- | :-------------------------------------- |\n| 0x0   | Not enabled                             |\n| 0x1   | CRC enabled, busy                       |\n| 0x2   | CRC enabled, done with OK signature     |\n| 0x4   | CRC enabled, done with FAILED signature |\n| Other | Reserved                                |\n\n"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    }
  ]
}