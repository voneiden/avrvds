{
  "variants": [
    {
      "order_code": "ATtiny202-SSFR",
      "package": "SOIC8",
      "pinout": "SOIC8",
      "speed_max": 20000000,
      "temp_max": 125,
      "temp_min": -40,
      "vcc_max": 5.5,
      "vcc_min": 1.8
    },
    {
      "order_code": "ATtiny202-SSNR",
      "package": "SOIC8",
      "pinout": "SOIC8",
      "speed_max": 20000000,
      "temp_max": 105,
      "temp_min": -40,
      "vcc_max": 5.5,
      "vcc_min": 1.8
    }
  ],
  "pinouts": [
    {
      "name": "SOIC8",
      "pins": [
        {
          "pad": "VDD",
          "position": 1
        },
        {
          "pad": "PA6",
          "position": 2
        },
        {
          "pad": "PA7",
          "position": 3
        },
        {
          "pad": "PA1",
          "position": 4
        },
        {
          "pad": "PA2",
          "position": 5
        },
        {
          "pad": "PA0",
          "position": 6
        },
        {
          "pad": "PA3",
          "position": 7
        },
        {
          "pad": "GND",
          "position": 8
        }
      ]
    }
  ],
  "devices": [
    {
      "name": "ATtiny202",
      "modules": [
        {
          "name": "AC",
          "instances": [
            {
              "name": "AC0",
              "signals": [
                {
                  "function": "AC0",
                  "group": "N",
                  "index": 0,
                  "pad": "PA6"
                },
                {
                  "function": "AC0",
                  "group": "OUT",
                  "index": null,
                  "pad": "PA3"
                },
                {
                  "function": "AC0",
                  "group": "P",
                  "index": 0,
                  "pad": "PA7"
                }
              ]
            }
          ]
        },
        {
          "name": "ADC",
          "instances": [
            {
              "name": "ADC0",
              "signals": [
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 6,
                  "pad": "PA6"
                },
                {
                  "function": "AIN0",
                  "group": "AIN",
                  "index": 7,
                  "pad": "PA7"
                }
              ]
            }
          ]
        },
        {
          "name": "BOD",
          "instances": [
            {
              "name": "BOD",
              "signals": null
            }
          ]
        },
        {
          "name": "CCL",
          "instances": [
            {
              "name": "CCL",
              "signals": [
                {
                  "function": "CCL",
                  "group": "LUT0_IN",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "CCL",
                  "group": "LUT0_IN",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "CCL",
                  "group": "LUT0_IN",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "CCL",
                  "group": "LUT1_OUT",
                  "index": 0,
                  "pad": "PA6"
                }
              ]
            }
          ]
        },
        {
          "name": "CLKCTRL",
          "instances": [
            {
              "name": "CLKCTRL",
              "signals": [
                {
                  "function": "CLKCTRL",
                  "group": "CLKI",
                  "index": null,
                  "pad": "PA3"
                }
              ]
            }
          ]
        },
        {
          "name": "CPU",
          "instances": [
            {
              "name": "CPU",
              "signals": [
                {
                  "function": "OTHER",
                  "group": "BREAK",
                  "index": null,
                  "pad": "PA1"
                }
              ]
            }
          ]
        },
        {
          "name": "CPUINT",
          "instances": [
            {
              "name": "CPUINT",
              "signals": null
            }
          ]
        },
        {
          "name": "CRCSCAN",
          "instances": [
            {
              "name": "CRCSCAN",
              "signals": null
            }
          ]
        },
        {
          "name": "EVSYS",
          "instances": [
            {
              "name": "EVSYS",
              "signals": [
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 6,
                  "pad": "PA6"
                },
                {
                  "function": "EVAINCH0",
                  "group": "EVAPA",
                  "index": 7,
                  "pad": "PA7"
                },
                {
                  "function": "EVSYS",
                  "group": "EVOUT",
                  "index": 0,
                  "pad": "PA2"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 6,
                  "pad": "PA6"
                },
                {
                  "function": "EVSINCH0",
                  "group": "EVSPA",
                  "index": 7,
                  "pad": "PA7"
                }
              ]
            }
          ]
        },
        {
          "name": "FUSE",
          "instances": [
            {
              "name": "FUSE",
              "signals": null
            }
          ]
        },
        {
          "name": "GPIO",
          "instances": [
            {
              "name": "GPIO",
              "signals": null
            }
          ]
        },
        {
          "name": "LOCKBIT",
          "instances": [
            {
              "name": "LOCKBIT",
              "signals": null
            }
          ]
        },
        {
          "name": "NVMCTRL",
          "instances": [
            {
              "name": "NVMCTRL",
              "signals": null
            }
          ]
        },
        {
          "name": "PORT",
          "instances": [
            {
              "name": "PORTA",
              "signals": [
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 0,
                  "pad": "PA0"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 3,
                  "pad": "PA3"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 6,
                  "pad": "PA6"
                },
                {
                  "function": "IOPORT",
                  "group": "PIN",
                  "index": 7,
                  "pad": "PA7"
                }
              ]
            }
          ]
        },
        {
          "name": "PORTMUX",
          "instances": [
            {
              "name": "PORTMUX",
              "signals": null
            }
          ]
        },
        {
          "name": "RSTCTRL",
          "instances": [
            {
              "name": "RSTCTRL",
              "signals": [
                {
                  "function": "OTHER",
                  "group": "RESET",
                  "index": null,
                  "pad": "PA0"
                }
              ]
            }
          ]
        },
        {
          "name": "RTC",
          "instances": [
            {
              "name": "RTC",
              "signals": null
            }
          ]
        },
        {
          "name": "SIGROW",
          "instances": [
            {
              "name": "SIGROW",
              "signals": null
            }
          ]
        },
        {
          "name": "SLPCTRL",
          "instances": [
            {
              "name": "SLPCTRL",
              "signals": null
            }
          ]
        },
        {
          "name": "SPI",
          "instances": [
            {
              "name": "SPI0",
              "signals": [
                {
                  "function": "SPI0_ALT",
                  "group": "MISO",
                  "index": null,
                  "pad": "PA7"
                },
                {
                  "function": "SPI0",
                  "group": "MISO",
                  "index": null,
                  "pad": "PA2"
                },
                {
                  "function": "SPI0_ALT",
                  "group": "MOSI",
                  "index": null,
                  "pad": "PA6"
                },
                {
                  "function": "SPI0",
                  "group": "MOSI",
                  "index": null,
                  "pad": "PA1"
                },
                {
                  "function": "SPI0",
                  "group": "SCK",
                  "index": null,
                  "pad": "PA3"
                },
                {
                  "function": "SPI0",
                  "group": "SS",
                  "index": null,
                  "pad": "PA0"
                }
              ]
            }
          ]
        },
        {
          "name": "SYSCFG",
          "instances": [
            {
              "name": "SYSCFG",
              "signals": [
                {
                  "function": "OTHER",
                  "group": "UPDI",
                  "index": null,
                  "pad": "PA0"
                }
              ]
            }
          ]
        },
        {
          "name": "TCA",
          "instances": [
            {
              "name": "TCA0",
              "signals": [
                {
                  "function": "TCA0_ALT",
                  "group": "WO",
                  "index": 0,
                  "pad": "PA7"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 0,
                  "pad": "PA3"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 1,
                  "pad": "PA1"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 2,
                  "pad": "PA2"
                },
                {
                  "function": "TCA0",
                  "group": "WO",
                  "index": 3,
                  "pad": "PA3"
                }
              ]
            }
          ]
        },
        {
          "name": "TCB",
          "instances": [
            {
              "name": "TCB0",
              "signals": [
                {
                  "function": "TCB0",
                  "group": "WO",
                  "index": null,
                  "pad": "PA6"
                }
              ]
            }
          ]
        },
        {
          "name": "TWI",
          "instances": [
            {
              "name": "TWI0",
              "signals": [
                {
                  "function": "TWI0",
                  "group": "SCL",
                  "index": null,
                  "pad": "PA2"
                },
                {
                  "function": "TWI0",
                  "group": "SDA",
                  "index": null,
                  "pad": "PA1"
                }
              ]
            }
          ]
        },
        {
          "name": "USART",
          "instances": [
            {
              "name": "USART0",
              "signals": [
                {
                  "function": "USART0_ALT",
                  "group": "RXD",
                  "index": null,
                  "pad": "PA2"
                },
                {
                  "function": "USART0",
                  "group": "RXD",
                  "index": null,
                  "pad": "PA7"
                },
                {
                  "function": "USART0_ALT",
                  "group": "TXD",
                  "index": null,
                  "pad": "PA1"
                },
                {
                  "function": "USART0",
                  "group": "TXD",
                  "index": null,
                  "pad": "PA6"
                },
                {
                  "function": "USART0",
                  "group": "XCK",
                  "index": null,
                  "pad": "PA3"
                },
                {
                  "function": "USART0",
                  "group": "XDIR",
                  "index": null,
                  "pad": "PA0"
                }
              ]
            }
          ]
        },
        {
          "name": "USERROW",
          "instances": [
            {
              "name": "USERROW",
              "signals": null
            }
          ]
        },
        {
          "name": "VPORT",
          "instances": [
            {
              "name": "VPORTA",
              "signals": null
            },
            {
              "name": "VPORTB",
              "signals": null
            },
            {
              "name": "VPORTC",
              "signals": null
            }
          ]
        },
        {
          "name": "VREF",
          "instances": [
            {
              "name": "VREF",
              "signals": null
            }
          ]
        },
        {
          "name": "WDT",
          "instances": [
            {
              "name": "WDT",
              "signals": null
            }
          ]
        }
      ]
    }
  ],
  "modules": [
    {
      "caption": "Analog Comparator",
      "id": "I2106",
      "name": "AC",
      "register_groups": [
        {
          "caption": "Analog Comparator",
          "name": "AC",
          "size": "0x8",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the AC."
                },
                {
                  "caption": "Hysteresis Mode",
                  "mask": "0x6",
                  "name": "HYSMODE",
                  "rw": "RW",
                  "values_ref": "AC_HYSMODE",
                  "description": "Writing these bits selects the Hysteresis mode for the AC input.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0x0   | OFF   | OFF         |\n| 0x1   | 10    | \u00b110 mV      |\n| 0x2   | 25    | \u00b125 mV      |\n| 0x3   | 50    | \u00b150 mV      |\n\n"
                },
                {
                  "caption": "Interrupt Mode",
                  "mask": "0x30",
                  "name": "INTMODE",
                  "rw": "RW",
                  "values_ref": "AC_INTMODE",
                  "description": "Writing to these bits selects what edges of the AC output triggers an interrupt request.\n\n\n| Value | Name     | Description                     |\n| :---- | :------- | :------------------------------ |\n| 0x0   | BOTHEDGE | Both negative and positive edge |\n| 0x1   | -        | Reserved                        |\n| 0x2   | NEGEDGE  | Negative edge                   |\n| 0x3   | POSEDGE  | Positive edge                   |\n\n"
                },
                {
                  "caption": "Output Buffer Enable",
                  "mask": "0x40",
                  "name": "OUTEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' makes the OUT signal available on the pin."
                },
                {
                  "caption": "Run in Standby Mode",
                  "mask": "0x80",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit allows the AC to continue operation in Standby Sleep mode. Since the clock is\nstopped, interrupts and status flags are not updated.\n\n\n| Value | Description                                               |\n| :---- | :-------------------------------------------------------- |\n| 0     | In Standby Sleep mode, the peripheral is halted           |\n| 1     | In Standby Sleep mode, the peripheral continues operation |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Analog Comparator 0 Interrupt Enable",
                  "mask": "0x1",
                  "name": "CMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables analog comparator interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Mux Control A",
              "reset": "0x00",
              "name": "MUXCTRLA",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Invert AC Output",
                  "mask": "0x80",
                  "name": "INVERT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables inversion of the output of the AC. This effectively inverts the input to all the\nperipherals connected to the signal, and affects the internal status signals."
                },
                {
                  "caption": "Negative Input MUX Selection",
                  "mask": "0x3",
                  "name": "MUXNEG",
                  "rw": "RW",
                  "values_ref": "AC_MUXNEG",
                  "description": "Writing to this bit field selects the input signal to the negative input of the AC.\n\n\n| Value | Name     | Description       |\n| :---- | :------- | :---------------- |\n| 0x0   | AINN0    | Negative Pin 0    |\n| 0x1   | Reserved | Reserved          |\n| 0x2   | VREF     | Voltage Reference |\n| 0x3   | Reserved | Reserved          |\n\n"
                },
                {
                  "caption": "Positive Input MUX Selection",
                  "mask": "0x18",
                  "name": "MUXPOS",
                  "rw": "RW",
                  "values_ref": "AC_MUXPOS",
                  "description": null
                }
              ],
              "description": "AC.MUXCTRLA controls analog comparator muxes"
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Analog Comparator Interrupt Flag",
                  "mask": "0x1",
                  "name": "CMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This is the interrupt flag for AC. Writing a '1' to this bit will clear the Interrupt Flag."
                },
                {
                  "caption": "Analog Comparator State",
                  "mask": "0x10",
                  "name": "STATE",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This shows the current status of the OUT signal from the AC. This will have a synchronizer delay to get\nupdated in the I/O register (three cycles)."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Analog to Digital Converter",
      "id": "I2132",
      "name": "ADC",
      "register_groups": [
        {
          "caption": "Analog to Digital Converter",
          "name": "ADC",
          "size": "0x18",
          "registers": [
            {
              "caption": "Calibration",
              "reset": "0x00",
              "name": "CALIB",
              "offset": "0x16",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Duty Cycle",
                  "mask": "0x1",
                  "name": "DUTYCYC",
                  "rw": "RW",
                  "values_ref": "ADC_DUTYCYC",
                  "description": "This bit determines the duty cycle of the ADC clock.\nADC\nclk\n> 1.5 MHz requires a minimum operating voltage of 2.7V\n\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0     | 50% Duty Cycle must be used if ADC |\n\n\nclk\n> 1.5 MHz\n1 25% Duty Cycle (high 25% and low 75%) must be used for ADC\nclk\n\u2264 1.5 MHz"
                }
              ],
              "description": null
            },
            {
              "caption": "Command",
              "reset": "0x00",
              "name": "COMMAND",
              "offset": "0x08",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Start Conversion Operation",
                  "mask": "0x1",
                  "name": "STCONV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit will start a single measurement. If in Free-Running mode this will start the first\nconversion. STCONV will read as '1' as long as a conversion is in progress. When the conversion is\ncomplete, this bit is automatically cleared."
                }
              ],
              "description": null
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "ADC Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description     |\n| :---- | :-------------- |\n| 0     | ADC is disabled |\n| 1     | ADC is enabled  |\n\n"
                },
                {
                  "caption": "ADC Freerun mode",
                  "mask": "0x2",
                  "name": "FREERUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit will enable the Free-Running mode for the data acquisition. The first conversion is\nstarted by writing COMMAND.STCONV bit high. In the Free-Running mode, a new conversion cycle is\nstarted immediately after or as soon as the previous conversion cycle has completed. This is signaled by\nINTFLAGS.RESRDY."
                },
                {
                  "caption": "ADC Resolution",
                  "mask": "0x4",
                  "name": "RESSEL",
                  "rw": "RW",
                  "values_ref": "ADC_RESSEL",
                  "description": "This bit selects the ADC resolution.\n\n\n| Value | Description                                                                                |\n| :---- | :----------------------------------------------------------------------------------------- |\n| 0     | Full 10-bit resolution. The 10-bit ADC results are accumulated or stored to the ADC Result |\n\n\nregister (ADC.RES).\n1 8-bit resolution. The conversion results are truncated to eight bits (MSBs) before they are\naccumulated or stored to the ADC Result register (ADC.RES). The two Least Significant bits\nare discarded."
                },
                {
                  "caption": "Run standby mode",
                  "mask": "0x80",
                  "name": "RUNSTBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit determines whether the ADC needs to run when the chip is in Standby Sleep mode."
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Accumulation Samples",
                  "mask": "0x7",
                  "name": "SAMPNUM",
                  "rw": "RW",
                  "values_ref": "ADC_SAMPNUM",
                  "description": "These bits select how many consecutive ADC sampling results are accumulated automatically. When this\nbit is written to a value greater than 0x0, the according number of consecutive ADC sampling results are\naccumulated into the ADC Result register (ADC.RES) in one complete conversion.\n\n\n| Value | Name  | Description             |\n| :---- | :---- | :---------------------- |\n| 0x0   | NONE  | No accumulation.        |\n| 0x1   | ACC2  | 2 results accumulated.  |\n| 0x2   | ACC4  | 4 results accumulated.  |\n| 0x3   | ACC8  | 8 results accumulated.  |\n| 0x4   | ACC16 | 16 results accumulated. |\n| 0x5   | ACC32 | 32 results accumulated. |\n| 0x6   | ACC64 | 64 results accumulated. |\n| 0x7   | -     | Reserved.               |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Pre-scaler",
                  "mask": "0x7",
                  "name": "PRESC",
                  "rw": "RW",
                  "values_ref": "ADC_PRESC",
                  "description": "These bits define the division factor from the peripheral clock (CLK_PER) to the ADC clock (CLK_ADC).\n\n\n| Value | Name   | Description            |\n| :---- | :----- | :--------------------- |\n| 0x0   | DIV2   | CLK_PER divided by 2   |\n| 0x1   | DIV4   | CLK_PER divided by 4   |\n| 0x2   | DIV8   | CLK_PER divided by 8   |\n| 0x3   | DIV16  | CLK_PER divided by 16  |\n| 0x4   | DIV32  | CLK_PER divided by 32  |\n| 0x5   | DIV64  | CLK_PER divided by 64  |\n| 0x6   | DIV128 | CLK_PER divided by 128 |\n| 0x7   | DIV256 | CLK_PER divided by 256 |\n\n"
                },
                {
                  "caption": "Reference Selection",
                  "mask": "0x30",
                  "name": "REFSEL",
                  "rw": "RW",
                  "values_ref": "ADC_REFSEL",
                  "description": "These bits select the voltage reference for the ADC.\n\n\n| Value | Name     | Description        |\n| :---- | :------- | :----------------- |\n| 0x0   | INTERNAL | Internal reference |\n| 0x1   | VDD      | V                  |\n\n\nDD\nOther - Reserved."
                },
                {
                  "caption": "Sample Capacitance Selection",
                  "mask": "0x40",
                  "name": "SAMPCAP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit selects the sample capacitance, and hence, the input impedance. The best value is dependent on\nthe reference voltage and the application's electrical properties.\n\n\n| Value | Description                                                                      |\n| :---- | :------------------------------------------------------------------------------- |\n| 0     | Recommended for reference voltage values below 1V.                               |\n| 1     | Reduced size of sampling capacitance. Recommended for higher reference voltages. |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Automatic Sampling Delay Variation",
                  "mask": "0x10",
                  "name": "ASDV",
                  "rw": "RW",
                  "values_ref": "ADC_ASDV",
                  "description": "Writing this bit to '1' enables automatic sampling delay variation between ADC conversions. The purpose\nof varying sampling instant is to randomize the sampling instant and thus avoid standing frequency\ncomponents in the frequency spectrum. The value of the SAMPDLY bits are automatically incremented by\none after each sample.\nWhen the Automatic Sampling Delay Variation is enabled and the SAMPDLY value reaches 0xF, it wraps\naround to 0x0.\n\n\n| Value | Name   | Description                                         |\n| :---- | :----- | :-------------------------------------------------- |\n| 0     | ASVOFF | The Automatic Sampling Delay Variation is disabled. |\n| 1     | ASVON  | The Automatic Sampling Delay Variation is enabled.  |\n\n"
                },
                {
                  "caption": "Initial Delay Selection",
                  "mask": "0xe0",
                  "name": "INITDLY",
                  "rw": "RW",
                  "values_ref": "ADC_INITDLY",
                  "description": "These bits define the initialization/start-up delay before the first sample when enabling the ADC or\nchanging to an internal reference voltage. Setting this delay will ensure that the reference, MUXes, etc.\nare ready before starting the first conversion. The initialization delay will also take place when waking up\nfrom deep sleep to do a measurement.\nThe delay is expressed as a number of CLK_ADC cycles.\n\n\n| Value | Name   | Description               |\n| :---- | :----- | :------------------------ |\n| 0x0   | DLY0   | Delay 0 CLK_ADC cycles.   |\n| 0x1   | DLY16  | Delay 16 CLK_ADC cycles.  |\n| 0x2   | DLY32  | Delay 32 CLK_ADC cycles.  |\n| 0x3   | DLY64  | Delay 64 CLK_ADC cycles.  |\n| 0x4   | DLY128 | Delay 128 CLK_ADC cycles. |\n| 0x5   | DLY256 | Delay 256 CLK_ADC cycles. |\n| Other | -      | Reserved                  |\n\n"
                },
                {
                  "caption": "Sampling Delay Selection",
                  "mask": "0xf",
                  "name": "SAMPDLY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "These bits define the delay between consecutive ADC samples. The programmable Sampling Delay\nallows modifying the sampling frequency during hardware accumulation, to suppress periodic noise\nsources that may otherwise disturb the sampling. The SAMPDLY field can be also modified automatically\nfrom one sampling cycle to another, by setting the ASDV bit. The delay is expressed as CLK_ADC cycles\nand is given directly by the bitfield setting. The sampling cap is kept open during the delay."
                }
              ],
              "description": null
            },
            {
              "caption": "Control E",
              "reset": "0x00",
              "name": "CTRLE",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Window Comparator Mode",
                  "mask": "0x7",
                  "name": "WINCM",
                  "rw": "RW",
                  "values_ref": "ADC_WINCM",
                  "description": "This field enables and defines when the interrupt flag is set in Window Comparator mode. RESULT is the\n16-bit accumulator result. WINLT and WINHT are 16-bit lower threshold value and 16-bit higher threshold\nvalue, respectively.\n\n\n| Value | Name    | Description                      |\n| :---- | :------ | :------------------------------- |\n| 0x0   | NONE    | No Window Comparison (default)   |\n| 0x1   | BELOW   | RESULT < WINLT                   |\n| 0x2   | ABOVE   | RESULT > WINHT                   |\n| 0x3   | INSIDE  | WINLT < RESULT < WINHT           |\n| 0x4   | OUTSIDE | RESULT < WINLT or RESULT >WINHT) |\n| Other | -       | Reserved                         |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Debug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x0C",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                     |\n| :---- | :------------------------------------------------------------------------------ |\n| 0     | The peripheral is halted in Break Debug mode and ignores events.                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted. |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Event Control",
              "reset": "0x00",
              "name": "EVCTRL",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Start Event Input Enable",
                  "mask": "0x1",
                  "name": "STARTEI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables event input as source for conversion start."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Result Ready Interrupt Enable",
                  "mask": "0x1",
                  "name": "RESRDY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables result ready interrupt."
                },
                {
                  "caption": "Window Comparator Interrupt Enable",
                  "mask": "0x2",
                  "name": "WCMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables window comparator interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Result Ready Flag",
                  "mask": "0x1",
                  "name": "RESRDY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The result ready interrupt flag is set when a measurement is complete and a new result is ready. The flag\nis cleared by either writing a '1' to the bit location or by reading the Result register (ADCn.RES). Writing a\n'0' to this bit has no effect."
                },
                {
                  "caption": "Window Comparator Flag",
                  "mask": "0x2",
                  "name": "WCMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This window comparator flag is set when the measurement is complete and if the result matches the\nselected Window Comparator mode defined by WINCM (ADCn.CTRLE). The comparison is done at the\nend of the conversion. The flag is cleared by either writing a '1' to the bit position or by reading the Result\nregister (ADCn.RES). Writing a '0' to this bit has no effect."
                }
              ],
              "description": null
            },
            {
              "caption": "Positive mux input",
              "reset": "0x00",
              "name": "MUXPOS",
              "offset": "0x06",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Analog Channel Selection Bits",
                  "mask": "0x1f",
                  "name": "MUXPOS",
                  "rw": "RW",
                  "values_ref": "ADC_MUXPOS",
                  "description": "This bit field selects which single-ended analog input is connected to the ADC. If these bits are changed\nduring a conversion, the change will not take effect until this conversion is complete.\n\n\n| Value | Name      | Description                               |\n| :---- | :-------- | :---------------------------------------- |\n| 0x00  | AIN0      | ADC input pin 0                           |\n| 0x01  | AIN1      | ADC input pin 1                           |\n| 0x02  | AIN2      | ADC input pin 2                           |\n| 0x03  | AIN3      | ADC input pin 3                           |\n| 0x04  | Reserved  | Reserved                                  |\n| 0x05  | Reserved  | Reserved                                  |\n| 0x06  | AIN6      | ADC input pin 6                           |\n| 0x07  | AIN7      | ADC input pin 7                           |\n| 0x08  | Reserved  | Reserved                                  |\n| 0x09  | Reserved  | Reserved                                  |\n| 0x0A  | Reserved  | Reserved                                  |\n| 0x0B  | Reserved  | Reserved                                  |\n| 0x1C  | Reserved  | Reserved                                  |\n| 0x1D  | INTREF    | Internal reference (from VREF peripheral) |\n| 0x1E  | TEMPSENSE | Temperature sensor                        |\n| 0x1F  | GND       | 0V (GND)                                  |\n| Other | -         | Reserved                                  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "ADC Accumulator Result",
              "reset": null,
              "name": "RES",
              "offset": "0x10",
              "rw": "R",
              "size": 2,
              "bitfields": null,
              "description": "The ADCn.RESL and ADCn.RESH register pair represent the 16-bit value, ADCn.RES. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset +\n0x01.\nIf the analog input is higher than the reference level of the ADC, the 10-bit ADC result will be equal the\nmaximum value of 0x3FF. Likewise, if the input is below 0V, the ADC result will be 0x000. As the ADC\ncannot produce a result above 0x3FF values, the accumulated value will never exceed 0xFFC0 even\nafter the maximum allowed 64 accumulations."
            },
            {
              "caption": "Sample Control",
              "reset": "0x00",
              "name": "SAMPCTRL",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Sample lenght",
                  "mask": "0x1f",
                  "name": "SAMPLEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "These bits extend the ADC sampling length in a number of CLK_ADC cycles. By default, the sampling\ntime is two CLK_ADC cycles. Increasing the sampling length allows sampling sources with higher\nimpedance. The total conversion time increases with the selected sampling length."
                }
              ],
              "description": null
            },
            {
              "caption": "Temporary Data",
              "reset": "0x00",
              "name": "TEMP",
              "offset": "0x0D",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Temporary",
                  "mask": "0xff",
                  "name": "TEMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Temporary register for read/write operations in 16-bit registers."
                }
              ],
              "description": "The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this\nperipheral. It can be read and written by software. There is one common Temporary register for all the 16-\nbit registers of this peripheral."
            },
            {
              "caption": "Window comparator high threshold",
              "reset": null,
              "name": "WINHT",
              "offset": "0x14",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register is the 16-bit high threshold for the digital comparator monitoring the ADCn.RES register. The\nADC itself has 10-bit output, RES[9:0], where the MSb is RES[9]. The data format in ADC and Digital\nAccumulation is one's complement, where 0x0000 represents the zero and 0xFFFF represents the\nlargest number (full scale).\nThe ADCn.WINHTH and ADCn.WINHTL register pair represents the 16-bit value, ADCn.WINHT. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at\noffset + 0x01."
            },
            {
              "caption": "Window comparator low threshold",
              "reset": null,
              "name": "WINLT",
              "offset": "0x12",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register is the 16-bit low threshold for the digital comparator monitoring the ADCn.RES register. The\nADC itself has 10-bit output, RES[9:0], where the MSb is RES[9]. The data format in ADC and Digital\nAccumulation is one's complement, where 0x0000 represents the zero and 0xFFFF represents the\nlargest number (full scale).\nThe ADCn.WINLTH and ADCn.WINLTL register pair represent the 16-bit value, ADCn.WINLT. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at\noffset + 0x01.\nWhen accumulating samples, the window comparator thresholds are applied on the accumulated value\nand not on each sample."
            }
          ]
        }
      ]
    },
    {
      "caption": "Bod interface",
      "id": "I2114",
      "name": "BOD",
      "register_groups": [
        {
          "caption": "Bod interface",
          "name": "BOD",
          "size": "0x10",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x05",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Operation in active mode",
                  "mask": "0xc",
                  "name": "ACTIVE",
                  "rw": "R",
                  "values_ref": "BOD_ACTIVE",
                  "description": "These bits select the BOD operation mode when the device is in Active or Idle mode.\nThe Reset value is loaded from the ACTIVE bits in FUSE.BODCFG.\n\n\n| Value | Description                                    |\n| :---- | :--------------------------------------------- |\n| 0x0   | Disabled                                       |\n| 0x1   | Enabled                                        |\n| 0x2   | Sampled                                        |\n| 0x3   | Enabled with wake-up halted until BOD is ready |\n\n"
                },
                {
                  "caption": "Sample frequency",
                  "mask": "0x10",
                  "name": "SAMPFREQ",
                  "rw": "R",
                  "values_ref": "BOD_SAMPFREQ",
                  "description": "This bit selects the BOD sample frequency.\nThe Reset value is loaded from the SAMPFREQ bit in FUSE.BODCFG. This bit is under Configuration\nChange Protection (CCP).\n\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0x0   | Sample frequency is 1 kHz  |\n| 0x1   | Sample frequency is 125 Hz |\n\n"
                },
                {
                  "caption": "Operation in sleep mode",
                  "mask": "0x3",
                  "name": "SLEEP",
                  "rw": "RW",
                  "values_ref": "BOD_SLEEP",
                  "description": "These bits select the BOD operation mode when the device is in Standby or Power-Down Sleep mode.\nThe Reset value is loaded from the SLEEP bits in FUSE.BODCFG.\nThese bits are under Configuration Change Protection (CCP).\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | Disabled    |\n| 0x1   | Enabled     |\n| 0x2   | Sampled     |\n| 0x3   | Reserved    |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Bod level",
                  "mask": "0x7",
                  "name": "LVL",
                  "rw": "R",
                  "values_ref": "BOD_LVL",
                  "description": "These bits select the BOD threshold level.\nThe Reset value is loaded from the BOD Level bits (LVL) in the BOD Configuration Fuse\n(FUSE.BODCFG).\n\n\n| Value | Name      | Description |\n| :---- | :-------- | :---------- |\n| 0x0   | BODLEVEL0 | 1.8V        |\n| 0x1   | BODLEVEL1 | 2.15V       |\n| 0x2   | BODLEVEL2 | 2.60V       |\n| 0x3   | BODLEVEL3 | 2.95V       |\n| 0x4   | BODLEVEL4 | 3.30V       |\n| 0x5   | BODLEVEL5 | 3.70V       |\n| 0x6   | BODLEVEL6 | 4.00V       |\n| 0x7   | BODLEVEL7 | 4.30V       |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Voltage level monitor interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Configuration",
                  "mask": "0x6",
                  "name": "VLMCFG",
                  "rw": "RW",
                  "values_ref": "BOD_VLMCFG",
                  "description": "These bits select which incidents will trigger a VLM interrupt.\n\n\n| Value | Description                                         |\n| :---- | :-------------------------------------------------- |\n| 0x0   | Voltage crosses VLM threshold from above            |\n| 0x1   | Voltage crosses VLM threshold from below            |\n| 0x2   | Either direction is triggering an interrupt request |\n| Other | Reserved                                            |\n\n"
                },
                {
                  "caption": "voltage level monitor interrrupt enable",
                  "mask": "0x1",
                  "name": "VLMIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the VLM interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Voltage level monitor interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0xA",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Voltage level monitor interrupt flag",
                  "mask": "0x1",
                  "name": "VLMIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when a trigger from the VLM is given, as configured by the VLMCFG bit in the\nBOD.INTCTRL register. The flag is only updated when the BOD is enabled."
                }
              ],
              "description": null
            },
            {
              "caption": "Voltage level monitor status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0xB",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Voltage level monitor status",
                  "mask": "0x1",
                  "name": "VLMS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is only valid when the BOD is enabled.\n\n\n| Value | Description                                  |\n| :---- | :------------------------------------------- |\n| 0     | The voltage is above the VLM threshold level |\n| 1     | The voltage is below the VLM threshold level |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Voltage level monitor Control",
              "reset": "0x00",
              "name": "VLMCTRLA",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "voltage level monitor level",
                  "mask": "0x3",
                  "name": "VLMLVL",
                  "rw": "RW",
                  "values_ref": "BOD_VLMLVL",
                  "description": "These bits select the VLM threshold relative to the BOD threshold (LVL in BOD.CTRLB).\n\n\n| Value | Description                           |\n| :---- | :------------------------------------ |\n| 0x0   | VLM threshold 5% above BOD threshold  |\n| 0x1   | VLM threshold 15% above BOD threshold |\n| 0x2   | VLM threshold 25% above BOD threshold |\n| other | Reserved                              |\n\n"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Configurable Custom Logic",
      "id": "I2128",
      "name": "CCL",
      "register_groups": [
        {
          "caption": "Configurable Custom Logic",
          "name": "CCL",
          "size": "0x10",
          "registers": [
            {
              "caption": "Control Register A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | The peripheral is disabled |\n| 1     | The peripheral is enabled  |\n\n"
                },
                {
                  "caption": "Run in Standby",
                  "mask": "0x40",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit indicates if the peripheral clock (CLK_PER) is kept running in Standby Sleep mode. The setting is\nignored for configurations where the CLK_PER is not required.\n\n\n| Value | Description                                        |\n| :---- | :------------------------------------------------- |\n| 0     | System clock is not required in Standby Sleep mode |\n| 1     | System clock is required in Standby Sleep mode     |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "LUT Control 0 A",
              "reset": "0x00",
              "name": "LUT0CTRLA",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Source Selection",
                  "mask": "0x40",
                  "name": "CLKSRC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Edge Detection Enable",
                  "mask": "0x80",
                  "name": "EDGEDET",
                  "rw": "RW",
                  "values_ref": "CCL_EDGEDET",
                  "description": null
                },
                {
                  "caption": "LUT Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Filter Selection",
                  "mask": "0x30",
                  "name": "FILTSEL",
                  "rw": "RW",
                  "values_ref": "CCL_FILTSEL",
                  "description": null
                },
                {
                  "caption": "Output Enable",
                  "mask": "0x8",
                  "name": "OUTEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "LUT Control 0 B",
              "reset": "0x00",
              "name": "LUT0CTRLB",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "LUT Input 0 Source Selection",
                  "mask": "0xf",
                  "name": "INSEL0",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL0",
                  "description": null
                },
                {
                  "caption": "LUT Input 1 Source Selection",
                  "mask": "0xf0",
                  "name": "INSEL1",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL1",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "LUT Control 0 C",
              "reset": "0x00",
              "name": "LUT0CTRLC",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "LUT Input 2 Source Selection",
                  "mask": "0xf",
                  "name": "INSEL2",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL2",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "LUT Control 1 A",
              "reset": "0x00",
              "name": "LUT1CTRLA",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Source Selection",
                  "mask": "0x40",
                  "name": "CLKSRC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Edge Detection Enable",
                  "mask": "0x80",
                  "name": "EDGEDET",
                  "rw": "RW",
                  "values_ref": "CCL_EDGEDET",
                  "description": null
                },
                {
                  "caption": "LUT Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Filter Selection",
                  "mask": "0x30",
                  "name": "FILTSEL",
                  "rw": "RW",
                  "values_ref": "CCL_FILTSEL",
                  "description": null
                },
                {
                  "caption": "Output Enable",
                  "mask": "0x8",
                  "name": "OUTEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "LUT Control 1 B",
              "reset": "0x00",
              "name": "LUT1CTRLB",
              "offset": "0xA",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "LUT Input 0 Source Selection",
                  "mask": "0xf",
                  "name": "INSEL0",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL0",
                  "description": null
                },
                {
                  "caption": "LUT Input 1 Source Selection",
                  "mask": "0xf0",
                  "name": "INSEL1",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL1",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "LUT Control 1 C",
              "reset": "0x00",
              "name": "LUT1CTRLC",
              "offset": "0xB",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "LUT Input 2 Source Selection",
                  "mask": "0xf",
                  "name": "INSEL2",
                  "rw": "RW",
                  "values_ref": "CCL_INSEL2",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Sequential Control 0",
              "reset": "0x00",
              "name": "SEQCTRL0",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Sequential Selection",
                  "mask": "0x7",
                  "name": "SEQSEL",
                  "rw": "RW",
                  "values_ref": "CCL_SEQSEL",
                  "description": "These bits select how many consecutive ADC sampling results are accumulated automatically. When this\nbit is written to a value greater than 0x0, the according number of consecutive ADC sampling results are\naccumulated into the ADC Result register (ADC.RES) in one complete conversion.\n\n\n| Value | Name  | Description             |\n| :---- | :---- | :---------------------- |\n| 0x0   | NONE  | No accumulation.        |\n| 0x1   | ACC2  | 2 results accumulated.  |\n| 0x2   | ACC4  | 4 results accumulated.  |\n| 0x3   | ACC8  | 8 results accumulated.  |\n| 0x4   | ACC16 | 16 results accumulated. |\n| 0x5   | ACC32 | 32 results accumulated. |\n| 0x6   | ACC64 | 64 results accumulated. |\n| 0x7   | -     | Reserved.               |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Truth 0",
              "reset": "0x00",
              "name": "TRUTH0",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Truth Table",
                  "mask": "0xff",
                  "name": "TRUTH",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Truth 1",
              "reset": "0x00",
              "name": "TRUTH1",
              "offset": "0xC",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Truth Table",
                  "mask": "0xff",
                  "name": "TRUTH",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            }
          ]
        }
      ]
    },
    {
      "caption": "Clock controller",
      "id": "I2601",
      "name": "CLKCTRL",
      "register_groups": [
        {
          "caption": "Clock controller",
          "name": "CLKCTRL",
          "size": "0x20",
          "registers": [
            {
              "caption": "MCLK Control A",
              "reset": "0x00",
              "name": "MCLKCTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "System clock out",
                  "mask": "0x80",
                  "name": "CLKOUT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description            |\n| :---- | :--------------------- |\n| 0     | EXTCLK has not started |\n| 1     | EXTCLK has started     |\n\n"
                },
                {
                  "caption": "clock select",
                  "mask": "0x3",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "CLKCTRL_CLKSEL",
                  "description": "This bit field selects the source for the Main Clock (CLK_MAIN).\n\n\n| Value | Name      | Description                                |\n| :---- | :-------- | :----------------------------------------- |\n| 0x0   | OSC20M    | 16/20 MHz internal oscillator              |\n| 0x1   | OSCULP32K | 32 KHz internal ultra low-power oscillator |\n| 0x2   | Reserved  | Reserved                                   |\n| 0x3   | EXTCLK    | External clock                             |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "MCLK Control B",
              "reset": "0x00",
              "name": "MCLKCTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Prescaler division",
                  "mask": "0x1e",
                  "name": "PDIV",
                  "rw": "RW",
                  "values_ref": "CLKCTRL_PDIV",
                  "description": "If the Prescaler Enable (PEN) bit is written to '1', these bits define the division ratio of the main clock\nprescaler.\nThese bits can be written during run-time to vary the clock frequency of the system to suit the application\nrequirements.\nUser software must ensure a correct configuration of input frequency (CLK_MAIN) and prescaler settings,\nsuch that the resulting frequency of CLK_PER never exceeds the allowed maximum (see Electrical\nCharacteristics).\n\n\n| Value | Description |\n| :---- | :---------- |\n| Value | Division    |\n| 0x0   | 2           |\n| 0x1   | 4           |\n| 0x2   | 8           |\n| 0x3   | 16          |\n| 0x4   | 32          |\n| 0x5   | 64          |\n| 0x8   | 6           |\n| 0x9   | 10          |\n| 0xA   | 12          |\n| 0xB   | 24          |\n| 0xC   | 48          |\n| other | Reserved    |\n\n"
                },
                {
                  "caption": "Prescaler enable",
                  "mask": "0x1",
                  "name": "PEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit must be written '1' to enable the prescaler. When enabled, the division ratio is selected by the\nPDIV bit field.\nWhen this bit is written to '0', the main clock will pass through undivided (CLK_PER=CLK_MAIN),\nregardless of the value of PDIV."
                }
              ],
              "description": null
            },
            {
              "caption": "MCLK Lock",
              "reset": null,
              "name": "MCLKLOCK",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "lock ebable",
                  "mask": "0x1",
                  "name": "LOCKEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' will lock the CLKCTRL.MCLKCTRLA and CLKCTRL.MCLKCTRLB registers, and, if\napplicable, the calibration settings for the current main clock source from further software updates. Once\nlocked, the CLKCTRL.MCLKLOCK registers cannot be accessed until the next hardware Reset.\nThis provides protection for the CLKCTRL.MCLKCTRLA and CLKCTRL.MCLKCTRLB registers and\ncalibration settings for the main clock source from unintentional modification by software.\nRelated Links\nConfiguration and User Fuses (FUSE)"
                }
              ],
              "description": null
            },
            {
              "caption": "MCLK Status",
              "reset": "0x00",
              "name": "MCLKSTATUS",
              "offset": "0x03",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "External Clock status",
                  "mask": "0x80",
                  "name": "EXTS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "\n\n| Value | Description            |\n| :---- | :--------------------- |\n| 0     | EXTCLK has not started |\n| 1     | EXTCLK has started     |\n\n"
                },
                {
                  "caption": "20MHz oscillator status",
                  "mask": "0x10",
                  "name": "OSC20MS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The Status bit will only be available if the source is requested as the main clock or by another module. If\nthe oscillator RUNSTDBY bit is set but the oscillator is unused/not requested, this bit will be 0.\n\n\n| Value | Description          |\n| :---- | :------------------- |\n| 0     | OSC20M is not stable |\n| 1     | OSC20M is stable     |\n\n"
                },
                {
                  "caption": "32KHz oscillator status",
                  "mask": "0x20",
                  "name": "OSC32KS",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The Status bit will only be available if the source is requested as the main clock or by another module. If\nthe oscillator RUNSTDBY bit is set but the oscillator is unused/not requested, this bit will be 0.\n\n\n| Value | Description             |\n| :---- | :---------------------- |\n| 0     | OSCULP32K is not stable |\n| 1     | OSCULP32K is stable     |\n\n"
                },
                {
                  "caption": "System Oscillator changing",
                  "mask": "0x1",
                  "name": "SOSC",
                  "rw": "R",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                              |\n| :---- | :--------------------------------------------------------------------------------------- |\n| 0     | The clock source for CLK_MAIN is not undergoing a switch                                 |\n| 1     | The clock source for CLK_MAIN is undergoing a switch, and will change as soon as the new |\n\n\nsource is stable."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC20M Calibration A",
              "reset": "0x00",
              "name": "OSC20MCALIBA",
              "offset": "0x11",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Calibration",
                  "mask": "0x3f",
                  "name": "CAL20M",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "These bits change the frequency around the current center frequency of the OSC20M for fine-tuning.\nAt Reset, the factory calibrated values are loaded based on the FREQSEL bits in FUSE.OSCCFG."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC20M Calibration B",
              "reset": "0x00",
              "name": "OSC20MCALIBB",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Lock",
                  "mask": "0x80",
                  "name": "LOCK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is set, the calibration settings in CLKCTRL.OSC20MCALIBA and\nCLKCTRL.OSC20MCALIBB cannot be changed.\nThe Reset, the value is loaded from the OSCLOCK bit in the Oscillator Configuration Fuse\n(FUSE.OSCCFG)."
                },
                {
                  "caption": "Oscillator temperature coefficient",
                  "mask": "0xf",
                  "name": "TEMPCAL20M",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "These bits tune the slope of the temperature compensation.\nAt Reset, the factory calibrated values are loaded based on the FREQSEL bits in FUSE.OSCCFG."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC20M Control A",
              "reset": null,
              "name": "OSC20MCTRLA",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run standby",
                  "mask": "0x2",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit forces the oscillator ON in all modes, even when unused by the system. In Standby Sleep mode\nthis can be used to ensure immediate wake-up and not waiting for oscillator start-up time.\nWhen not requested by peripherals, no oscillator output is provided.\nIt takes four oscillator cycles to open the clock gate after a request but the oscillator analog start-up time\nwill be removed when this bit is set."
                }
              ],
              "description": null
            },
            {
              "caption": "OSC32K Control A",
              "reset": "0x00",
              "name": "OSC32KCTRLA",
              "offset": "0x18",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run standby",
                  "mask": "0x2",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit forces the oscillator ON in all modes, even when unused by the system. In Standby Sleep mode\nthis can be used to ensure immediate wake-up and not waiting for the oscillator start-up time.\nWhen not requested by peripherals, no oscillator output is provided.\nIt takes four oscillator cycles to open the clock gate after a request but the oscillator analog start-up time\nwill be removed when this bit is set."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "CPU",
      "id": "I2100",
      "name": "CPU",
      "register_groups": [
        {
          "caption": "CPU",
          "name": "CPU",
          "size": "0x10",
          "registers": [
            {
              "caption": "Configuration Change Protection",
              "reset": "0x00",
              "name": "CCP",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CCP signature",
                  "mask": "0xff",
                  "name": "CCP",
                  "rw": "RW",
                  "values_ref": "CPU_CCP",
                  "description": "Writing the correct signature to this bit field allows changing protected I/O registers or executing protected\ninstructions within the next four CPU instructions executed.\nAll interrupts are ignored during these cycles. After these cycles, interrupts will automatically be handled\nagain by the CPU, and any pending interrupts will be executed according to their level and priority.\nWhen the protected I/O register signature is written, CCP[0] will read as '1' as long as the CCP feature is\nenabled.\nWhen the protected self-programming signature is written, CCP[1] will read as '1' as long as the CCP\nfeature is enabled.\nCCP[7:2] will always read as zero.\n\n\n| Value | Name  | Description                        |\n| :---- | :---- | :--------------------------------- |\n| 0x9D  | SPM   | Allow Self-Programming             |\n| 0xD8  | IOREG | Un-protect protected I/O registers |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Stack Pointer High",
              "reset": null,
              "name": "SPH",
              "offset": "0xE",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "The CPU.SP holds the Stack Pointer (SP) that points to the top of the stack. After Reset, the Stack\nPointer points to the highest internal SRAM address.\nOnly the number of bits required to address the available data memory including external memory (up to\n64 KB) is implemented for each device. Unused bits will always read as zero.\nThe CPU.SPL and CPU.SPH register pair represents the 16-bit value, CPU.SP. The low byte [7:0] (suffix\nL) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nTo prevent corruption when updating the SP from software, a write to CPU.SPL will automatically disable\ninterrupts for the next four instructions or until the next I/O memory write."
            },
            {
              "caption": "Stack Pointer Low",
              "reset": null,
              "name": "SPL",
              "offset": "0xD",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "The CPU.SP holds the Stack Pointer (SP) that points to the top of the stack. After Reset, the Stack\nPointer points to the highest internal SRAM address.\nOnly the number of bits required to address the available data memory including external memory (up to\n64 KB) is implemented for each device. Unused bits will always read as zero.\nThe CPU.SPL and CPU.SPH register pair represents the 16-bit value, CPU.SP. The low byte [7:0] (suffix\nL) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nTo prevent corruption when updating the SP from software, a write to CPU.SPL will automatically disable\ninterrupts for the next four instructions or until the next I/O memory write."
            },
            {
              "caption": "Status Register",
              "reset": "0x00",
              "name": "SREG",
              "offset": "0xF",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Carry Flag",
                  "mask": "0x1",
                  "name": "C",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The carry flag (C) indicates a carry in an arithmetic or logic operation."
                },
                {
                  "caption": "Half Carry Flag",
                  "mask": "0x20",
                  "name": "H",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit indicates a half carry in some arithmetic operations. Half carry is useful in BCD arithmetic."
                },
                {
                  "caption": "Global Interrupt Enable Flag",
                  "mask": "0x80",
                  "name": "I",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables interrupts on the device.\nWriting a '0' to this bit disables interrupts on the device, independent of the individual interrupt enable\nsettings of the peripherals.\nThis bit is not cleared by hardware after an interrupt has occurred.\nThis bit can be set and cleared by software with the SEI and CLI instructions.\nChanging the I flag through the I/O register results in a one-cycle Wait state on the access."
                },
                {
                  "caption": "Negative Flag",
                  "mask": "0x4",
                  "name": "N",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The negative flag (N) indicates a negative result in an arithmetic or logic operation."
                },
                {
                  "caption": "N Exclusive Or V Flag",
                  "mask": "0x10",
                  "name": "S",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The sign bit (S) is always an exclusive or (xor) between the negative flag (N) and the two's complement\noverflow flag (V)."
                },
                {
                  "caption": "Transfer Bit",
                  "mask": "0x40",
                  "name": "T",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The bit copy instructions bit load (BLD) and bit store (BST) use the T bit as source or destination for the\noperated bit.\nA bit from a register in the register file can be copied into this bit by the BST instruction, and this bit can\nbe copied into a bit in a register in the register file by the BLD instruction."
                },
                {
                  "caption": "Two's Complement Overflow Flag",
                  "mask": "0x8",
                  "name": "V",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The two's complement overflow flag (V) supports two's complement arithmetic."
                },
                {
                  "caption": "Zero Flag",
                  "mask": "0x2",
                  "name": "Z",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The zero flag (Z) indicates a zero result in an arithmetic or logic operation."
                }
              ],
              "description": "The STATUS register contains information about the result of the most recently executed arithmetic or\nlogic instruction. For details about the bits in this register and how they are affected by the different\ninstructions, see the Instruction Set Summary."
            }
          ]
        }
      ]
    },
    {
      "caption": "Interrupt Controller",
      "id": "I2104",
      "name": "CPUINT",
      "register_groups": [
        {
          "caption": "Interrupt Controller",
          "name": "CPUINT",
          "size": "0x4",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compact Vector Table",
                  "mask": "0x20",
                  "name": "CVT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is protected by the Configuration Change Protection mechanism.\n\n\n| Value | Description                               |\n| :---- | :---------------------------------------- |\n| 0     | Compact Vector Table function is disabled |\n| 1     | Compact Vector Table function is enabled  |\n\n"
                },
                {
                  "caption": "Interrupt Vector Select",
                  "mask": "0x40",
                  "name": "IVSEL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If the boot section is defined, it will be placed before the application section. The actual start address of\nthe application section is determined by the BOOTEND fuse.\nThis bit is protected by the Configuration Change Protection mechanism.\n\n\n| Value | Description                                                                       |\n| :---- | :-------------------------------------------------------------------------------- |\n| 0     | Interrupt vectors are placed at the start of the application section of the Flash |\n| 1     | Interrupt vectors are placed at the start of the boot section of the Flash        |\n\n"
                },
                {
                  "caption": "Round-robin Scheduling Enable",
                  "mask": "0x1",
                  "name": "LVL0RR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is not protected by the Configuration Change Protection mechanism.\n\n\n| Value | Description                                                                                        |\n| :---- | :------------------------------------------------------------------------------------------------- |\n| 0     | Priority is fixed for priority level 0 interrupt requests: The lowest interrupt vector address has |\n\n\nhighest priority.\n1 Round Robin priority scheme is enabled for priority level 0 interrupt requests"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Level 0 Priority",
              "reset": "0x00",
              "name": "LVL0PRI",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Interrupt Level Priority",
                  "mask": "0xff",
                  "name": "LVL0PRI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When Round Robin is enabled (LVL0RR bit in CPUINT.CTRLA is '1'), this bit field stores the vector of the\nlast acknowledged priority level 0 (LVL0) interrupt. The stored vector will have the lowest priority next time\none or more LVL0 interrupts are pending.\nIf Round Robin is disabled (LVL0RR in CPUINT.CTRLA is '0'), the vector address-based priority scheme\n(lowest address has the highest priority) is governing the priorities of LVL0 interrupt requests.\nIf a system Reset is asserted, the lowest interrupt vector address will have the highest priority within the\nLVL0."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Level 1 Priority Vector",
              "reset": "0x00",
              "name": "LVL1VEC",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Interrupt Vector with High Priority",
                  "mask": "0xff",
                  "name": "LVL1VEC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit field contains the address of the single vector with increased priority level 1 (LVL1).\nIf this bit field has the value 0x00, no vector has LVL1. Consequently, the LVL1 interrupt is disabled."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Level 0 Interrupt Executing",
                  "mask": "0x1",
                  "name": "LVL0EX",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when a priority level 0 interrupt is executing, or when the interrupt handler has been\ninterrupted by a priority level 1 interrupt or an NMI. The flag is cleared when returning (RETI) from the\ninterrupt handler."
                },
                {
                  "caption": "Level 1 Interrupt Executing",
                  "mask": "0x2",
                  "name": "LVL1EX",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when a priority level 1 interrupt is executing, or when the interrupt handler has been\ninterrupted by an NMI. The flag is cleared when returning (RETI) from the interrupt handler."
                },
                {
                  "caption": "Non-maskable Interrupt Executing",
                  "mask": "0x80",
                  "name": "NMIEX",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set if a non-maskable interrupt is executing. The flag is cleared when returning (RETI) from\nthe interrupt handler."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "CRCSCAN",
      "id": "I2122",
      "name": "CRCSCAN",
      "register_groups": [
        {
          "caption": "CRCSCAN",
          "name": "CRCSCAN",
          "size": "0x4",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable CRC scan",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the CRCSCAN peripheral with the current settings. It will stay '1' even after a\nCRC check has completed, but writing it to '1' again will start a new check.\nWriting the bit to '0' will disable the CRCSCAN after the ongoing check is completed (after reaching the\nend of the section it is set up to check). A failure in the ongoing check will still be detected and can cause\nan NMI if the NMIEN bit is '1'.\nThe CRCSCAN can be enabled during the internal Reset initialization to verify Flash sections before\nletting the CPU start normal code execution (see device data sheet fuse description). If the CRCSCAN is\nenabled during the internal Reset initialization, the ENABLE bit will read as '1' when normal code\nexecution starts.\nTo see whether the CRCSCAN peripheral is busy with an ongoing check, poll the Busy bit (BUSY) in the\nSTATUS register (CRCSCAN.STATUS).\nRelated Links\nConfiguration and User Fuses (FUSE)\nReset Time"
                },
                {
                  "caption": "Enable NMI Trigger",
                  "mask": "0x2",
                  "name": "NMIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', any CRC failure will trigger an NMI.\nThis can only be cleared by a system Reset - it is not cleared by a write to the RESET bit.\nThis bit can only be written to '1' when the CRCSCAN is not busy (the BUSY bit in CRCSCAN.STATUS is\n'0')."
                },
                {
                  "caption": "Reset CRC scan",
                  "mask": "0x80",
                  "name": "RESET",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' resets the CRCSCAN peripheral: The CRCSCAN Control registers and STATUS\nregister (CTRLA, CTRLB, STATUS) will be cleared one clock cycle after the RESET bit was written to '1'.\nIf NMIEN is '0', this bit is writable both when the CRCSCAN is busy (the BUSY bit in CRCSCAN.STATUS\nis '1') and not busy (the BUSY bit is '0'), and will take effect immediately.\nIf NMIEN is '1', this bit is only writable when the CRCSCAN is not busy (the BUSY bit in\nCRCSCAN.STATUS is '0').\nThe RESET bit is a strobe bit."
                }
              ],
              "description": "If an NMI has been triggered, this register is not writable."
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CRC Flash Access Mode",
                  "mask": "0x30",
                  "name": "MODE",
                  "rw": "RW",
                  "values_ref": "CRCSCAN_MODE",
                  "description": "These bits select the LUT output filter options:\n\n\n| Value | Name    | Description          |\n| :---- | :------ | :------------------- |\n| 0x0   | DISABLE | Filter disabled      |\n| 0x1   | SYNCH   | Synchronizer enabled |\n| 0x2   | FILTER  | Filter enabled       |\n| 0x3   | -       | Reserved             |\n\n"
                },
                {
                  "caption": "CRC Source",
                  "mask": "0x3",
                  "name": "SRC",
                  "rw": "RW",
                  "values_ref": "CRCSCAN_SRC",
                  "description": "The SRC bit field selects which section of the Flash the CRC module should check. To set up section\nsizes, refer to the fuse description.\nThe CRC can be enabled during internal Reset initialization to verify Flash sections before letting the\nCPU start (see fuse description). If the CRC is enabled during internal Reset initialization, the SRC bit\nfield will read out as FLASH, BOOTAPP, or BOOT when normal code execution starts (depending on the\nconfiguration).\n\n\n| Value | Name  | Description                                                           |\n| :---- | :---- | :-------------------------------------------------------------------- |\n| 0x0   | FLASH | The CRC is performed on the entire Flash (boot, application code, and |\n\n\napplication data sections).\n0x1 BOOTAPP The CRC is performed on the boot and application code sections of Flash.\n0x2 BOOT The CRC is performed on the boot section of Flash.\n0x3 - Reserved.\nRelated Links\nConfiguration and User Fuses (FUSE)\nReset Time"
                }
              ],
              "description": "The CTRLB register contains the mode and source settings for the CRC. It is not writable when the CRC\nis busy or when an NMI has been triggered."
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x2",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CRC Busy",
                  "mask": "0x1",
                  "name": "BUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When this bit is read as 1, the CRC module is busy. As long as the module is busy, the access to the\ncontrol registers is limited."
                },
                {
                  "caption": "CRC Ok",
                  "mask": "0x2",
                  "name": "OK",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When this bit is read as 1, the previous CRC completed successfully. The bit is set to '1' from Reset but is\ncleared to '0' when enabling. As long as the CRC module is busy, it will be read '0'. When running\ncontinuously, the CRC status must be assumed OK until it fails or is stopped by the user."
                }
              ],
              "description": "The STATUS register contains the busy and OK information. It is not writable, only readable."
            }
          ]
        }
      ]
    },
    {
      "caption": "Event System",
      "id": "I2601",
      "name": "EVSYS",
      "register_groups": [
        {
          "caption": "Event System",
          "name": "EVSYS",
          "size": "0x40",
          "registers": [
            {
              "caption": "Asynchronous Channel 0 Generator Selection",
              "reset": "0x00",
              "name": "ASYNCCH0",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous Channel 0 Generator Selection",
                  "mask": "0xff",
                  "name": "ASYNCCH0",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCCH0",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous Channel 1 Generator Selection",
              "reset": "0x00",
              "name": "ASYNCCH1",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous Channel 1 Generator Selection",
                  "mask": "0xff",
                  "name": "ASYNCCH1",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCCH1",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous Channel Strobe",
              "reset": "0x00",
              "name": "ASYNCSTROBE",
              "offset": "0x00",
              "rw": "W",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Asynchronous User Ch 0 Input Selection - TCB0",
              "reset": "0x00",
              "name": "ASYNCUSER0",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 0 Input Selection - TCB0",
                  "mask": "0xff",
                  "name": "ASYNCUSER0",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER0",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 1 Input Selection - ADC0",
              "reset": "0x00",
              "name": "ASYNCUSER1",
              "offset": "0x13",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 1 Input Selection - ADC0",
                  "mask": "0xff",
                  "name": "ASYNCUSER1",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER1",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0",
              "reset": "0x00",
              "name": "ASYNCUSER2",
              "offset": "0x14",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0",
                  "mask": "0xff",
                  "name": "ASYNCUSER2",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER2",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0",
              "reset": "0x00",
              "name": "ASYNCUSER3",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0",
                  "mask": "0xff",
                  "name": "ASYNCUSER3",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER3",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1",
              "reset": "0x00",
              "name": "ASYNCUSER4",
              "offset": "0x16",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1",
                  "mask": "0xff",
                  "name": "ASYNCUSER4",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER4",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1",
              "reset": "0x00",
              "name": "ASYNCUSER5",
              "offset": "0x17",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1",
                  "mask": "0xff",
                  "name": "ASYNCUSER5",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER5",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 6 Input Selection - TCD0 Event 0",
              "reset": "0x00",
              "name": "ASYNCUSER6",
              "offset": "0x18",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 6 Input Selection - TCD0 Event 0",
                  "mask": "0xff",
                  "name": "ASYNCUSER6",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER6",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 7 Input Selection - TCD0 Event 1",
              "reset": "0x00",
              "name": "ASYNCUSER7",
              "offset": "0x19",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 7 Input Selection - TCD0 Event 1",
                  "mask": "0xff",
                  "name": "ASYNCUSER7",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER7",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 8 Input Selection - Event Out 0",
              "reset": "0x00",
              "name": "ASYNCUSER8",
              "offset": "0x1A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 8 Input Selection - Event Out 0",
                  "mask": "0xff",
                  "name": "ASYNCUSER8",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER8",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 9 Input Selection - Event Out 1",
              "reset": "0x00",
              "name": "ASYNCUSER9",
              "offset": "0x1B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 9 Input Selection - Event Out 1",
                  "mask": "0xff",
                  "name": "ASYNCUSER9",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER9",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Asynchronous User Ch 10 Input Selection - Event Out 2",
              "reset": "0x00",
              "name": "ASYNCUSER10",
              "offset": "0x1C",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous User Ch 10 Input Selection - Event Out 2",
                  "mask": "0xff",
                  "name": "ASYNCUSER10",
                  "rw": "RW",
                  "values_ref": "EVSYS_ASYNCUSER10",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Synchronous Channel 0 Generator Selection",
              "reset": "0x00",
              "name": "SYNCCH0",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Synchronous Channel 0 Generator Selection",
                  "mask": "0xff",
                  "name": "SYNCCH0",
                  "rw": "RW",
                  "values_ref": "EVSYS_SYNCCH0",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Synchronous Channel 1 Generator Selection",
              "reset": "0x00",
              "name": "SYNCCH1",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Synchronous Channel 1 Generator Selection",
                  "mask": "0xff",
                  "name": "SYNCCH1",
                  "rw": "RW",
                  "values_ref": "EVSYS_SYNCCH1",
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Synchronous Channel Strobe",
              "reset": "0x00",
              "name": "SYNCSTROBE",
              "offset": "0x01",
              "rw": "W",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Synchronous User Ch 0 Input Selection - TCA0",
              "reset": "0x00",
              "name": "SYNCUSER0",
              "offset": "0x22",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Synchronous User Ch 0 Input Selection - TCA0",
                  "mask": "0xff",
                  "name": "SYNCUSER0",
                  "rw": "RW",
                  "values_ref": "EVSYS_SYNCUSER0",
                  "description": null
                }
              ],
              "description": "Undocumented"
            }
          ]
        }
      ]
    },
    {
      "caption": "Fuses",
      "id": "I2601",
      "name": "FUSE",
      "register_groups": [
        {
          "caption": "Fuses",
          "name": "FUSE",
          "size": "0x09",
          "registers": [
            {
              "caption": "Application Code Section End",
              "reset": "0x00",
              "name": "APPEND",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "BOD Configuration",
              "reset": "0x00",
              "name": "BODCFG",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "BOD Operation in Active Mode",
                  "mask": "0xc",
                  "name": "ACTIVE",
                  "rw": "RW",
                  "values_ref": "FUSE_ACTIVE",
                  "description": "This value is loaded into the ACTIVE bit field of the BOD Control A register (BOD.CTRLA) during Reset.\n\n\n| Value | Description                                    |\n| :---- | :--------------------------------------------- |\n| 0x0   | Disabled                                       |\n| 0x1   | Enabled                                        |\n| 0x2   | Sampled                                        |\n| 0x3   | Enabled with wake-up halted until BOD is ready |\n\n"
                },
                {
                  "caption": "BOD Level",
                  "mask": "0xe0",
                  "name": "LVL",
                  "rw": "RW",
                  "values_ref": "FUSE_LVL",
                  "description": "This value is loaded into the LVL bit field of the BOD Control B register (BOD.CTRLB) during Reset.\n\n\n| Value | Name      | Description |\n| :---- | :-------- | :---------- |\n| 0x0   | BODLEVEL0 | 1.8V        |\n| 0x1   | BODLEVEL1 | 2.15V       |\n| 0x2   | BODLEVEL2 | 2.60V       |\n| 0x3   | BODLEVEL3 | 2.95V       |\n| 0x4   | BODLEVEL4 | 3.30V       |\n| 0x5   | BODLEVEL5 | 3.70V       |\n| 0x6   | BODLEVEL6 | 4.00V       |\n| 0x7   | BODLEVEL7 | 4.30V       |\n\n"
                },
                {
                  "caption": "BOD Sample Frequency",
                  "mask": "0x10",
                  "name": "SAMPFREQ",
                  "rw": "RW",
                  "values_ref": "FUSE_SAMPFREQ",
                  "description": "This value is loaded into the SAMPFREQ bit of the BOD Control A register (BOD.CTRLA) during Reset.\n\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0x0   | Sample frequency is 1 kHz  |\n| 0x1   | Sample frequency is 125 Hz |\n\n"
                },
                {
                  "caption": "BOD Operation in Sleep Mode",
                  "mask": "0x3",
                  "name": "SLEEP",
                  "rw": "RW",
                  "values_ref": "FUSE_SLEEP",
                  "description": "This value is loaded into the SLEEP bit field of the BOD Control A register (BOD.CTRLA) during Reset.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | Disabled    |\n| 0x1   | Enabled     |\n\n\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x2   | Sampled     |\n| 0x3   | Reserved    |\n\n\nRelated Links\nRegister Summary - BOD\nReset Controller (RSTCTRL)"
                }
              ],
              "description": "The settings of the BOD will be reloaded from this Fuse after a Power-on Reset. For all other Resets, the\nBOD configuration remains unchanged."
            },
            {
              "caption": "Boot Section End",
              "reset": "0x00",
              "name": "BOOTEND",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Oscillator Configuration",
              "reset": "0x02",
              "name": "OSCCFG",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Frequency Select",
                  "mask": "0x3",
                  "name": "FREQSEL",
                  "rw": "RW",
                  "values_ref": "FUSE_FREQSEL",
                  "description": "These bits select the operation frequency of the 16/20 MHz internal oscillator (OSC20M), and determine\nthe respective factory calibration values to be written to CAL20M in CLKCTRL.OSC20MCALIBA and\nTEMPCAL20M in CLKCTRL.OSC20MCALIBB.\n\n\n| Value | Description                                          |\n| :---- | :--------------------------------------------------- |\n| 0x1   | Run at 16 MHz with corresponding factory calibration |\n| 0x2   | Run at 20 MHz with corresponding factory calibration |\n| Other | Reserved                                             |\n\n\nRelated Links\nRegister Summary - CLKCTRL\nReset Controller (RSTCTRL)"
                },
                {
                  "caption": "Oscillator Lock",
                  "mask": "0x80",
                  "name": "OSCLOCK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This fuse bit is loaded to LOCK in CLKCTRL.OSC20MCALIBB during Reset.\n\n\n| Value | Description                                                   |\n| :---- | :------------------------------------------------------------ |\n| 0     | Calibration registers of the 20 MHz oscillator are accessible |\n| 1     | Calibration registers of the 20 MHz oscillator are locked     |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "System Configuration 0",
              "reset": "0xC4",
              "name": "SYSCFG0",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CRC Source",
                  "mask": "0xc0",
                  "name": "CRCSRC",
                  "rw": "RW",
                  "values_ref": "FUSE_CRCSRC",
                  "description": "See CRC description for more information about the functionality.\n\n\n| Value | Name    | Description                                                     |\n| :---- | :------ | :-------------------------------------------------------------- |\n| 00    | FLASH   | CRC of full Flash (boot, application code and application data) |\n| 01    | BOOT    | CRC of boot section                                             |\n| 10    | BOOTAPP | CRC of application code and boot sections                       |\n| 11    | NOCRC   | No CRC                                                          |\n\n"
                },
                {
                  "caption": "EEPROM Save",
                  "mask": "0x1",
                  "name": "EESAVE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If the device is locked the EEPROM is always erased by a chip erase, regardless of this bit.\n\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0     | EEPROM erased during chip erase    |\n| 1     | EEPROM not erased under chip erase |\n\n"
                },
                {
                  "caption": "Reset Pin Configuration",
                  "mask": "0xc",
                  "name": "RSTPINCFG",
                  "rw": "RW",
                  "values_ref": "FUSE_RSTPINCFG",
                  "description": "These bits select the Reset/UPDI pin configuration.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | GPIO        |\n| 0x1   | UPDI        |\n| 0x2   | RESET       |\n| 0x3   | Reserved    |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "System Configuration 1",
              "reset": "0x07",
              "name": "SYSCFG1",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Startup Time",
                  "mask": "0x7",
                  "name": "SUT",
                  "rw": "RW",
                  "values_ref": "FUSE_SUT",
                  "description": "These bits select the start-up time between power-on and code execution.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | 0 ms        |\n| 0x1   | 1 ms        |\n| 0x2   | 2 ms        |\n| 0x3   | 4 ms        |\n| 0x4   | 8 ms        |\n| 0x5   | 16 ms       |\n| 0x6   | 32 ms       |\n| 0x7   | 64 ms       |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "TCD0 Configuration",
              "reset": "0x00",
              "name": "TCD0CFG",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare A Default Output Value",
                  "mask": "0x1",
                  "name": "CMPA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Compare A Output Enable",
                  "mask": "0x10",
                  "name": "CMPAEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Compare B Default Output Value",
                  "mask": "0x2",
                  "name": "CMPB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Compare B Output Enable",
                  "mask": "0x20",
                  "name": "CMPBEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Compare C Default Output Value",
                  "mask": "0x4",
                  "name": "CMPC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Compare C Output Enable",
                  "mask": "0x40",
                  "name": "CMPCEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Compare D Default Output Value",
                  "mask": "0x8",
                  "name": "CMPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Compare D Output Enable",
                  "mask": "0x80",
                  "name": "CMPDEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Watchdog Configuration",
              "reset": "0x00",
              "name": "WDTCFG",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Watchdog Timeout Period",
                  "mask": "0xf",
                  "name": "PERIOD",
                  "rw": "RW",
                  "values_ref": "FUSE_PERIOD",
                  "description": "This value is loaded into the PERIOD bit field of the Watchdog Control A register (WDT.CTRLA) during\nReset.\nRelated Links\nRegister Summary - WDT\nReset Controller (RSTCTRL)"
                },
                {
                  "caption": "Watchdog Window Timeout Period",
                  "mask": "0xf0",
                  "name": "WINDOW",
                  "rw": "RW",
                  "values_ref": "FUSE_WINDOW",
                  "description": "This value is loaded into the WINDOW bit field of the Watchdog Control A register (WDT.CTRLA) during\nReset."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "General Purpose IO",
      "id": "I2601",
      "name": "GPIO",
      "register_groups": [
        {
          "caption": "General Purpose IO",
          "name": "GPIO",
          "size": "0x4",
          "registers": [
            {
              "caption": "General Purpose IO Register 0",
              "reset": null,
              "name": "GPIOR0",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "General Purpose IO Register 1",
              "reset": null,
              "name": "GPIOR1",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "General Purpose IO Register 2",
              "reset": null,
              "name": "GPIOR2",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "General Purpose IO Register 3",
              "reset": null,
              "name": "GPIOR3",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            }
          ]
        }
      ]
    },
    {
      "caption": "Lockbit",
      "id": "I2601",
      "name": "LOCKBIT",
      "register_groups": [
        {
          "caption": "Lockbit",
          "name": "LOCKBIT",
          "size": "0x01",
          "registers": [
            {
              "caption": "Lock bits",
              "reset": "0xC5",
              "name": "LOCKBIT",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Lock Bits",
                  "mask": "0xff",
                  "name": "LB",
                  "rw": "RW",
                  "values_ref": "LOCKBIT_LB",
                  "description": "When the part is locked, UPDI cannot access the system bus, so it cannot read out anything but CS-\nspace.\n\n\n| Value | Description                    |\n| :---- | :----------------------------- |\n| 0xC5  | Valid key - the device is open |\n| other | Invalid - The device is locked |\n\n\nRelated Links\nMemory Section Access from CPU and UPDI on Locked Device"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Non-volatile Memory Controller",
      "id": "I2109",
      "name": "NVMCTRL",
      "register_groups": [
        {
          "caption": "Non-volatile Memory Controller",
          "name": "NVMCTRL",
          "size": "0x10",
          "registers": [
            {
              "caption": "Address",
              "reset": null,
              "name": "ADDR",
              "offset": "0x8",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The NVMCTRL.ADDRL and NVMCTRL.ADDRH register pair represents the 16-bit value,\nNVMCTRL.ADDR. The low byte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8]\n(suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0x7",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "NVMCTRL_CMD",
                  "description": "Write this bit field to issue a command. The Configuration Change Protection key for self-programming\n(SPM) has to be written within four instructions before this write.\nValue Name Description\n0x0 - No command\n0x1 WP Write page buffer to memory (NVMCTRL.ADDR selects which memory)\n0x2 ER Erase page (NVMCTRL.ADDR selects which memory)\n0x3 ERWP Erase and write page (NVMCTRL.ADDR selects which memory)\n0x4 PBC Page buffer clear\n0x5 CHER Chip erase: erase Flash and EEPROM (unless EESAVE in FUSE.SYSCFG is '1')\n0x6 EEER EEPROM Erase\n0x7 WFU Write fuse (only accessible through UPDI)"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Application code write protect",
                  "mask": "0x1",
                  "name": "APCWP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit protects the application code section from further writes.\nThis bit can only be written to '1'. It is cleared to '0' only by Reset."
                },
                {
                  "caption": "Boot Lock",
                  "mask": "0x2",
                  "name": "BOOTLOCK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit locks the boot section from read and instruction fetch.\nIf this bit is '1', a read from the boot section will return '0'. A fetch from the boot section will also return 0\nas instruction.\nThis bit can be written from the boot section only. It can only be cleared to '0' by a Reset.\nThis bit will take effect only when the boot section is left the first time after the bit is written."
                }
              ],
              "description": null
            },
            {
              "caption": "Data",
              "reset": null,
              "name": "DATA",
              "offset": "0x6",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The NVMCTRL.DATAL and NVMCTRL.DATAH register pair represents the 16-bit value,\nNVMCTRL.DATA. The low byte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8]\n(suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "EEPROM Ready",
                  "mask": "0x1",
                  "name": "EEREADY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the interrupt, which indicates that the EEPROM is ready for new write/\nerase operations.\nThis is a level interrupt that will be triggered only when the EEREADY flag in the INTFLAGS register is set\nto zero. Thus, the interrupt should not be enabled before triggering an NVM command, as the EEREADY\nflag will not be set before the NVM command issued. The interrupt should be disabled in the interrupt\nhandler."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "EEPROM Ready",
                  "mask": "0x1",
                  "name": "EEREADY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Interrupt flag for the EEPROM interrupt. This bit is cleared by writing a '1' to it. When this interrupt is\nenabled, it will immediately request an interrupt, and it will continue to request interrupts - even if no\nEEPROM writes are initiated."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": null,
              "name": "STATUS",
              "offset": "0x2",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "EEPROM busy",
                  "mask": "0x2",
                  "name": "EEBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit will read '1' when the EEPROM is busy with a command."
                },
                {
                  "caption": "Flash busy",
                  "mask": "0x1",
                  "name": "FBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit will read '1' when the Flash is busy with a command."
                },
                {
                  "caption": "Write error",
                  "mask": "0x4",
                  "name": "WRERROR",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit will read '1' when a write error has happened. A write error could be writing to different sections\nbefore doing a page write or writing to a protected area. This bit is valid for the last operation."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "I/O Ports",
      "id": "I2103",
      "name": "PORT",
      "register_groups": [
        {
          "caption": "I/O Ports",
          "name": "PORT",
          "size": "0x20",
          "registers": [
            {
              "caption": "Data Direction",
              "reset": null,
              "name": "DIR",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Data Direction Clear",
              "reset": null,
              "name": "DIRCLR",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Data Direction Set",
              "reset": null,
              "name": "DIRSET",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Data Direction Toggle",
              "reset": null,
              "name": "DIRTGL",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Input Value",
              "reset": null,
              "name": "IN",
              "offset": "0x08",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Pin Interrupt",
                  "mask": "0xff",
                  "name": "INT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The INT Flag is set when a pin change/state matches the pin's input sense configuration.\nWriting a '1' to a flag's bit location will clear the flag.\nFor enabling and executing the interrupt, refer to ISC bit description in PORT.PINnCTRL."
                }
              ],
              "description": null
            },
            {
              "caption": "Output Value",
              "reset": null,
              "name": "OUT",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Output Value Clear",
              "reset": null,
              "name": "OUTCLR",
              "offset": "0x06",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Output Value Set",
              "reset": null,
              "name": "OUTSET",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Output Value Toggle",
              "reset": null,
              "name": "OUTTGL",
              "offset": "0x07",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Pin 0 Control",
              "reset": "0x00",
              "name": "PIN0CTRL",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": null
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Pin 1 Control",
              "reset": "0x00",
              "name": "PIN1CTRL",
              "offset": "0x11",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": null
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Pin 2 Control",
              "reset": "0x00",
              "name": "PIN2CTRL",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": null
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Pin 3 Control",
              "reset": "0x00",
              "name": "PIN3CTRL",
              "offset": "0x13",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": null
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Pin 4 Control",
              "reset": "0x00",
              "name": "PIN4CTRL",
              "offset": "0x14",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": null
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Pin 5 Control",
              "reset": "0x00",
              "name": "PIN5CTRL",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": null
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Pin 6 Control",
              "reset": "0x00",
              "name": "PIN6CTRL",
              "offset": "0x16",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": null
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Pin 7 Control",
              "reset": "0x00",
              "name": "PIN7CTRL",
              "offset": "0x17",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inverted I/O Enable",
                  "mask": "0x80",
                  "name": "INVEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                },
                {
                  "caption": "Input/Sense Configuration",
                  "mask": "0x7",
                  "name": "ISC",
                  "rw": "RW",
                  "values_ref": "PORT_ISC",
                  "description": null
                },
                {
                  "caption": "Pullup enable",
                  "mask": "0x8",
                  "name": "PULLUPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            }
          ]
        }
      ]
    },
    {
      "caption": "Port Multiplexer",
      "id": "I2601",
      "name": "PORTMUX",
      "register_groups": [
        {
          "caption": "Port Multiplexer",
          "name": "PORTMUX",
          "size": "0x10",
          "registers": [
            {
              "caption": "Port Multiplexer Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Event Output 0",
                  "mask": "0x1",
                  "name": "EVOUT0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Write this bit to '1' to enable event output 0."
                },
                {
                  "caption": "Event Output 1",
                  "mask": "0x2",
                  "name": "EVOUT1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "These bits select the BOD operation mode when the device is in Standby or Power-Down Sleep mode.\nThe Reset value is loaded from the SLEEP bits in FUSE.BODCFG.\nThese bits are under Configuration Change Protection (CCP).\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | Disabled    |\n| 0x1   | Enabled     |\n| 0x2   | Sampled     |\n| 0x3   | Reserved    |\n\n"
                },
                {
                  "caption": "Event Output 2",
                  "mask": "0x4",
                  "name": "EVOUT2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Write this bit to '1' to select alternative communication pins for SPI 0."
                },
                {
                  "caption": "Configurable Custom Logic LUT0",
                  "mask": "0x10",
                  "name": "LUT0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_LUT0",
                  "description": "This bit selects the BOD sample frequency.\nThe Reset value is loaded from the SAMPFREQ bit in FUSE.BODCFG. This bit is under Configuration\nChange Protection (CCP).\n\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0x0   | Sample frequency is 1 kHz  |\n| 0x1   | Sample frequency is 125 Hz |\n\n"
                },
                {
                  "caption": "Configurable Custom Logic LUT1",
                  "mask": "0x20",
                  "name": "LUT1",
                  "rw": "RW",
                  "values_ref": "PORTMUX_LUT1",
                  "description": "In the FRQ or PWM Waveform Generation mode, these bits will override the PORT output register for the\ncorresponding pin.\n\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | Port output settings for the pin with WOn output respected                     |\n| 1     | Port output settings for pin with WOn output overridden in FRQ or PWM Waveform |\n\n\nGeneration mode"
                }
              ],
              "description": null
            },
            {
              "caption": "Port Multiplexer Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Port Multiplexer SPI0",
                  "mask": "0x4",
                  "name": "SPI0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_SPI0",
                  "description": "Write this bit to '1' to select alternative communication pins for SPI 0."
                },
                {
                  "caption": "Port Multiplexer USART0",
                  "mask": "0x1",
                  "name": "USART0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_USART0",
                  "description": "Write this bit to '1' to select alternative communication pins for USART 0."
                }
              ],
              "description": null
            },
            {
              "caption": "Port Multiplexer Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Port Multiplexer TCA0 Output 0",
                  "mask": "0x1",
                  "name": "TCA00",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA00",
                  "description": "The CMPnOV bits allow direct access to the waveform generator's output compare value when the timer/\ncounter is not enabled. This is used to set or clear the WG output value when the timer/counter is not\nrunning."
                },
                {
                  "caption": "Port Multiplexer TCA0 Output 1",
                  "mask": "0x2",
                  "name": "TCA01",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA01",
                  "description": "See CMP0OV."
                },
                {
                  "caption": "Port Multiplexer TCA0 Output 2",
                  "mask": "0x4",
                  "name": "TCA02",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA02",
                  "description": "See CMP0OV."
                },
                {
                  "caption": "Port Multiplexer TCA0 Output 3",
                  "mask": "0x8",
                  "name": "TCA03",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCA03",
                  "description": "These bits are used for software control of update, restart, and reset of the timer/counter. The command\nbits are always read as zero.\n\n\n| Value | Name    | Description                                 |\n| :---- | :------ | :------------------------------------------ |\n| 0x0   | NONE    | No command                                  |\n| 0x1   | UPDATE  | Force update                                |\n| 0x2   | RESTART | Force restart                               |\n| 0x3   | RESET   | Force hard Reset (ignored if TC is enabled) |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Port Multiplexer Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Port Multiplexer TCB",
                  "mask": "0x1",
                  "name": "TCB0",
                  "rw": "RW",
                  "values_ref": "PORTMUX_TCB0",
                  "description": "This bit sets the timer/counter in Split mode operation. It will then work as two 8-bit timer/counters. The\nregister map will change compared to normal 16-bit mode."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Reset controller",
      "id": "I2111",
      "name": "RSTCTRL",
      "register_groups": [
        {
          "caption": "Reset controller",
          "name": "RSTCTRL",
          "size": "0x4",
          "registers": [
            {
              "caption": "Reset Flags",
              "reset": "0x00",
              "name": "RSTFR",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Brown out detector Reset flag",
                  "mask": "0x2",
                  "name": "BORF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a Brown-out Reset occurs."
                },
                {
                  "caption": "External Reset flag",
                  "mask": "0x4",
                  "name": "EXTRF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if an External Reset occurs."
                },
                {
                  "caption": "Power on Reset flag",
                  "mask": "0x1",
                  "name": "PORF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a Power-on Reset occurs.\nThis flag is only cleared by writing a '1' to it.\nAfter a POR, only the POR flag is set and all other flags are cleared. No other flags can be set before a\nfull system boot is run after the POR."
                },
                {
                  "caption": "Software Reset flag",
                  "mask": "0x10",
                  "name": "SWRF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a Software Reset occurs."
                },
                {
                  "caption": "UPDI Reset flag",
                  "mask": "0x20",
                  "name": "UPDIRF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a UPDI Reset occurs."
                },
                {
                  "caption": "Watch dog Reset flag",
                  "mask": "0x8",
                  "name": "WDRF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set if a Watchdog Reset occurs."
                }
              ],
              "description": "All flags are cleared by writing a '1' to them. They are also cleared by a Power-on Reset, with the\nexception of the Power-On Reset Flag (PORF)."
            },
            {
              "caption": "Software Reset",
              "reset": "0x00",
              "name": "SWRR",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Software reset enable",
                  "mask": "0x1",
                  "name": "SWRE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', a software Reset will occur.\nThis bit will always read as '0'."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Real-Time Counter",
      "id": "I2116",
      "name": "RTC",
      "register_groups": [
        {
          "caption": "Real-Time Counter",
          "name": "RTC",
          "size": "0x20",
          "registers": [
            {
              "caption": "Clock Select",
              "reset": "0x00",
              "name": "CLKSEL",
              "offset": "0x07",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Select",
                  "mask": "0x3",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "RTC_CLKSEL",
                  "description": "Writing these bits select the source for the RTC clock (CLK_RTC).\n\n\n| Value | Name   | Description                    |\n| :---- | :----- | :----------------------------- |\n| 0x0   | INT32K | 32.768 kHz from OSCULP32K      |\n| 0x1   | INT1K  | 1.024 kHz from OSCULP32K       |\n| 0x2   | -      | Reserved                       |\n| 0x3   | EXTCLK | External clock from EXTCLK pin |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Compare",
              "reset": null,
              "name": "CMP",
              "offset": "0x0C",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The RTC.CMPL and RTC.CMPH register pair represents the 16-bit value, CMP. The low byte [7:0] (suffix\nL) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01."
            },
            {
              "caption": "Counter",
              "reset": null,
              "name": "CNT",
              "offset": "0x08",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The RTC.CNTL and RTC.CNTH register pair represents the 16-bit value, CNT. The low byte [7:0] (suffix\nL) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nDue to synchronization between the RTC clock and system clock domains, there is a latency of two RTC\nclock cycles from updating the register until this has an effect. Application software needs to check that\nthe CNTBUSY flag in RTC.STATUS is cleared before writing to this register."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Prescaling Factor",
                  "mask": "0x78",
                  "name": "PRESCALER",
                  "rw": "RW",
                  "values_ref": "RTC_PRESCALER",
                  "description": "These bits define the prescaling of the CLK_RTC clock signal. Due to synchronization between the RTC\nclock and system clock domains, there is a latency of two RTC clock cycles from updating the register\nuntil this has an effect. Application software needs to check that the CTRLABUSY flag in RTC.STATUS is\ncleared before writing to this register.\n\n\n| Value | Name     | Description                 |\n| :---- | :------- | :-------------------------- |\n| 0x0   | DIV1     | RTC clock/1 (no prescaling) |\n| 0x1   | DIV2     | RTC clock/2                 |\n| 0x2   | DIV4     | RTC clock/4                 |\n| 0x3   | DIV8     | RTC clock/8                 |\n| 0x4   | DIV16    | RTC clock/16                |\n| 0x5   | DIV32    | RTC clock/32                |\n| 0x6   | DIV64    | RTC clock/64                |\n| 0x7   | DIV128   | RTC clock/128               |\n| 0x8   | DIV256   | RTC clock/256               |\n| 0x9   | DIV512   | RTC clock/512               |\n| 0xA   | DIV1024  | RTC clock/1024              |\n| 0xB   | DIV2048  | RTC clock/2048              |\n| 0xC   | DIV4096  | RTC clock/4096              |\n| 0xD   | DIV8192  | RTC clock/8192              |\n| 0xE   | DIV16384 | RTC clock/16384             |\n| 0xF   | DIV32768 | RTC clock/32768             |\n\n"
                },
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "RTCEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description  |\n| :---- | :----------- |\n| 0     | RTC disabled |\n| 1     | RTC enabled  |\n\n"
                },
                {
                  "caption": "Run In Standby",
                  "mask": "0x80",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0     | RTC disabled in Standby Sleep mode |\n| 1     | RTC enabled in Standby Sleep mode  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Debug control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run in debug",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                     |\n| :---- | :------------------------------------------------------------------------------ |\n| 0     | The peripheral is halted in Break Debug mode and ignores events.                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted. |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare Match Interrupt enable",
                  "mask": "0x2",
                  "name": "CMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Enable interrupt-on-compare match (i.e., when the Counter value (CNT) matches the Compare value\n(CMP))."
                },
                {
                  "caption": "Overflow Interrupt enable",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Enable interrupt-on-counter overflow (i.e., when the Counter value (CNT) matched the Period value\n(PER) and wraps around to zero)."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare Match Interrupt",
                  "mask": "0x2",
                  "name": "CMP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when the Counter value (CNT) matches the Compare value (CMP).\nWriting a '1' to this bit clears the flag."
                },
                {
                  "caption": "Overflow Interrupt Flag",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when the Counter value (CNT) has reached the Period value (PER) and wrapped to zero.\nWriting a '1' to this bit clears the flag."
                }
              ],
              "description": null
            },
            {
              "caption": "Period",
              "reset": null,
              "name": "PER",
              "offset": "0x0A",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The RTC.PERL and RTC.PERH register pair represents the 16-bit value, PER. The low byte [7:0] (suffix\nL) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01.\nDue to synchronization between the RTC clock and system clock domains, there is a latency of two RTC\nclock cycles from updating the register until this has an effect. Application software needs to check that\nthe PERBUSY flag in RTC.STATUS is cleared before writing to this register."
            },
            {
              "caption": "PIT Control A",
              "reset": "0x00",
              "name": "PITCTRLA",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Period",
                  "mask": "0x78",
                  "name": "PERIOD",
                  "rw": "RW",
                  "values_ref": "RTC_PERIOD",
                  "description": "Writing this bit field selects the number of RTC clock cycles between each interrupt.\n\n\n| Value | Name     | Description  |\n| :---- | :------- | :----------- |\n| 0x0   | OFF      | No interrupt |\n| 0x1   | CYC4     | 4 cycles     |\n| 0x2   | CYC8     | 8 cycles     |\n| 0x3   | CYC16    | 16 cycles    |\n| 0x4   | CYC32    | 32 cycles    |\n| 0x5   | CYC64    | 64 cycles    |\n| 0x6   | CYC128   | 128 cycles   |\n| 0x7   | CYC256   | 256 cycles   |\n| 0x8   | CYC512   | 512 cycles   |\n| 0x9   | CYC1024  | 1024 cycles  |\n| 0xA   | CYC2048  | 2048 cycles  |\n| 0xB   | CYC4096  | 4096 cycles  |\n| 0xC   | CYC8192  | 8192 cycles  |\n| 0xD   | CYC16384 | 16384 cycles |\n| 0xE   | CYC32768 | 32768 cycles |\n| 0xF   | -        | Reserved     |\n\n"
                },
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "PITEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the Periodic Interrupt Timer."
                }
              ],
              "description": null
            },
            {
              "caption": "PIT Debug control",
              "reset": "0x00",
              "name": "PITDBGCTRL",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run in debug",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' will enable the PIT to run in Debug mode while the CPU is halted.\n\n\n| Value | Description                                                                     |\n| :---- | :------------------------------------------------------------------------------ |\n| 0     | The peripheral is halted in Break Debug mode and ignores events.                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted. |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "PIT Interrupt Control",
              "reset": "0x00",
              "name": "PITINTCTRL",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Periodic Interrupt",
                  "mask": "0x1",
                  "name": "PI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0     | The periodic interrupt is disabled |\n| 1     | The periodic interrupt is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "PIT Interrupt Flags",
              "reset": "0x00",
              "name": "PITINTFLAGS",
              "offset": "0x13",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Periodic Interrupt",
                  "mask": "0x1",
                  "name": "PI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when a periodic interrupt is issued.\nWriting a '1' clears the flag."
                }
              ],
              "description": null
            },
            {
              "caption": "PIT Status",
              "reset": "0x00",
              "name": "PITSTATUS",
              "offset": "0x11",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CTRLA Synchronization Busy Flag",
                  "mask": "0x1",
                  "name": "CTRLBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit indicates whether the RTC is busy synchronizing the Periodic Interrupt Timer Control A register\n(RTC.PITCTRLA) in the RTC clock domain."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": null,
              "name": "STATUS",
              "offset": "0x01",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Comparator Synchronization Busy Flag",
                  "mask": "0x8",
                  "name": "CMPBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is indicating whether the RTC is busy synchronizing the Compare register (RTC.CMP) in RTC\nclock domain."
                },
                {
                  "caption": "Count Synchronization Busy Flag",
                  "mask": "0x2",
                  "name": "CNTBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is indicating whether the RTC is busy synchronizing the Count register (RTC.CNT) in RTC clock\ndomain."
                },
                {
                  "caption": "CTRLA Synchronization Busy Flag",
                  "mask": "0x1",
                  "name": "CTRLABUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is indicating whether the RTC is busy synchronizing the Control A register (RTC.CTRLA) in RTC\nclock domain."
                },
                {
                  "caption": "Period Synchronization Busy Flag",
                  "mask": "0x4",
                  "name": "PERBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is indicating whether the RTC is busy synchronizing the Period register (RTC.PER) in RTC clock\ndomain."
                }
              ],
              "description": null
            },
            {
              "caption": "Temporary",
              "reset": null,
              "name": "TEMP",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this\nperipheral. It can be read and written by software. There is one common Temporary register for all the 16-\nbit registers of this peripheral."
            }
          ]
        }
      ]
    },
    {
      "caption": "Signature row",
      "id": "I2601",
      "name": "SIGROW",
      "register_groups": [
        {
          "caption": "Signature row",
          "name": "SIGROW",
          "size": "0x40",
          "registers": [
            {
              "caption": "Device ID Byte 0",
              "reset": null,
              "name": "DEVICEID0",
              "offset": "0x00",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Device ID Byte 1",
              "reset": null,
              "name": "DEVICEID1",
              "offset": "0x01",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Device ID Byte 2",
              "reset": null,
              "name": "DEVICEID2",
              "offset": "0x02",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "OSC16 error at 3V",
              "reset": null,
              "name": "OSC16ERR3V",
              "offset": "0x22",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "OSC16 error at 5V",
              "reset": null,
              "name": "OSC16ERR5V",
              "offset": "0x23",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "OSC20 error at 3V",
              "reset": null,
              "name": "OSC20ERR3V",
              "offset": "0x24",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "OSC20 error at 5V",
              "reset": null,
              "name": "OSC20ERR5V",
              "offset": "0x25",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 0",
              "reset": null,
              "name": "SERNUM0",
              "offset": "0x03",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 1",
              "reset": null,
              "name": "SERNUM1",
              "offset": "0x04",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 2",
              "reset": null,
              "name": "SERNUM2",
              "offset": "0x05",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 3",
              "reset": null,
              "name": "SERNUM3",
              "offset": "0x06",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 4",
              "reset": null,
              "name": "SERNUM4",
              "offset": "0x07",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 5",
              "reset": null,
              "name": "SERNUM5",
              "offset": "0x08",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 6",
              "reset": null,
              "name": "SERNUM6",
              "offset": "0x09",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 7",
              "reset": null,
              "name": "SERNUM7",
              "offset": "0x0A",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 8",
              "reset": null,
              "name": "SERNUM8",
              "offset": "0x0B",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Serial Number Byte 9",
              "reset": null,
              "name": "SERNUM9",
              "offset": "0x0C",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Temperature Sensor Calibration Byte 0",
              "reset": null,
              "name": "TEMPSENSE0",
              "offset": "0x20",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Temperature Sensor Calibration Byte 1",
              "reset": null,
              "name": "TEMPSENSE1",
              "offset": "0x21",
              "rw": "R",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            }
          ]
        }
      ]
    },
    {
      "caption": "Sleep Controller",
      "id": "I2112",
      "name": "SLPCTRL",
      "register_groups": [
        {
          "caption": "Sleep Controller",
          "name": "SLPCTRL",
          "size": "0x2",
          "registers": [
            {
              "caption": "Control",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Sleep enable",
                  "mask": "0x1",
                  "name": "SEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit must be written to '1' before the SLEEP instruction is executed to make the MCU enter the\nselected sleep mode."
                },
                {
                  "caption": "Sleep mode",
                  "mask": "0x6",
                  "name": "SMODE",
                  "rw": "RW",
                  "values_ref": "SLPCTRL_SMODE",
                  "description": "Writing these bits selects the sleep mode entered when the Sleep Enable bit (SEN) is written to '1' and\nthe SLEEP instruction is executed.\n\n\n| Value | Name    | Description                   |\n| :---- | :------ | :---------------------------- |\n| 0x0   | IDLE    | Idle Sleep mode enabled       |\n| 0x1   | STANDBY | Standby Sleep mode enabled    |\n| 0x2   | PDOWN   | Power-Down Sleep mode enabled |\n| other | -       | Reserved                      |\n\n"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Serial Peripheral Interface",
      "id": "I2107",
      "name": "SPI",
      "register_groups": [
        {
          "caption": "Serial Peripheral Interface",
          "name": "SPI",
          "size": "0x8",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable Double Speed",
                  "mask": "0x10",
                  "name": "CLK2X",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1' the SPI speed (SCK frequency, after internal prescaler) is doubled in Master\nmode.\n\n\n| Value | Description                                         |\n| :---- | :-------------------------------------------------- |\n| 0     | SPI speed (SCK frequency) is not doubled            |\n| 1     | SPI speed (SCK frequency) is doubled in Master mode |\n\n"
                },
                {
                  "caption": "Data Order Setting",
                  "mask": "0x40",
                  "name": "DORD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                   |\n| :---- | :-------------------------------------------- |\n| 0     | The MSB of the data word is transmitted first |\n| 1     | The LSB of the data word is transmitted first |\n\n"
                },
                {
                  "caption": "Enable Module",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description     |\n| :---- | :-------------- |\n| 0     | SPI is disabled |\n| 1     | SPI is enabled  |\n\n"
                },
                {
                  "caption": "Master Operation Enable",
                  "mask": "0x20",
                  "name": "MASTER",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Write this bit to configure SPI in desired mode.\nIf SS is configured as input and driven low while this bit is '1', this bit is cleared, and the IF flag in\nSPIn.INTFLAGS is set. The user has to write MASTER=1 again to re-enable SPI Master mode.\nThis behavior is controlled by the Slave Select Disable bit (SSD) in SPIn.CTRLB.\n\n\n| Value | Description              |\n| :---- | :----------------------- |\n| 0     | SPI Slave mode selected  |\n| 1     | SPI Master mode selected |\n\n"
                },
                {
                  "caption": "Prescaler",
                  "mask": "0x6",
                  "name": "PRESC",
                  "rw": "RW",
                  "values_ref": "SPI_PRESC",
                  "description": "This bit field controls the SPI clock rate configured in Master mode. These bits have no effect in Slave\nmode. The relationship between SCK and the peripheral clock frequency (f\nCLK_PER\n) is shown below.\nThe output of the SPI prescaler can be doubled by writing the CLK2X bit to '1'.\n\n\n| Value | Name   | Description |\n| :---- | :----- | :---------- |\n| 0x0   | DIV4   | CLK_PER/4   |\n| 0x1   | DIV16  | CLK_PER/16  |\n| 0x2   | DIV64  | CLK_PER/64  |\n| 0x3   | DIV128 | CLK_PER/128 |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Buffer Mode Enable",
                  "mask": "0x80",
                  "name": "BUFEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables Buffer mode, meaning two buffers in receive direction, one buffer in transmit\ndirection, and separate interrupt flags for both transmit complete and receive complete."
                },
                {
                  "caption": "Buffer Write Mode",
                  "mask": "0x40",
                  "name": "BUFWR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When writing this bit to '0' the first data transferred will be a dummy sample.\n\n\n| Value | Description                                                                                    |\n| :---- | :--------------------------------------------------------------------------------------------- |\n| 0     | One SPI transfer must be completed before the data is copied into the Shift register.          |\n| 1     | When writing to the data register when the SPI is enabled and SS is high, the first write will |\n\n\ngo directly to the Shift register."
                },
                {
                  "caption": "SPI Mode",
                  "mask": "0x3",
                  "name": "MODE",
                  "rw": "RW",
                  "values_ref": "SPI_MODE",
                  "description": "These bits select the Transfer mode. The four combinations of SCK phase and polarity with respect to the\nserial data are shown in the table below. These bits decide whether the first edge of a clock cycle (leading\nedge) is rising or falling and whether data setup and sample occur on the leading or trailing edge. When\nthe leading edge is rising, the SCK signal is low when idle, and when the leading edge is falling, the SCK\nsignal is high when idle.\n\n\n| Value | Name  | Description                  |\n| :---- | :---- | :--------------------------- |\n| 0x0   | 0     | Leading edge: Rising, sample |\n\n\nTrailing edge: Falling, setup\n0x1 1 Leading edge: Rising, setup\nTrailing edge: Falling, sample\n0x2 2 Leading edge: Falling, sample\nTrailing edge: Rising, setup\n0x3 3 Leading edge: Falling, setup\nTrailing edge: Rising, sample\nRelated Links\nData Modes"
                },
                {
                  "caption": "Slave Select Disable",
                  "mask": "0x4",
                  "name": "SSD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is set and when operating as SPI Master (MASTER=1 in SPIn.CTRLA), SS does not\ndisable Master mode.\n\n\n| Value | Description                                                |\n| :---- | :--------------------------------------------------------- |\n| 0     | Enable the Slave Select line when operating as SPI Master  |\n| 1     | Disable the Slave Select line when operating as SPI Master |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Data",
              "reset": null,
              "name": "DATA",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": null,
              "name": "INTCTRL",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Data Register Empty Interrupt Enable",
                  "mask": "0x20",
                  "name": "DREIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In Buffer mode this bit enables the data register empty interrupt. The enabled interrupt will be triggered\nwhen the DREIF flag in the SPIn.INTFLAGS register is set. In Non-Buffer mode, this bit is zero."
                },
                {
                  "caption": "Interrupt Enable",
                  "mask": "0x1",
                  "name": "IE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables the SPI interrupt when the SPI is not in Buffer mode. The enabled interrupt will be\ntriggered when RXCIF/IF is set in the SPIn.INTFLAGS register."
                },
                {
                  "caption": "Receive Complete Interrupt Enable",
                  "mask": "0x80",
                  "name": "RXCIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In Buffer mode, this bit enables the receive complete interrupt. The enabled interrupt will be triggered\nwhen the RXCIF flag in the SPIn.INTFLAGS register is set. In Non-Buffer mode this bit is zero."
                },
                {
                  "caption": "Slave Select Trigger Interrupt Enable",
                  "mask": "0x10",
                  "name": "SSIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In Buffer mode, this bit enables the Slave Select interrupt. The enabled interrupt will be triggered when\nthe SSIF flag in the SPIn.INTFLAGS register is set. In Non-Buffer mode, this bit is zero."
                },
                {
                  "caption": "Transfer Complete Interrupt Enable",
                  "mask": "0x40",
                  "name": "TXCIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In Buffer mode, this bit enables the transfer complete interrupt. The enabled interrupt will be triggered\nwhen the TXCIF flag in the SPIn.INTFLAGS register is set. In Non-Buffer mode, this bit is zero."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "System Configuration Registers",
      "id": "I2601",
      "name": "SYSCFG",
      "register_groups": [
        {
          "caption": "System Configuration Registers",
          "name": "SYSCFG",
          "size": "0x20",
          "registers": [
            {
              "caption": "External Break",
              "reset": "0x00",
              "name": "EXTBRK",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "External break enable",
                  "mask": "0x1",
                  "name": "ENEXTBRK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": null
                }
              ],
              "description": "Undocumented"
            },
            {
              "caption": "Revision ID",
              "reset": null,
              "name": "REVID",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "This register is read-only and displays the device revision ID."
            }
          ]
        }
      ]
    },
    {
      "caption": "16-bit Timer/Counter Type A",
      "id": "I2117",
      "name": "TCA",
      "register_groups": [
        {
          "caption": "16-bit Timer/Counter Type A - Single Mode",
          "name": "TCA_SINGLE",
          "size": "0x40",
          "registers": [
            {
              "caption": "Compare 0",
              "reset": null,
              "name": "CMP0",
              "offset": "0x28",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators\nare then used for generating waveforms.\nTCAn.CMPn registers are updated with the buffer value from their corresponding TCAn.CMPnBUF\nregister when an UPDATE condition occurs.\nThe TCAn.CMPnL and TCAn.CMPnH register pair represents the 16-bit value, TCAn.CMPn. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at\noffset + 0x01."
            },
            {
              "caption": "Compare 0 Buffer",
              "reset": null,
              "name": "CMP0BUF",
              "offset": "0x38",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register serves as the buffer for the associated compare registers (TCAn.CMPn). Accessing any of\nthese registers using the CPU or UPDI will affect the corresponding CMPnBV status bit.\nThe TCAn.CMPnBUFL and TCAn.CMPnBUFH register pair represents the 16-bit value, TCAn.CMPnBUF.\nThe low byte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be\naccessed at offset + 0x01."
            },
            {
              "caption": "Compare 1",
              "reset": null,
              "name": "CMP1",
              "offset": "0x2A",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators\nare then used for generating waveforms.\nTCAn.CMPn registers are updated with the buffer value from their corresponding TCAn.CMPnBUF\nregister when an UPDATE condition occurs.\nThe TCAn.CMPnL and TCAn.CMPnH register pair represents the 16-bit value, TCAn.CMPn. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at\noffset + 0x01."
            },
            {
              "caption": "Compare 1 Buffer",
              "reset": null,
              "name": "CMP1BUF",
              "offset": "0x3A",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register serves as the buffer for the associated compare registers (TCAn.CMPn). Accessing any of\nthese registers using the CPU or UPDI will affect the corresponding CMPnBV status bit.\nThe TCAn.CMPnBUFL and TCAn.CMPnBUFH register pair represents the 16-bit value, TCAn.CMPnBUF.\nThe low byte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be\naccessed at offset + 0x01."
            },
            {
              "caption": "Compare 2",
              "reset": null,
              "name": "CMP2",
              "offset": "0x2C",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators\nare then used for generating waveforms.\nTCAn.CMPn registers are updated with the buffer value from their corresponding TCAn.CMPnBUF\nregister when an UPDATE condition occurs.\nThe TCAn.CMPnL and TCAn.CMPnH register pair represents the 16-bit value, TCAn.CMPn. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at\noffset + 0x01."
            },
            {
              "caption": "Compare 2 Buffer",
              "reset": null,
              "name": "CMP2BUF",
              "offset": "0x3C",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register serves as the buffer for the associated compare registers (TCAn.CMPn). Accessing any of\nthese registers using the CPU or UPDI will affect the corresponding CMPnBV status bit.\nThe TCAn.CMPnBUFL and TCAn.CMPnBUFH register pair represents the 16-bit value, TCAn.CMPnBUF.\nThe low byte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be\naccessed at offset + 0x01."
            },
            {
              "caption": "Count",
              "reset": null,
              "name": "CNT",
              "offset": "0x20",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The TCAn.CNTL and TCAn.CNTH register pair represents the 16-bit value, TCAn.CNT. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset +\n0x01.\nCPU and UPDI write access has priority over internal updates of the register."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Selection",
                  "mask": "0xe",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_CLKSEL",
                  "description": "These bits select the clock frequency for the timer/counter.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0x0   | DIV1  | f           |\n\n\nTCA\n= f\nCLK_PER\n/1\n0x1 DIV2 f\nTCA\n= f\nCLK_PER\n/2\n0x2 DIV4 f\nTCA\n= f\nCLK_PER\n/4\n0x3 DIV8 f\nTCA\n= f\nCLK_PER\n/8\n0x4 DIV16 f\nTCA\n= f\nCLK_PER\n/16\n0x5 DIV64 f\nTCA\n= f\nCLK_PER\n/64\n0x6 DIV256 f\nTCA\n= f\nCLK_PER\n/256\n0x7 DIV1024 f\nTCA\n= f\nCLK_PER\n/1024"
                },
                {
                  "caption": "Module Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | The peripheral is disabled |\n| 1     | The peripheral is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Auto Lock Update",
                  "mask": "0x8",
                  "name": "ALUPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Auto-Lock Update feature controls the Lock Update (LUPD) bit in the TCAn.CTRLE register. When\nALUPD is written to '1', LUPD will be set to '1' until the Buffer Valid (CMPnBV) bits of all enabled compare\nchannels are '1'. This condition will clear LUPD.\nIt will remain cleared until the next UPDATE condition, where the buffer values will be transferred to the\nCMPn registers and LUPD will be set to '1' again. This makes sure that CMPnBUF register values are not\ntransferred to the CMPn registers until all enabled compare buffers are written.\n\n\n| Value | Description                                     |\n| :---- | :---------------------------------------------- |\n| 0     | LUPD in TCA.CTRLE not altered by system         |\n| 1     | LUPD in TCA.CTRLE set and cleared automatically |\n\n"
                },
                {
                  "caption": "Compare 0 Enable",
                  "mask": "0x10",
                  "name": "CMP0EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In the FRQ or PWM Waveform Generation mode, these bits will override the PORT output register for the\ncorresponding pin.\n\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | Port output settings for the pin with WOn output respected                     |\n| 1     | Port output settings for pin with WOn output overridden in FRQ or PWM Waveform |\n\n\nGeneration mode"
                },
                {
                  "caption": "Compare 1 Enable",
                  "mask": "0x20",
                  "name": "CMP1EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In the FRQ or PWM Waveform Generation mode, these bits will override the PORT output register for the\ncorresponding pin.\n\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | Port output settings for the pin with WOn output respected                     |\n| 1     | Port output settings for pin with WOn output overridden in FRQ or PWM Waveform |\n\n\nGeneration mode"
                },
                {
                  "caption": "Compare 2 Enable",
                  "mask": "0x40",
                  "name": "CMP2EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "In the FRQ or PWM Waveform Generation mode, these bits will override the PORT output register for the\ncorresponding pin.\n\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | Port output settings for the pin with WOn output respected                     |\n| 1     | Port output settings for pin with WOn output overridden in FRQ or PWM Waveform |\n\n\nGeneration mode"
                },
                {
                  "caption": "Waveform generation mode",
                  "mask": "0x7",
                  "name": "WGMODE",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_WGMODE",
                  "description": "These bits select the Waveform Generation mode and control the counting sequence of the counter, TOP\nvalue, UPDATE condition, interrupt condition, and type of waveform that is generated.\nNo waveform generation is performed in the Normal mode of operation. For all other modes, the result\nfrom the waveform generator will only be directed to the port pins if the corresponding CMPnEN bit has\nbeen set to enable this. The port pin direction must be set as output.\nTable 20-5. Timer Waveform Generation Mode\nWGMODE[2:0] Group Configuration Mode of Operation Top Update OVF\n000 NORMAL Normal PER TOP TOP\n001 FRQ Frequency CMP0 TOP TOP\n010 - Reserved - - -\n011 SINGLESLOPE Single-slope PWM PER BOTTOM BOTTOM\nWGMODE[2:0] Group Configuration Mode of Operation Top Update OVF\n100 - Reserved - - -\n101 DSTOP Dual-slope PWM PER BOTTOM TOP\n110 DSBOTH Dual-slope PWM PER BOTTOM TOP and BOTTOM\n111 DSBOTTOM Dual-slope PWM PER BOTTOM BOTTOM\n\n\n| Value | Name        | Description           |\n| :---- | :---------- | :-------------------- |\n| 0x0   | NORMAL      | Normal operation mode |\n| 0x1   | FRQ         | Frequency mode        |\n| 0x3   | SINGLESLOPE | Single-slope PWM mode |\n| 0x5   | DSTOP       | Dual-slope PWM mode   |\n| 0x6   | DSBOTH      | Dual-slope PWM mode   |\n| 0x7   | DSBOTTOM    | Dual-slope PWM mode   |\n| Other | -           | Reserved              |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Waveform Output Value",
                  "mask": "0x1",
                  "name": "CMP0OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The CMPnOV bits allow direct access to the waveform generator's output compare value when the timer/\ncounter is not enabled. This is used to set or clear the WG output value when the timer/counter is not\nrunning."
                },
                {
                  "caption": "Compare 1 Waveform Output Value",
                  "mask": "0x2",
                  "name": "CMP1OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0OV."
                },
                {
                  "caption": "Compare 2 Waveform Output Value",
                  "mask": "0x4",
                  "name": "CMP2OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0OV."
                }
              ],
              "description": null
            },
            {
              "caption": "Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Split Mode Enable",
                  "mask": "0x1",
                  "name": "SPLITM",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit sets the timer/counter in Split mode operation. It will then work as two 8-bit timer/counters. The\nregister map will change compared to normal 16-bit mode."
                }
              ],
              "description": null
            },
            {
              "caption": "Control E Clear",
              "reset": "0x00",
              "name": "CTRLECLR",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0xc",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_CMD",
                  "description": "These bits are used for software control of update, restart, and reset of the timer/counter. The command\nbits are always read as zero.\n\n\n| Value | Name    | Description                                 |\n| :---- | :------ | :------------------------------------------ |\n| 0x0   | NONE    | No command                                  |\n| 0x1   | UPDATE  | Force update                                |\n| 0x2   | RESTART | Force restart                               |\n| 0x3   | RESET   | Force hard Reset (ignored if TC is enabled) |\n\n"
                },
                {
                  "caption": "Direction",
                  "mask": "0x1",
                  "name": "DIR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Normally this bit is controlled in hardware by the Waveform Generation mode or by event actions, but this\nbit can also be changed from software.\n\n\n| Value | Description                                 |\n| :---- | :------------------------------------------ |\n| 0     | The counter is counting up (incrementing)   |\n| 1     | The counter is counting down (decrementing) |\n\n"
                },
                {
                  "caption": "Lock Update",
                  "mask": "0x2",
                  "name": "LUPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Lock update can be used to ensure that all buffers are valid before an update is performed.\n\n\n| Value | Description                                                                           |\n| :---- | :------------------------------------------------------------------------------------ |\n| 0     | The buffered registers are updated as soon as an UPDATE condition has occurred.       |\n| 1     | No update of the buffered registers is performed, even though an UPDATE condition has |\n\n\noccurred."
                }
              ],
              "description": "The individual Status bit can be cleared by writing a one to its bit location. This allows each bit to be\ncleared without the use of a read-modify-write operation on a single register.\nEach Status bit can be read out either by reading TCAn.CTRLESET or TCAn.CTRLECLR."
            },
            {
              "caption": "Control E Set",
              "reset": "0x00",
              "name": "CTRLESET",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0xc",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_CMD",
                  "description": "These bits are used for software control of update, restart, and reset the timer/counter. The command bits\nare always read as zero.\n\n\n| Value | Name    | Description                                 |\n| :---- | :------ | :------------------------------------------ |\n| 0x0   | NONE    | No command                                  |\n| 0x1   | UPDATE  | Force update                                |\n| 0x2   | RESTART | Force restart                               |\n| 0x3   | RESET   | Force hard Reset (ignored if TC is enabled) |\n\n"
                },
                {
                  "caption": "Direction",
                  "mask": "0x1",
                  "name": "DIR",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_DIR",
                  "description": "Normally this bit is controlled in hardware by the Waveform Generation mode or by event actions, but this\nbit can also be changed from software.\n\n\n| Value | Description                                 |\n| :---- | :------------------------------------------ |\n| 0     | The counter is counting up (incrementing)   |\n| 1     | The counter is counting down (decrementing) |\n\n"
                },
                {
                  "caption": "Lock Update",
                  "mask": "0x2",
                  "name": "LUPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Locking the update ensures that all buffers are valid before an update is performed.\n\n\n| Value | Description                                                                           |\n| :---- | :------------------------------------------------------------------------------------ |\n| 0     | The buffered registers are updated as soon as an UPDATE condition has occurred.       |\n| 1     | No update of the buffered registers is performed, even though an UPDATE condition has |\n\n\noccurred."
                }
              ],
              "description": "The individual Status bit can be set by writing a '1' to its bit location. This allows each bit to be set without\nthe use of a read-modify-write operation on a single register.\nEach Status bit can be read out either by reading TCAn.CTRLESET or TCAn.CTRLECLR."
            },
            {
              "caption": "Control F Clear",
              "reset": "0x00",
              "name": "CTRLFCLR",
              "offset": "0x06",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Buffer Valid",
                  "mask": "0x2",
                  "name": "CMP0BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The CMPnBV bits are set when a new value is written to the corresponding TCAn.CMPnBUF register.\nThese bits are automatically cleared on an UPDATE condition."
                },
                {
                  "caption": "Compare 1 Buffer Valid",
                  "mask": "0x4",
                  "name": "CMP1BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0BV."
                },
                {
                  "caption": "Compare 2 Buffer Valid",
                  "mask": "0x8",
                  "name": "CMP2BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0BV."
                },
                {
                  "caption": "Period Buffer Valid",
                  "mask": "0x1",
                  "name": "PERBV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set when a new value is written to the TCAn.PERBUF register. This bit is automatically cleared\non an UPDATE condition."
                }
              ],
              "description": "The individual Status bit can be cleared by writing a '1' to its bit location. This allows each bit to be\ncleared without the use of a read-modify-write operation on a single register."
            },
            {
              "caption": "Control F Set",
              "reset": "0x00",
              "name": "CTRLFSET",
              "offset": "0x07",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Buffer Valid",
                  "mask": "0x2",
                  "name": "CMP0BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The CMPnBV bits are set when a new value is written to the corresponding TCAn.CMPnBUF register.\nThese bits are automatically cleared on an UPDATE condition."
                },
                {
                  "caption": "Compare 1 Buffer Valid",
                  "mask": "0x4",
                  "name": "CMP1BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0BV."
                },
                {
                  "caption": "Compare 2 Buffer Valid",
                  "mask": "0x8",
                  "name": "CMP2BV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0BV."
                },
                {
                  "caption": "Period Buffer Valid",
                  "mask": "0x1",
                  "name": "PERBV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set when a new value is written to the TCAn.PERBUF register. This bit is automatically cleared\non an UPDATE condition."
                }
              ],
              "description": "The individual status bit can be set by writing a one to its bit location. This allows each bit to be set\nwithout the use of a read-modify-write operation on a single register."
            },
            {
              "caption": "Degbug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x0E",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Event Control",
              "reset": "0x00",
              "name": "EVCTRL",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Count on Event Input",
                  "mask": "0x1",
                  "name": "CNTEI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                     |\n| :---- | :-------------------------------------------------------------- |\n| 0     | Counting on Event input is disabled                             |\n| 1     | Counting on Event input is enabled according to EVACT bit field |\n\n"
                },
                {
                  "caption": "Event Action",
                  "mask": "0x6",
                  "name": "EVACT",
                  "rw": "RW",
                  "values_ref": "TCA_SINGLE_EVACT",
                  "description": "These bits define what type of event action the counter will increment or decrement.\nValue Name Description\n0x0 EVACT_POSEDGE Count on positive edge event\n0x1 EVACT_ANYEDGE Count on any edge event\n0x2 EVACT_HIGHLVL Count on prescaled clock while event line is 1.\n0x3 EVACT_UPDOWN Count on prescaled clock. The Event controls the count direction. Up-\ncounting when the event line is 0, down-counting when the event line is"
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Interrupt",
                  "mask": "0x10",
                  "name": "CMP0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing CMPn bit to '1' enables compare interrupt from channel n."
                },
                {
                  "caption": "Compare 1 Interrupt",
                  "mask": "0x20",
                  "name": "CMP1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0."
                },
                {
                  "caption": "Compare 2 Interrupt",
                  "mask": "0x40",
                  "name": "CMP2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0."
                },
                {
                  "caption": "Overflow Interrupt",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing OVF bit to '1' enables overflow interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Compare 0 Interrupt",
                  "mask": "0x10",
                  "name": "CMP0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Compare Interrupt flag (CMPn) is set on a compare match on the corresponding compare channel.\nFor all modes of operation, the CMPn flag will be set when a compare match occurs between the Count\nregister (TCAn.CNT) and the corresponding Compare register (TCAn.CMPn). The CMPn flag will not be\ncleared automatically and has to be cleared by software. This is done by writing a one to its bit location."
                },
                {
                  "caption": "Compare 1 Interrupt",
                  "mask": "0x20",
                  "name": "CMP1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0 flag description."
                },
                {
                  "caption": "Compare 2 Interrupt",
                  "mask": "0x40",
                  "name": "CMP2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See CMP0 flag description."
                },
                {
                  "caption": "Overflow Interrupt",
                  "mask": "0x1",
                  "name": "OVF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set either on a TOP (overflow) or BOTTOM (underflow) condition, depending on the\nWGMODE setting. OVF is not automatically cleared and needs to be cleared by software. This is done by\nwriting a one to its bit location."
                }
              ],
              "description": "The individual Status bit can be cleared by writing a '1' to its bit location. This allows each bit to be set\nwithout the use of a read-modify-write operation on a single register."
            },
            {
              "caption": "Period",
              "reset": null,
              "name": "PER",
              "offset": "0x26",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "TCAn.PER contains the 16-bit TOP value in the timer/counter.\nThe TCAn.PERL and TCAn.PERH register pair represents the 16-bit value, TCAn.PER. The low byte\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\n+ 0x01."
            },
            {
              "caption": "Period Buffer",
              "reset": null,
              "name": "PERBUF",
              "offset": "0x36",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "This register serves as the buffer for the period register (TCAn.PER). Accessing this register using the\nCPU or UPDI will affect the PERBV flag.\nThe TCAn.PERBUFL and TCAn.PERBUFH register pair represents the 16-bit value, TCAn.PERBUF. The\nlow byte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed\nat offset + 0x01."
            },
            {
              "caption": "Temporary data for 16-bit Access",
              "reset": null,
              "name": "TEMP",
              "offset": "0x0F",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this\nperipheral. It can be read and written by software. There is one common Temporary register for all the 16-\nbit registers of this peripheral."
            }
          ]
        },
        {
          "caption": "16-bit Timer/Counter Type A - Split Mode",
          "name": "TCA_SPLIT",
          "size": "0x40",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Selection",
                  "mask": "0xe",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "TCA_SPLIT_CLKSEL",
                  "description": "These bits select the clock frequency for the timer/counter.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0x0   | DIV1  | f           |\n\n\nTCA\n= f\nCLK_PER\n/1\n0x1 DIV2 f\nTCA\n= f\nCLK_PER\n/2\n0x2 DIV4 f\nTCA\n= f\nCLK_PER\n/4\n0x3 DIV8 f\nTCA\n= f\nCLK_PER\n/8\n0x4 DIV16 f\nTCA\n= f\nCLK_PER\n/16\n0x5 DIV64 f\nTCA\n= f\nCLK_PER\n/64\n0x6 DIV256 f\nTCA\n= f\nCLK_PER\n/256\n0x7 DIV1024 f\nTCA\n= f\nCLK_PER\n/1024"
                },
                {
                  "caption": "Module Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                |\n| :---- | :------------------------- |\n| 0     | The peripheral is disabled |\n| 1     | The peripheral is enabled  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "High Compare 0 Enable",
                  "mask": "0x10",
                  "name": "HCMP0EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0EN."
                },
                {
                  "caption": "High Compare 1 Enable",
                  "mask": "0x20",
                  "name": "HCMP1EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0."
                },
                {
                  "caption": "High Compare 2 Enable",
                  "mask": "0x40",
                  "name": "HCMP2EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0."
                },
                {
                  "caption": "Low Compare 0 Enable",
                  "mask": "0x1",
                  "name": "LCMP0EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Setting the LCMPnEN/HCMPnEN bits in the FRQ or PWM Waveform Generation mode of operation will\noverride the port output register for the corresponding WOn pin."
                },
                {
                  "caption": "Low Compare 1 Enable",
                  "mask": "0x2",
                  "name": "LCMP1EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0EN."
                },
                {
                  "caption": "Low Compare 2 Enable",
                  "mask": "0x4",
                  "name": "LCMP2EN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0EN."
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x00",
              "name": "CTRLC",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "High Compare 0 Output Value",
                  "mask": "0x10",
                  "name": "HCMP0OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0OV."
                },
                {
                  "caption": "High Compare 1 Output Value",
                  "mask": "0x20",
                  "name": "HCMP1OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0."
                },
                {
                  "caption": "High Compare 2 Output Value",
                  "mask": "0x40",
                  "name": "HCMP2OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0."
                },
                {
                  "caption": "Low Compare 0 Output Value",
                  "mask": "0x1",
                  "name": "LCMP0OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The LCMPnOV/HCMPn bits allow direct access to the waveform generator's output compare value when\nthe timer/counter is not enabled. This is used to set or clear the WOn output value when the timer/counter\nis not running."
                },
                {
                  "caption": "Low Compare 1 Output Value",
                  "mask": "0x2",
                  "name": "LCMP1OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0OV."
                },
                {
                  "caption": "Low Compare 2 Output Value",
                  "mask": "0x4",
                  "name": "LCMP2OV",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0OV."
                }
              ],
              "description": null
            },
            {
              "caption": "Control D",
              "reset": "0x00",
              "name": "CTRLD",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Split Mode Enable",
                  "mask": "0x1",
                  "name": "SPLITM",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit sets the timer/counter in Split mode operation. It will then work as two 8-bit timer/counters. The\nregister map will change compared to normal 16-bit mode."
                }
              ],
              "description": null
            },
            {
              "caption": "Control E Clear",
              "reset": "0x00",
              "name": "CTRLECLR",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0xc",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "TCA_SPLIT_CMD",
                  "description": "These bits are used for software control of update, restart, and reset of the timer/counter. The command\nbits are always read as zero.\n\n\n| Value | Name    | Description                                 |\n| :---- | :------ | :------------------------------------------ |\n| 0x0   | NONE    | No command                                  |\n| 0x1   | -       | Reserved                                    |\n| 0x2   | RESTART | Force restart                               |\n| 0x3   | RESET   | Force hard Reset (ignored if TC is enabled) |\n\n"
                }
              ],
              "description": "The individual Status bit can be cleared by writing a '1' to its bit location. This allows each bit to be\ncleared without the use of a read-modify-write operation on a single register."
            },
            {
              "caption": "Control E Set",
              "reset": "0x00",
              "name": "CTRLESET",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Command",
                  "mask": "0xc",
                  "name": "CMD",
                  "rw": "RW",
                  "values_ref": "TCA_SPLIT_CMD",
                  "description": "These bits are used for software control of update, restart, and reset of the timer/counter. The command\nbits are always read as zero. The CMD bits must be used together with CMDEN. Using the reset\ncommand requires that both low-byte and high-byte timer/counter is selected.\n\n\n| Value | Name    | Description                                 |\n| :---- | :------ | :------------------------------------------ |\n| 0x0   | NONE    | No command                                  |\n| 0x1   | -       | Reserved                                    |\n| 0x2   | RESTART | Force restart                               |\n| 0x3   | RESET   | Force hard Reset (ignored if TC is enabled) |\n\n"
                }
              ],
              "description": "The individual Status bit can be set by writing a '1' to its bit location. This allows each bit to be set without\nthe use of a read-modify-write operation on a single register."
            },
            {
              "caption": "Degbug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x0E",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                    |\n| :---- | :----------------------------------------------------------------------------- |\n| 0     | The peripheral is halted in Break Debug mode and ignores events                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "High Compare",
              "reset": null,
              "name": "HCMP0",
              "offset": "0x29",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "High Compare",
              "reset": null,
              "name": "HCMP1",
              "offset": "0x2B",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "High Compare",
              "reset": null,
              "name": "HCMP2",
              "offset": "0x2D",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "High Count",
              "reset": null,
              "name": "HCNT",
              "offset": "0x21",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "TCAn.HCNT contains the counter value in high byte timer. CPU and UPDI write access has priority over\ncount, clear, or reload of the counter."
            },
            {
              "caption": "High Period",
              "reset": null,
              "name": "HPER",
              "offset": "0x27",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "The TCAn.HPER register contains the TOP value of high byte timer."
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "High Underflow Interrupt Enable",
                  "mask": "0x2",
                  "name": "HUNF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing HUNF bit to '1' enables high byte underflow interrupt."
                },
                {
                  "caption": "Low Compare 0 Interrupt Enable",
                  "mask": "0x10",
                  "name": "LCMP0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing LCMPn bit to '1' enables low byte compare interrupt from channel n."
                },
                {
                  "caption": "Low Compare 1 Interrupt Enable",
                  "mask": "0x20",
                  "name": "LCMP1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0."
                },
                {
                  "caption": "Low Compare 2 Interrupt Enable",
                  "mask": "0x40",
                  "name": "LCMP2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0."
                },
                {
                  "caption": "Low Underflow Interrupt Enable",
                  "mask": "0x1",
                  "name": "LUNF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing HUNF bit to '1' enables low byte underflow interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "High Underflow Interrupt Flag",
                  "mask": "0x2",
                  "name": "HUNF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set on a high byte timer BOTTOM (underflow) condition. HUNF is not automatically cleared\nand needs to be cleared by software. This is done by writing a '1' to its bit location."
                },
                {
                  "caption": "Low Compare 2 Interrupt Flag",
                  "mask": "0x10",
                  "name": "LCMP0",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The Compare Interrupt flag (LCMPn) is set on a compare match on the corresponding compare channel.\nFor all modes of operation, the LCMPn flag will be set when a compare match occurs between the Low\nByte Count register (TCAn.LCNT) and the corresponding compare register (TCAn.LCMPn). The LCMPn\nflag will not be cleared automatically and has to be cleared by software. This is done by writing a '1' to its\nbit location."
                },
                {
                  "caption": "Low Compare 1 Interrupt Flag",
                  "mask": "0x20",
                  "name": "LCMP1",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0 flag description."
                },
                {
                  "caption": "Low Compare 0 Interrupt Flag",
                  "mask": "0x40",
                  "name": "LCMP2",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "See LCMP0 flag description."
                },
                {
                  "caption": "Low Underflow Interrupt Flag",
                  "mask": "0x1",
                  "name": "LUNF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set on a low byte timer BOTTOM (underflow) condition. LUNF is not automatically cleared and\nneeds to be cleared by software. This is done by writing a '1' to its bit location."
                }
              ],
              "description": "The individual Status bit can be cleared by writing a '1' to its bit location. This allows each bit to be set\nwithout the use of a read-modify-write operation on a single register."
            },
            {
              "caption": "Low Compare",
              "reset": null,
              "name": "LCMP0",
              "offset": "0x28",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Low Compare",
              "reset": null,
              "name": "LCMP1",
              "offset": "0x2A",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Low Compare",
              "reset": null,
              "name": "LCMP2",
              "offset": "0x2C",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "Low Count",
              "reset": null,
              "name": "LCNT",
              "offset": "0x20",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "TCAn.LCNT contains the counter value in low byte timer. CPU and UPDI write access has priority over\ncount, clear, or reload of the counter."
            },
            {
              "caption": "Low Period",
              "reset": null,
              "name": "LPER",
              "offset": "0x26",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "The TCAn.LPER register contains the TOP value of low byte timer."
            }
          ]
        }
      ]
    },
    {
      "caption": "16-bit Timer Type B",
      "id": "I2119",
      "name": "TCB",
      "register_groups": [
        {
          "caption": "16-bit Timer Type B",
          "name": "TCB",
          "size": "0x10",
          "registers": [
            {
              "caption": "Compare or Capture",
              "reset": null,
              "name": "CCMP",
              "offset": "0xC",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The TCBn.CCMPL and TCBn.CCMPH register pair represents the 16-bit value TCBn.CCMP. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at\noffset + 0x01.\nThis register has different functions depending on the mode of operation:\n* For capture operation, these registers contain the captured value of the counter at the time the\ncapture occurs\n* In periodic interrupt/time-out and Single-Shot mode, this register acts as the TOP value\n* In 8-bit PWM mode, TCBn.CCMPL and TCBn.CCMPH act as two independent registers"
            },
            {
              "caption": "Count",
              "reset": "0x0000",
              "name": "CNT",
              "offset": "0xA",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The TCBn.CNTL and TCBn.CNTH register pair represents the 16-bit value TCBn.CNT. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset +\n0x01.\nCPU and UPDI write access has priority over internal updates of the register."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Clock Select",
                  "mask": "0x6",
                  "name": "CLKSEL",
                  "rw": "RW",
                  "values_ref": "TCB_CLKSEL",
                  "description": "Writing these bits selects the clock source for this peripheral.\n\n\n| Value | Description           |\n| :---- | :-------------------- |\n| 0x0   | CLK_PER               |\n| 0x1   | CLK_PER / 2           |\n| 0x2   | Use CLK_TCA from TCA0 |\n| 0x3   | Reserved              |\n\n"
                },
                {
                  "caption": "Enable",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the Timer/Counter type B peripheral."
                },
                {
                  "caption": "Run Standby",
                  "mask": "0x40",
                  "name": "RUNSTDBY",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit will enable the peripheral to run in Standby Sleep mode. Not applicable when\nCLKSEL is set to 0x2 (CLK_TCA)."
                },
                {
                  "caption": "Synchronize Update",
                  "mask": "0x10",
                  "name": "SYNCUPD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "When this bit is written to '1', the TCB will restart whenever the TCA0 counter is restarted."
                }
              ],
              "description": null
            },
            {
              "caption": "Control Register B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Asynchronous Enable",
                  "mask": "0x40",
                  "name": "ASYNC",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' will allow asynchronous updates of the TCB output signal in Single-Shot mode.\n\n\n| Value | Description                                              |\n| :---- | :------------------------------------------------------- |\n| 0     | The output will go HIGH when the counter actually starts |\n| 1     | The output will go HIGH when an event arrives            |\n\n"
                },
                {
                  "caption": "Pin Output Enable",
                  "mask": "0x10",
                  "name": "CCMPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is used to set the output value of the Compare/Capture Output.\n\n\n| Value | Description                              |\n| :---- | :--------------------------------------- |\n| 0     | Compare/Capture Output is zero           |\n| 1     | Compare/Capture Output has a valid value |\n\n"
                },
                {
                  "caption": "Pin Initial State",
                  "mask": "0x20",
                  "name": "CCMPINIT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is used to set the initial output value of the pin when a pin output is used.\n\n\n| Value | Description               |\n| :---- | :------------------------ |\n| 0     | Initial pin state is LOW  |\n| 1     | Initial pin state is HIGH |\n\n"
                },
                {
                  "caption": "Timer Mode",
                  "mask": "0x7",
                  "name": "CNTMODE",
                  "rw": "RW",
                  "values_ref": "TCB_CNTMODE",
                  "description": "Writing these bits selects the Timer mode.\n\n\n| Value | Description                                              |\n| :---- | :------------------------------------------------------- |\n| 0x0   | Periodic Interrupt mode                                  |\n| 0x1   | Time-out Check mode                                      |\n| 0x2   | Input Capture on Event mode                              |\n| 0x3   | Input Capture Frequency Measurement mode                 |\n| 0x4   | Input Capture Pulse-Width Measurement mode               |\n| 0x5   | Input Capture Frequency and Pulse-Width Measurement mode |\n| 0x6   | Single-Shot mode                                         |\n| 0x7   | 8-Bit PWM mode                                           |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Debug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                     |\n| :---- | :------------------------------------------------------------------------------ |\n| 0     | The peripheral is halted in Break Debug mode and ignores events.                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted. |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Event Control",
              "reset": "0x00",
              "name": "EVCTRL",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Event Input Enable",
                  "mask": "0x1",
                  "name": "CAPTEI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the input capture event."
                },
                {
                  "caption": "Event Edge",
                  "mask": "0x10",
                  "name": "EDGE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is used to select the event edge. The effect of this bit is dependent on the selected Count Mode\n(CNTMODE) in TCBn.CTRLB. \"-\" means that an event or edge has no effect in this mode.\nCount Mode EDGE Positive Edge Negative Edge\nPeriodic Interrupt mode 0 - -\n1 - -\nTimeout Check mode 0 Start counter Stop counter\n1 Stop counter Start counter\nInput Capture on Event mode 0 Input Capture, interrupt -\n1 - Input Capture, interrupt\nInput Capture Frequency\nMeasurement mode\n0 Input Capture, clear and\nrestart counter, interrupt\n-\n1 - Input Capture, clear and\nrestart counter, interrupt\nInput Capture Pulse-Width\nMeasurement mode\n0 Clear and restart counter Input Capture, interrupt\n1 Input Capture, interrupt Clear and restart counter\nInput Capture Frequency and\nPulse Width Measurement mode\n0 On 1st Positive: Clear and restart counter\nOn following Negative: Input Capture\n2nd Positive: Stop counter, interrupt\n1 On 1st Negative: Clear and restart counter\nOn following Positive: Input Capture\n2nd Negative: Stop counter, interrupt\nSingle-Shot mode 0 Start counter -\nCount Mode EDGE Positive Edge Negative Edge\n1 - Start counter\n8-Bit PWM mode 0 - -\n1 - -"
                },
                {
                  "caption": "Input Capture Noise Cancellation Filter",
                  "mask": "0x40",
                  "name": "FILTER",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the input capture noise cancellation unit."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Control",
              "reset": "0x00",
              "name": "INTCTRL",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Capture or Timeout",
                  "mask": "0x1",
                  "name": "CAPT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the Capture interrupt."
                }
              ],
              "description": null
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Capture or Timeout",
                  "mask": "0x1",
                  "name": "CAPT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set when an interrupt occurs. The interrupt conditions are dependent on the Counter Mode\n(CNTMODE) in TCBn.CTRLB.\nThis bit is cleared by writing a '1' to it or when the Capture register is read in Capture mode.\nCounter Mode Interrupt Set Condition\nPeriodic Interrupt mode Set when the counter reaches TOP\nTimeout Check mode Set when the counter reaches TOP\nInput Capture on Event mode Set when an event occurs and the Capture register is loaded, flag\nclears when capture is read\nInput Capture Frequency\nMeasurement mode\nSet on edge when the Capture register is loaded and count\ninitialized, flag clears when capture is read\nInput Capture Pulse-Width\nMeasurement mode\nSet on a edge when the Capture register is loaded, previous edge\ninitialized the count, flag clears when capture is read\nInput Capture Frequency and Pulse-\nWidth Measurement mode\nSet on second (positive or negative) edge when the counter is\nstopped, flag clears when capture is read\nSingle-Shot mode Set when counter reaches TOP\n8-Bit PWM mode Set when the counter reaches CCH"
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x7",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Run",
                  "mask": "0x1",
                  "name": "RUN",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When the counter is running, this bit is set to '1'. When the counter is stopped, this bit is cleared to '0'.\nThe bit is read-only and cannot be set by UPDI."
                }
              ],
              "description": null
            },
            {
              "caption": "Temporary Value",
              "reset": null,
              "name": "TEMP",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this\nperipheral. It can be read and written by software. There is one common Temporary register for all the 16-\nbit registers of this peripheral."
            }
          ]
        }
      ]
    },
    {
      "caption": "Two-Wire Interface",
      "id": "I2110",
      "name": "TWI",
      "register_groups": [
        {
          "caption": "Two-Wire Interface",
          "name": "TWI",
          "size": "0x10",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "FM Plus Enable",
                  "mask": "0x2",
                  "name": "FMPEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing these bits selects the 1 MHz bus speed (Fast mode plus, Fm+) for the TWI in default\nconfiguration.\n\n\n| Value | Description  |\n| :---- | :----------- |\n| 0     | Fm+ disabled |\n| 1     | Fm+ enabled  |\n\n"
                },
                {
                  "caption": "SDA Hold Time",
                  "mask": "0xc",
                  "name": "SDAHOLD",
                  "rw": "RW",
                  "values_ref": "TWI_SDAHOLD",
                  "description": "Writing these bits selects the SDA hold time.\nTable 25-3. SDA Hold Time\nSDAHOLD[1:0] Nominal Hold Time Hold Time Range Across\nAll Corners (ns)\nDescription\n0x0 OFF 0 Hold time off.\n0x1 50 ns 36 - 131 Backward compatible setting.\n0x2 300 ns 180 - 630 Meets SMBus specification under\ntypical conditions.\n0x3 500 ns 300 - 1050 Meets SMBus specification across\nall corners."
                },
                {
                  "caption": "SDA Setup Time",
                  "mask": "0x10",
                  "name": "SDASETUP",
                  "rw": "RW",
                  "values_ref": "TWI_SDASETUP",
                  "description": "By default, there are four clock cycles of setup time on SDA out signal while reading from the slave part\nof the TWI module. Writing this bit to '1' will change the setup time to eight clocks.\n\n\n| Value | Name  | Description                         |\n| :---- | :---- | :---------------------------------- |\n| 0     | 4CYC  | SDA setup time is four clock cycles |\n| 1     | 8CYC  | SDA setup time is eight clock cycle |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Debug Control Register",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                     |\n| :---- | :------------------------------------------------------------------------------ |\n| 0     | The peripheral is halted in Break Debug mode and ignores events.                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted. |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Master Address",
              "reset": null,
              "name": "MADDR",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Master Baurd Rate Control",
              "reset": null,
              "name": "MBAUD",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Master Control A",
              "reset": "0x00",
              "name": "MCTRLA",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Enable TWI Master",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the TWI as master."
                },
                {
                  "caption": "Quick Command Enable",
                  "mask": "0x10",
                  "name": "QCEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables Quick Command. When Quick Command is enabled, the corresponding\ninterrupt flag is set immediately after the slave acknowledges the address. At this point, the software can\neither issue a Stop command or a repeated Start by writing either the Command bits (CMD) in the Master\nControl B register (TWIn.MCTRLB) or the Master Address register (TWIn.MADDR)."
                },
                {
                  "caption": "Read Interrupt Enable",
                  "mask": "0x80",
                  "name": "RIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables interrupt on the Master Read Interrupt Flag (RIF) in the Master Status\nregister (TWIn.MSTATUS). A TWI Master read interrupt would be generated only if this bit, the RIF, and\nthe Global Interrupt Flag (I) in CPU.SREG are all '1'."
                },
                {
                  "caption": "Smart Mode Enable",
                  "mask": "0x2",
                  "name": "SMEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the Master Smart mode. When Smart mode is enabled, the acknowledge\naction is sent immediately after reading the Master Data (TWIn.MDATA) register."
                },
                {
                  "caption": "Inactive Bus Timeout",
                  "mask": "0xc",
                  "name": "TIMEOUT",
                  "rw": "RW",
                  "values_ref": "TWI_TIMEOUT",
                  "description": "Setting the inactive bus timeout (TIMEOUT) bits to a non-zero value will enable the inactive bus time-out\nsupervisor. If the bus is inactive for longer than the TIMEOUT setting, the bus state logic will enter the Idle\nstate.\n\n\n| Value | Name     | Description                                   |\n| :---- | :------- | :-------------------------------------------- |\n| 0x0   | DISABLED | Bus timeout disabled. I2C.                    |\n| 0x1   | 50US     | 50 \u00b5s - SMBus (assume baud is set to 100 kHz) |\n| 0x2   | 100US    | 100 \u00b5s (assume baud is set to 100 kHz)        |\n| 0x3   | 200US    | 200 \u00b5s (assume baud is set to 100 kHz)        |\n\n"
                },
                {
                  "caption": "Write Interrupt Enable",
                  "mask": "0x40",
                  "name": "WIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables interrupt on the Master Write Interrupt Flag (WIF) in the Master Status\nregister (TWIn.MSTATUS). A TWI Master write interrupt will be generated only if this bit, the WIF, and the\nGlobal Interrupt Flag (I) in CPU.SREG are all '1'."
                }
              ],
              "description": null
            },
            {
              "caption": "Master Control B",
              "reset": "0x00",
              "name": "MCTRLB",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Acknowledge Action",
                  "mask": "0x4",
                  "name": "ACKACT",
                  "rw": "RW",
                  "values_ref": "TWI_ACKACT",
                  "description": "This bit defines the master's behavior under certain conditions defined by the bus protocol state and\nsoftware interaction. The acknowledge action is performed when DATA is read, or when an execute\ncommand is written to the CMD bits.\nThe ACKACT bit is not a flag or strobe, but an ordinary read/write accessible register bit. The default\nACKACT for master read interrupt is \u201cSend ACK\u201d (0). For master write, the code will know that no\nacknowledge should be sent since it is itself sending data.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0     | Send ACK    |\n| 1     | Send NACK   |\n\n"
                },
                {
                  "caption": "Flush",
                  "mask": "0x8",
                  "name": "FLUSH",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit generates a strobe for one clock cycle disabling and then enabling the master.\nWriting '0' has no effect.\nThe purpose is to clear the internal state of master: For TWI master to transmit successfully, it is\nrecommended to write the Master Address register (TWIn.MADDR) first and then the Master Data\nregister (TWIn.MDATA).\nThe peripheral will transmit invalid data if TWIn.MDATA is written before TWIn.MADDR. To avoid this\ninvalid transmission, write '1' to this bit to clear both registers."
                },
                {
                  "caption": "Command",
                  "mask": "0x3",
                  "name": "MCMD",
                  "rw": "RW",
                  "values_ref": "TWI_MCMD",
                  "description": "The master command bits are strobes. These bits are always read as zero.\nWriting to these bits triggers a master operation as defined by the table below.\nTable 25-4. Command Settings\nMCMD[1:0] DIR Description\n0x0 X NOACT - No action\n0x1 X REPSTART - Execute Acknowledge Action succeeded by repeated Start.\n0x2 0 RECVTRANS - Execute Acknowledge Action succeeded by a byte read operation.\nMCMD[1:0] DIR Description\n1 Execute Acknowledge Action (no action) succeeded by a byte send operation.(1)\n0x3 X STOP - Execute Acknowledge Action succeeded by issuing a Stop condition.\nNote:"
                }
              ],
              "description": null
            },
            {
              "caption": "Master Data",
              "reset": null,
              "name": "MDATA",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Master Status",
              "reset": "0x00",
              "name": "MSTATUS",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Arbitration Lost",
                  "mask": "0x8",
                  "name": "ARBLOST",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If read as '1' this bit indicates that the master has lost arbitration while transmitting a high data or NACK\nbit, or while issuing a Start or repeated Start condition (S/Sr) on the bus.\nWriting a '1' to it will clear the ARBLOST flag. However, normal use of the TWI does not require the flag to\nbe cleared by this method. However, as for the CLKHOLD flag, clearing the ARBLOST flag is not required\nduring normal use of the TWI.\nClearing the ARBLOST bit will follow the same software interaction as the CLKHOLD flag.\nGiven the condition where the bus ownership is lost to another master, the software must either abort\noperation or resend the data packet. Either way, the next required software interaction is in both cases to\nwrite to the TWIn.MADDR register. A write access to the TWIn.MADDR register will then clear the\nARBLOST flag."
                },
                {
                  "caption": "Bus Error",
                  "mask": "0x4",
                  "name": "BUSERR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The BUSERR flag indicates that an illegal bus condition has occurred. An illegal bus condition is detected\nif a protocol violating Start (S), repeated Start (Sr), or Stop (P) is detected on the TWI bus lines. A Start\ncondition directly followed by a Stop condition is one example of protocol violation.\nWriting a '1' to this bit will clear the BUSERR. However, normal use of the TWI does not require the\nBUSERR to be cleared by this method.\nA robust TWI driver software design will treat the bus error flag similarly to the ARBLOST flag, assuming\nthe bus ownership is lost when the bus error flag is set. As for the ARBLOST flag, the next software\noperation of writing the TWIn.MADDR register will consequently clear the BUSERR flag. For bus error to\nbe detected, the bus state logic must be enabled and the system frequency must be 4x the SCL\nfrequency."
                },
                {
                  "caption": "Bus State",
                  "mask": "0x3",
                  "name": "BUSSTATE",
                  "rw": "RW",
                  "values_ref": "TWI_BUSSTATE",
                  "description": "These bits indicate the current TWI bus state as defined in the table below. After a System Reset or re-\nenabling, the TWI master bus state will be unknown. The change of bus state is dependent on bus\nactivity.\nWriting 0x1 to the BUSSTATE bits forces the bus state logic into its Idle state. However, the bus state\nlogic cannot be forced into any other state. When the master is disabled, the bus state is 'unknown'.\n\n\n| Value | Name    | Description               |\n| :---- | :------ | :------------------------ |\n| 0x0   | UNKNOWN | Unknown bus state         |\n| 0x1   | IDLE    | Bus is idle               |\n| 0x2   | OWNER   | This TWI controls the bus |\n| 0x3   | BUSY    | The bus is busy           |\n\n"
                },
                {
                  "caption": "Clock Hold",
                  "mask": "0x20",
                  "name": "CLKHOLD",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If read as '1', this bit indicates that the master is currently holding the TWI clock (SCL) low, stretching the\nTWI clock period.\nWriting a '1' to this bit will clear the CLKHOLD flag. However, normal use of the TWI does not require the\nCLKHOLD flag to be cleared by this method, since the flag is automatically cleared when accessing\nseveral other TWI registers. The CLKHOLD flag can be cleared by:"
                },
                {
                  "caption": "Read Interrupt Flag",
                  "mask": "0x80",
                  "name": "RIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set to '1' when the master byte read operation is successfully completed (i.e., no arbitration lost\nor bus error occurred during the operation). The read operation is triggered by software reading DATA or\nwriting to ADDR registers with bit ADDR[0] written to '1'. A slave device must have responded with an\nACK to the address and direction byte transmitted by the master for this flag to be set.\nWriting a '1' to this bit will clear the RIF. However, normal use of the TWI does not require the flag to be\ncleared by this method.\nClearing the RIF bit will follow the same software interaction as the CLKHOLD flag.\nThe RIF flag can generate a master read interrupt (see description of the RIEN control bit in the\nTWIn.MCTRLA register)."
                },
                {
                  "caption": "Received Acknowledge",
                  "mask": "0x10",
                  "name": "RXACK",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is read-only and contains the most recently received Acknowledge bit from the slave."
                },
                {
                  "caption": "Write Interrupt Flag",
                  "mask": "0x40",
                  "name": "WIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set when a master transmit address or byte write is completed, regardless of the occurrence of\na bus error or an arbitration lost condition.\nWriting a '1' to this bit will clear the WIF. However, normal use of the TWI does not require the flag to be\ncleared by this method.\nClearing the WIF bit will follow the same software interaction as the CLKHOLD flag.\nThe WIF flag can generate a master write interrupt (see description of the WIEN control bit in the\nTWIn.MCTRLA register)."
                }
              ],
              "description": "Normal TWI operation dictates that this register is regarded purely as a read-only register. Clearing any of\nthe status flags is done indirectly by accessing the Master Transmits Address (TWIn.MADDR), Master\nData register (TWIn.MDATA), or the Command bits (CMD) in the Master Control B register\n(TWIn.MCTRLB)."
            },
            {
              "caption": "Slave Address",
              "reset": null,
              "name": "SADDR",
              "offset": "0xC",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Slave Address Mask",
              "reset": null,
              "name": "SADDRMASK",
              "offset": "0xE",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Address Enable",
                  "mask": "0x1",
                  "name": "ADDREN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If this bit is written to '1', the slave address match logic responds to the two unique addresses in slave\nTWIn.SADDR and TWIn.SADDRMASK.\nIf this bit is '0', the TWIn.SADDRMASK register acts as a mask to the TWIn.SADDR register."
                },
                {
                  "caption": "Address Mask",
                  "mask": "0xfe",
                  "name": "ADDRMASK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The ADDRMASK register acts as a second address match register, or an address mask register\ndepending on the ADDREN setting.\nIf ADDREN is written to '0', ADDRMASK can be loaded with a 7-bit Slave Address mask. Each of the bits\nin the TWIn.SADDRMASK register can mask (disable) the corresponding address bits in the TWI slave\nAddress Register (TWIn.SADDR). If the mask bit is written to '1' then the address match logic ignores the\ncompare between the incoming address bit and the corresponding bit in slave TWIn.SADDR register. In\nother words, masked bits will always match.\nIf ADDREN is written to '1', the TWIn.SADDRMASK can be loaded with a second slave address in\naddition to the TWIn.SADDR register. In this mode, the slave will match on two unique addresses, one in\nTWIn.SADDR and the other in TWIn.SADDRMASK."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Control A",
              "reset": "0x00",
              "name": "SCTRLA",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Address/Stop Interrupt Enable",
                  "mask": "0x40",
                  "name": "APIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables interrupt on the Slave Address or Stop Interrupt Flag (APIF) in the Slave\nStatus register (TWIn.SSTATUS). A TWI slave Address or Stop interrupt will be generated only if the this\nbit, APIF, and the Global Interrupt Flag (I) in CPU.SREG are all '1'.\nThe slave stop interrupt shares the interrupt flag and vector with the slave address interrupt. The\nTWIn.SCTRAL.PIEN must be written to '1' in order for the APIF to be set on a stop condition and when\nthe interrupt occurs the TWIn.SSTATUS.AP bit will determine whether an address match or a stop\ncondition caused the interrupt."
                },
                {
                  "caption": "Data Interrupt Enable",
                  "mask": "0x80",
                  "name": "DIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables interrupt on the Slave Data Interrupt Flag (DIF) in the Slave Status register\n(TWIn.SSTATUS). A TWI slave data interrupt will be generated only if this bit, the DIF, and the Global\nInterrupt Flag (I) in CPU.SREG are all '1'."
                },
                {
                  "caption": "Enable TWI Slave",
                  "mask": "0x1",
                  "name": "ENABLE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the TWI slave."
                },
                {
                  "caption": "Stop Interrupt Enable",
                  "mask": "0x20",
                  "name": "PIEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables APIF to be set when a Stop condition occurs. To use this feature the system\nfrequency must be 4x the SCL frequency."
                },
                {
                  "caption": "Promiscuous Mode Enable",
                  "mask": "0x4",
                  "name": "PMEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If this bit is written to '1', the slave address match logic responds to all received addresses.\nIf this bit is written to '0', the address match logic uses the Slave Address register (TWIn.SADDR) to\ndetermine which address to recognize as the slaves own address."
                },
                {
                  "caption": "Smart Mode Enable",
                  "mask": "0x2",
                  "name": "SMEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the slave Smart mode. When the Smart mode is enabled, issuing a\ncommand with CMD or reading/writing DATA resets the interrupt and operation continues. If the Smart\nmode is disabled, the slave always waits for a CMD command before continuing."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Control B",
              "reset": "0x00",
              "name": "SCTRLB",
              "offset": "0xA",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Acknowledge Action",
                  "mask": "0x4",
                  "name": "ACKACT",
                  "rw": "RW",
                  "values_ref": "TWI_ACKACT",
                  "description": "This bit defines the slave's behavior under certain conditions defined by the bus protocol state and\nsoftware interaction. The table below lists the acknowledge procedure performed by the slave if action is\ninitiated by software. The acknowledge action is performed when TWIn.SDATA is read or written, or when\nan execute command is written to the CMD bits in this register.\nThe ACKACT bit is not a flag or strobe, but an ordinary read/write accessible register bit.\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0     | ACK   | Send ACK    |\n| 1     | NACK  | Send NACK   |\n\n"
                },
                {
                  "caption": "Command",
                  "mask": "0x3",
                  "name": "SCMD",
                  "rw": "RW",
                  "values_ref": "TWI_SCMD",
                  "description": "Unlike the acknowledge action bits, the Slave command bits are strobes. These bits always read as zero.\nWriting to these bits trigger a slave operation as defined in the table below.\nTable 25-5. Command Settings\nSCMD[1:0] DIR Description\n0x0 X NOACT - No action\n0x1 X Reserved\n0x2 - COMPTRANS Used to complete a transaction.\n0 Execute Acknowledge Action succeeded by waiting for any Start (S/Sr)\ncondition.\n1 Wait for any Start (S/Sr) condition.\n0x3 - RESPONSE Used in response to an address interrupt (APIF).\n0 Execute Acknowledge Action succeeded by reception of next byte.\n1 Execute Acknowledge Action succeeded by slave data interrupt.\nUsed in response to a data interrupt (DIF).\n0 Execute Acknowledge Action succeeded by reception of next byte.\n1 Execute a byte read operation followed by Acknowledge Action.\nThe acknowledge action bits and command bits can be written at the same time."
                }
              ],
              "description": null
            },
            {
              "caption": "Slave Data",
              "reset": null,
              "name": "SDATA",
              "offset": "0xD",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": null
            },
            {
              "caption": "Slave Status",
              "reset": "0x00",
              "name": "SSTATUS",
              "offset": "0xB",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Slave Address or Stop",
                  "mask": "0x1",
                  "name": "AP",
                  "rw": "R",
                  "values_ref": "TWI_AP",
                  "description": "When the TWI slave address or Stop Interrupt Flag (APIF) is set, this bit determines whether the interrupt\nis due to address detection or a Stop condition.\n\n\n| Value | Name  | Description                                       |\n| :---- | :---- | :------------------------------------------------ |\n| 0     | STOP  | A Stop condition generated the interrupt on APIF  |\n| 1     | ADR   | Address detection generated the interrupt on APIF |\n\n"
                },
                {
                  "caption": "Address/Stop Interrupt Flag",
                  "mask": "0x40",
                  "name": "APIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when the slave address match logic detects that a valid address has been received or by\na Stop condition. Writing a '1' to its bit location will clear the APIF. However, normal use of the TWI does\nnot require the flag to be cleared by this method since the flag is cleared using the same software\ninteractions as described for the DIF flag.\nThe APIF flag can be used to generate a slave address or stop interrupt (see the description of the AIEN\ncontrol bit in TWIn.CTRLA). Take special note of that the slave stop interrupt shares the interrupt vector\nwith slave address interrupt."
                },
                {
                  "caption": "Bus Error",
                  "mask": "0x4",
                  "name": "BUSERR",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The BUSERR flag indicates that an illegal bus condition has occurred. An illegal bus condition is detected\nif a protocol violating Start (S), Repeated Start (Sr), or Stop (P) is detected on the TWI bus lines. A Start\ncondition directly followed by a Stop condition is one example of protocol violation. Writing a '1' to its bit\nlocation will clear the BUSERR flag. However, normal use of the TWI does not require the BUSERR to be\ncleared by this method. A robust TWI driver software design will assume that the entire packet of data\nhas been corrupted and restart by waiting for a new Start condition (S). The TWI bus error detector is part\nof the TWI Master circuitry. For bus errors to be detected, the TWI Master must be enabled (ENABLE bit\nin TWIn.MCTRLA is '1'), and the system clock frequency must be at least four times the SCL frequency."
                },
                {
                  "caption": "Clock Hold",
                  "mask": "0x20",
                  "name": "CLKHOLD",
                  "rw": "R",
                  "values_ref": null,
                  "description": "If read as '1', the slave clock hold flag indicates that the slave is currently holding the TWI clock (SCL)\nlow, stretching the TWI clock period. This is a read-only bit that is set when an address or data interrupt is\nset. Resetting the corresponding interrupt will indirectly reset this flag."
                },
                {
                  "caption": "Collision",
                  "mask": "0x8",
                  "name": "COLL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "If read as '1', the transmit collision flag indicates that the slave has not been able to transmit a high data\nor NACK bit. If a slave transmit collision is detected, the slave will commence its operation as normal,\nexcept no low values will be shifted out onto the SDA line (i.e., when the COLL flag is set to '1' it disables\nthe data and acknowledge output from the slave logic). The DIF flag will be set to '1' at the end as a result\nof the internal completion of an unsuccessful transaction. Similarly, when a collision occurs because the\nslave has not been able to transmit NACK bit, it means the address match already happened and APIF\nflag is set as a result. APIF/DIF flags can only generate interrupt whose handlers can be used to check\nfor the collision. Writing a '1' to its bit location will clear the COLL flag. However, the flag is automatically\ncleared if any Start condition (S/Sr) is detected.\nThis flag is intended for systems where address resolution protocol (ARP) is employed. However, a\ndetected collision in non-ARP situations indicates that there has been a protocol violation and should be\ntreated as a bus error."
                },
                {
                  "caption": "Data Interrupt Flag",
                  "mask": "0x80",
                  "name": "DIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when a slave byte transmit or byte receive operation is successfully completed without any\nbus error. The flag can be set with an unsuccessful transaction in case of collision detection (see the\ndescription of the COLL Status bit). Writing a '1' to its bit location will clear the DIF. However, normal use\nof the TWI does not require the DIF flag to be cleared by using this method, since the flag is automatically\ncleared when:"
                },
                {
                  "caption": "Read/Write Direction",
                  "mask": "0x2",
                  "name": "DIR",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is read-only and indicates the current bus direction state. The DIR bit reflects the direction bit\nvalue from the last address packet received from a master TWI device. If this bit is read as '1', a master\nread operation is in progress. Consequently, a '0' indicates that a master write operation is in progress."
                },
                {
                  "caption": "Received Acknowledge",
                  "mask": "0x10",
                  "name": "RXACK",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is read-only and contains the most recently received Acknowledge bit from the master."
                }
              ],
              "description": "Normal TWI operation dictates that the Slave Status register should be regarded purely as a read-only\nregister. Clearing any of the status flags will indirectly be done when accessing the Slave Data\n(TWIn.SDATA) register or the CMD bits in the Slave Control B register (TWIn.SCTRLB)."
            }
          ]
        }
      ]
    },
    {
      "caption": "Universal Synchronous and Asynchronous Receiver and Transmitter",
      "id": "I2108",
      "name": "USART",
      "register_groups": [
        {
          "caption": "Universal Synchronous and Asynchronous Receiver and Transmitter",
          "name": "USART",
          "size": "0x10",
          "registers": [
            {
              "caption": "Baud Rate",
              "reset": "0x0000",
              "name": "BAUD",
              "offset": "0x8",
              "rw": "RW",
              "size": 2,
              "bitfields": null,
              "description": "The USARTn.BAUDL and USARTn.BAUDH register pair represents the 16-bit value, USARTn.BAUD.\nThe low byte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be\naccessed at offset + 0x01.\nOngoing transmissions of the transmitter and receiver will be corrupted if the baud rate is changed.\nWriting this register will trigger an immediate update of the baud rate prescaler. For more information on\nhow to set the baud rate, see Table 23-2."
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x5",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Auto-baud Error Interrupt Enable",
                  "mask": "0x4",
                  "name": "ABEIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the auto-baud error interrupt on interrupt vector RXC. The enabled interrupt\nwill trigger for conditions where the ISFIF flag is set."
                },
                {
                  "caption": "Data Register Empty Interrupt Enable",
                  "mask": "0x20",
                  "name": "DREIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables the Data Register Empty Interrupt (interrupt vector DRE). The enabled interrupt will be\ntriggered when the DREIF in the USART.STATUS register is set."
                },
                {
                  "caption": "Loop-back Mode Enable",
                  "mask": "0x8",
                  "name": "LBME",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables an internal connection between the TxD and RxD pin."
                },
                {
                  "caption": "RS485 Mode internal transmitter",
                  "mask": "0x3",
                  "name": "RS485",
                  "rw": "RW",
                  "values_ref": "USART_RS485",
                  "description": "These bits enable the RS-485 and select the operation mode.\nValue Name Description\n0x0 OFF Disabled.\n0x1 EXT Enables RS-485 mode with control of an external line driver through a dedicated\nTransmit Enable (TE) pin.\n0x2 INT Enables RS-485 mode with control of the internal USART transmitter.\n0x3 - Reserved."
                },
                {
                  "caption": "Receive Complete Interrupt Enable",
                  "mask": "0x80",
                  "name": "RXCIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The bit enables the Receive Complete Interrupt (interrupt vector RXC). The enabled interrupt will be\ntriggered when RXCIF in the USARTn.STATUS register is set."
                },
                {
                  "caption": "Receiver Start Frame Interrupt Enable",
                  "mask": "0x10",
                  "name": "RXSIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the Start Frame Detector to generate an interrupt on interrupt vector RXC\nwhen a start-of-frame condition is detected."
                },
                {
                  "caption": "Transmit Complete Interrupt Enable",
                  "mask": "0x40",
                  "name": "TXCIE",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables the Transmit Complete Interrupt (interrupt vector TXC). The enabled interrupt will be\ntriggered when the TXCIF in the USARTn.STATUS register is set."
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x6",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Multi-processor Communication Mode",
                  "mask": "0x1",
                  "name": "MPCM",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit enables the Multi-Processor Communication mode: the USART receiver ignores all\nthe incoming frames that do not contain address information. The transmitter is unaffected by the MPCM\nsetting. For more detailed information see Multiprocessor Communication Mode."
                },
                {
                  "caption": "Open Drain Mode Enable",
                  "mask": "0x8",
                  "name": "ODME",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' makes the TxD pin to have open-drain functionality. A pull-up resistor is needed to\nprevent the line from floating when a logic one is output to the TxD pin."
                },
                {
                  "caption": "Reciever enable",
                  "mask": "0x80",
                  "name": "RXEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the USART receiver. The receiver will override normal port operation for the\nRxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FERR,\nBUFOVF, and PERR flags. In GENAUTO and LINAUTO mode, disabling the receiver will reset the auto-\nbaud detection logic."
                },
                {
                  "caption": "Receiver Mode",
                  "mask": "0x6",
                  "name": "RXMODE",
                  "rw": "RW",
                  "values_ref": "USART_RXMODE",
                  "description": "In CLK2X mode, the divisor of the baud rate divider will be reduced from 16 to 8 effectively doubling the\ntransfer rate for asynchronous communication modes. For synchronous operation, the CLK2X mode has\nno effect and RXMODE should always be written to zero. RXMODE must be zero when the USART\nCommunication mode is configured to IRCOM. Setting RXMODE to GENAUTO enables generic auto-\nbaud where the SYNC character is valid when eight low and high bits have been registered. In this mode,\nany SYNC character that gives a valid BAUD rate will be accepted. In LINAUTO mode the SYNC\ncharacter is constrained and found valid if each two bits falls within 32 \u00b16 baud samples of the internal\nbaud rate and match data value 0x55. The GENAUTO and LINAUTO mode is only supported for USART\noperated in Asynchronous Slave mode.\n\n\n| Value | Name   | Description                                    |\n| :---- | :----- | :--------------------------------------------- |\n| 0x0   | NORMAL | Normal USART mode, Standard Transmission Speed |\n| 0x1   | CLK2X  | Normal USART mode, Double Transmission Speed   |\n\n\n\n\n| Value | Name    | Description                    |\n| :---- | :------ | :----------------------------- |\n| 0x2   | GENAUTO | Generic Auto-baud mode         |\n| 0x3   | LINAUTO | LIN Constrained Auto-baud mode |\n\n"
                },
                {
                  "caption": "Start Frame Detection Enable",
                  "mask": "0x10",
                  "name": "SFDEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the USART Start Frame Detection mode. The Start Frame detector is able to\nwake-up the system from Idle or Standby Sleep modes when a high (IDLE) to low (START) transition is\ndetected on the RxD line."
                },
                {
                  "caption": "Transmitter Enable",
                  "mask": "0x40",
                  "name": "TXEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' enables the USART transmitter. The transmitter will override normal port operation for\nthe TxD pin when enabled. Disabling the transmitter (writing TXEN to zero) will not become effective until\nongoing and pending transmissions are completed (i.e., when the Transmit Shift register and Transmit\nBuffer register does not contain data to be transmitted). When the transmitter is disabled, it will no longer\noverride the TxDn pin, and the pin direction is set as input automatically by hardware, even if it was\nconfigured as output by the user."
                }
              ],
              "description": null
            },
            {
              "caption": "Control C",
              "reset": "0x03",
              "name": "CTRLC",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "This register description is valid for all modes except Master SPI mode. When the USART\nCommunication mode bits (CMODE) in this register are written to 'MSPI', see Control C - Master SPI\nMode for the correct description."
            },
            {
              "caption": "Debug Control",
              "reset": "0x00",
              "name": "DBGCTRL",
              "offset": "0xB",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Autobaud majority voter bypass",
                  "mask": "0x80",
                  "name": "ABMBP",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The 8-bit value sets the pulse modulation scheme for the transmitter. Setting this register will have effect\nonly if IRCOM mode is selected by a USART. By leaving this register value to zero, 3/16 of the baud rate\nperiod pulse modulation is used. Setting this value from 1 to 254 will give a fixed pulse length coding. The\n8-bit value sets the number of system clock periods for the pulse. The start of the pulse will be\nsynchronized with the rising edge of the baud rate clock. Setting the value to 255 (0xFF) will disable pulse\ncoding, letting the RX and TX signals pass through the IRCOM module unaltered. This enables other\nfeatures through the IRCOM module, such as half duplex USART, Loop-back testing, and USART RX\ninput from an event channel.\nTXPL must be configured before the USART transmitter is enabled (TXEN)."
                },
                {
                  "caption": "Debug Run",
                  "mask": "0x1",
                  "name": "DBGRUN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "\n\n| Value | Description                                                                     |\n| :---- | :------------------------------------------------------------------------------ |\n| 0     | The peripheral is halted in Break Debug mode and ignores events.                |\n| 1     | The peripheral will continue to run in Break Debug mode when the CPU is halted. |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Event Control",
              "reset": "0x00",
              "name": "EVCTRL",
              "offset": "0xC",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "IrDA Event Input Enable",
                  "mask": "0x1",
                  "name": "IREI",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit enables the event source for the IRCOM Receiver. If event input is selected for the IRCOM\nReceiver, the input from the USART's RX pin is automatically disabled."
                }
              ],
              "description": null
            },
            {
              "caption": "Receive Data High Byte",
              "reset": "0x00",
              "name": "RXDATAH",
              "offset": "0x1",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Buffer Overflow",
                  "mask": "0x40",
                  "name": "BUFOVF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The BUFOVF flag indicates data loss due to a receiver buffer full condition. This flag is set if a Buffer\nOverflow condition is detected. A Buffer Overflow occurs when the receive buffer is full (two characters), it\nis a new character waiting in the Receive Shift register, and a new Start bit is detected. This flag is valid\nuntil the receive buffer (USARTn.RXDATAL) is read.\nThis flag is not used in Master SPI mode of operation."
                },
                {
                  "caption": "Receiver Data Register",
                  "mask": "0x1",
                  "name": "DATA8",
                  "rw": "R",
                  "values_ref": null,
                  "description": "When USART receiver is set to LINAUTO mode, this bit indicates if the received data is within the\nresponse space of a LIN frame. If the received data is the protected identifier field, this bit will be read as\nzero. Otherwise, the bit will be read as one. For Receiver mode other than LINAUTO mode, DATA[8]\nholds the ninth data bit in the received character when operating with serial frames with nine data bits."
                },
                {
                  "caption": "Frame Error",
                  "mask": "0x4",
                  "name": "FERR",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The FERR flag indicates the state of the first Stop bit of the next readable frame stored in the receive\nbuffer. The bit is set if the received character had a Frame Error (i.e., when the first Stop bit was zero and\ncleared when the Stop bit of the received data is '1'. This bit is valid until the receive buffer\n(USARTn.RXDATAL) is read. The FERR is not affected by the SBMODE bit in USARTn.CTRLC since the\nreceiver ignores all, except for the first Stop bit.\nThis flag is not used in Master SPI mode of operation."
                },
                {
                  "caption": "Parity Error",
                  "mask": "0x2",
                  "name": "PERR",
                  "rw": "R",
                  "values_ref": null,
                  "description": "If parity checking is enabled and the next character in the receive buffer has a Parity Error this flag is set.\nIf Parity Check is not enabled the PERR will always be read as zero. This bit is valid until the receive\nbuffer (USARTn.RXDATAL) is read. For details on parity calculation refer to Parity . If USART is set to\nLINAUTO mode, this bit will be a Parity Check of the protected identifier field and will be valid when\nDATA[8] in USARTn.RXDATAH reads low.\nThis flag is not used in Master SPI mode of operation."
                },
                {
                  "caption": "Receive Complete Interrupt Flag",
                  "mask": "0x80",
                  "name": "RXCIF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set when there is unread data in the receive buffer and cleared when the receive buffer is\nempty (i.e., does not contain any unread data). When the receiver is disabled, the receive buffer will be\nflushed and consequently, the RXCIF will become zero."
                }
              ],
              "description": "Reading the USARTn.RXDATAH register location will return the contents of the ninth DATA bit plus Status\nbits.\nThe receive buffer consists of a two-level FIFO. The FIFO and the corresponding flags in the high byte of\nUSARTn.RXDATAH will change state whenever the receive buffer is accessed (read). If CHSIZE in\nUSARTn.CTRLC is set to 9BIT Low byte first, read USARTn.RXDATAL before USARTn.RXDATAH.\nOtherwise, always read USARTn.RXDATAH before USARTn.RXDATAL in order to get the correct flags."
            },
            {
              "caption": "Receive Data Low Byte",
              "reset": "0x00",
              "name": "RXDATAL",
              "offset": "0x0",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "RX Data",
                  "mask": "0xff",
                  "name": "DATA",
                  "rw": "R",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "Reading the USARTn.RXDATAL Register will return the contents of the Receive Data Buffer register\n(RXB).\nThe receive buffer consists of a two-level FIFO. The FIFO and the corresponding flags in the high byte of\nRXDATA will change state whenever the receive buffer is accessed (read). If CHSIZE in USARTn.CTRLC\nis set to 9BIT Low byte first, read USARTn.RXDATAL before USARTn.RXDATAH. Otherwise, always read\nUSARTn.RXDATAH before USARTn.RXDATAL in order to get the correct flags."
            },
            {
              "caption": "IRCOM Receiver Pulse Length Control",
              "reset": "0x00",
              "name": "RXPLCTRL",
              "offset": "0xE",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Receiver Pulse Lenght",
                  "mask": "0x7f",
                  "name": "RXPL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The 8-bit value sets the filter coefficient for the IRCOM transceiver. Setting this register will only have\neffect if IRCOM mode is selected by a USART.\nBy leaving this register value to zero, filtering is disabled. Setting this value between 0x01 and 0xFF will\nenable filtering, where x+1 equal samples are required for the pulse to be accepted.\nRXPL must be configured before USART receiver is enabled (RXEN)."
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x4",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Break Detected Flag",
                  "mask": "0x2",
                  "name": "BDF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is intended for USART configured to LINAUTO receive mode. The break detector has a fixed\nthreshold of 11 bits low for a Break to be detected. The BDF bit is set after a valid BREAK and SYNC\ncharacter is detected. The bit is automatically cleared when next data is received. The bit will behave\nidentically when USART is set to GENAUTO mode. In NORMAL or CLK2X receive mode, the BDF bit is\nunused.\nThis bit is cleared by writing a '1' to it."
                },
                {
                  "caption": "Data Register Empty Flag",
                  "mask": "0x20",
                  "name": "DREIF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The DREIF indicates if the transmit buffer (TXDATA) is ready to receive new data. The flag is set to '1'\nwhen the transmit buffer is empty and is '0' when the transmit buffer contains data to be transmitted that\nhas not yet been moved into the Shift register. DREIF is set after a Reset to indicate that the transmitter is\nready. Always write this bit to '0' when writing the STATUS register.\nDREIF is cleared to '0' by writing TXDATAL. When interrupt-driven data transmission is used, the Data\nRegister Empty interrupt routine must either write new data to TXDATA in order to clear DREIF or disable\nthe Data Register Empty interrupt. If not, a new interrupt will occur directly after the return from the\ncurrent interrupt."
                },
                {
                  "caption": "Inconsistent Sync Field Interrupt Flag",
                  "mask": "0x8",
                  "name": "ISFIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is set when the auto-baud is enabled and the sync field bit time are too fast or too slow to give a\nvalid baud setting. It will also be set when USART is set to LINAUTO mode and the SYNC character differ\nfrom data value 0x55.\nWriting a '1' to this bit will clear the flag and bring the USART back to Idle state."
                },
                {
                  "caption": "Receive Complete Interrupt Flag",
                  "mask": "0x80",
                  "name": "RXCIF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This flag is set to '1' when there is unread data in the receive buffer and cleared when the receive buffer\nis empty (i.e., does not contain any unread data). When the receiver is disabled, the receive buffer will be\nflushed and consequently, the RXCIF will become zero.\nWhen interrupt-driven data reception is used, the receive complete interrupt routine must read the\nreceived data from RXDATA in order to clear the RXCIF. If not, a new interrupt will occur directly after the\nreturn from the current interrupt."
                },
                {
                  "caption": "Receive Start Interrupt",
                  "mask": "0x10",
                  "name": "RXSIF",
                  "rw": "R",
                  "values_ref": null,
                  "description": "The RXSIF flag indicates a valid Start condition on RxD line. The flag is set when the system is in\nstandby modes and a high (IDLE) to low (START) valid transition is detected on the RxD line. If the start\ndetection is not enabled, the RXSIF will always be read as zero. This flag can only be cleared by writing a\n'1' to its bit location. This flag is not used in the Master SPI mode operation."
                },
                {
                  "caption": "Transmit Interrupt Flag",
                  "mask": "0x40",
                  "name": "TXCIF",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This flag is set when the entire frame in the Transmit Shift register has been shifted out and there are no\nnew data in the transmit buffer (TXDATA).\nThis flag is automatically cleared when the transmit complete interrupt vector is executed. The flag can\nalso be cleared by writing a '1' to its bit location."
                },
                {
                  "caption": "Wait For Break",
                  "mask": "0x1",
                  "name": "WFB",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' will register the next low and high transition on RxD line as a Break character. This\ncan be used to wait for a Break character of arbitrary width. Combined with USART set to GENAUTO\nmode, this allows the user to set any BAUD rate through BREAK and SYNC as long as it falls within the\nvalid range of the USARTn.BAUD register. This bit will always read '0'."
                }
              ],
              "description": null
            },
            {
              "caption": "Transmit Data High Byte",
              "reset": "0x00",
              "name": "TXDATAH",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Transmit Data Register (CHSIZE=9bit)",
                  "mask": "0x1",
                  "name": "DATA8",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "This bit is used when CHSIZE=9BIT in USARTn.CTRLC."
                }
              ],
              "description": "USARTn.TXDATAH holds the ninth data bit in the character to be transmitted when operating with serial\nframes with nine data bits. When used this bit must be written before writing to USARTn.TXDATAL except\nif CHSIZE in USARTn.CTRLC is set to 9BIT Low byte first where USARTn.TXDATAL should be written\nfirst.\nThis bit is unused in Master SPI mode of operation."
            },
            {
              "caption": "Transmit Data Low Byte",
              "reset": "0x00",
              "name": "TXDATAL",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Transmit Data Register",
                  "mask": "0xff",
                  "name": "DATA",
                  "rw": "RW",
                  "values_ref": null,
                  "description": ""
                }
              ],
              "description": "The Transmit Data Buffer (TXB) register will be the destination for data written to the USARTn.TXDATAL\nregister location.\nFor 5-, 6-, or 7-bit characters the upper unused bits will be ignored by the transmitter and set to zero by\nthe receiver.\nThe transmit buffer can only be written when the DREIF flag in the USARTn.STATUS register is set. Data\nwritten to DATA when the DREIF flag is not set will be ignored by the USART transmitter. When data is\nwritten to the transmit buffer, and the transmitter is enabled, the transmitter will load the data into the\nTransmit Shift register when the Shift register is empty. The data is then transmitted on the TxD pin."
            },
            {
              "caption": "IRCOM Transmitter Pulse Length Control",
              "reset": "0x00",
              "name": "TXPLCTRL",
              "offset": "0xD",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Transmit pulse length",
                  "mask": "0xff",
                  "name": "TXPL",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The 8-bit value sets the pulse modulation scheme for the transmitter. Setting this register will have effect\nonly if IRCOM mode is selected by a USART. By leaving this register value to zero, 3/16 of the baud rate\nperiod pulse modulation is used. Setting this value from 1 to 254 will give a fixed pulse length coding. The\n8-bit value sets the number of system clock periods for the pulse. The start of the pulse will be\nsynchronized with the rising edge of the baud rate clock. Setting the value to 255 (0xFF) will disable pulse\ncoding, letting the RX and TX signals pass through the IRCOM module unaltered. This enables other\nfeatures through the IRCOM module, such as half duplex USART, Loop-back testing, and USART RX\ninput from an event channel.\nTXPL must be configured before the USART transmitter is enabled (TXEN)."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "User Row",
      "id": "I2601",
      "name": "USERROW",
      "register_groups": [
        {
          "caption": "User Row",
          "name": "USERROW",
          "size": "0x20",
          "registers": [
            {
              "caption": "User Row Byte 0",
              "reset": null,
              "name": "USERROW0",
              "offset": "0x00",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 1",
              "reset": null,
              "name": "USERROW1",
              "offset": "0x01",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 2",
              "reset": null,
              "name": "USERROW2",
              "offset": "0x02",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 3",
              "reset": null,
              "name": "USERROW3",
              "offset": "0x03",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 4",
              "reset": null,
              "name": "USERROW4",
              "offset": "0x04",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 5",
              "reset": null,
              "name": "USERROW5",
              "offset": "0x05",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 6",
              "reset": null,
              "name": "USERROW6",
              "offset": "0x06",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 7",
              "reset": null,
              "name": "USERROW7",
              "offset": "0x07",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 8",
              "reset": null,
              "name": "USERROW8",
              "offset": "0x08",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 9",
              "reset": null,
              "name": "USERROW9",
              "offset": "0x09",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 10",
              "reset": null,
              "name": "USERROW10",
              "offset": "0x0A",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 11",
              "reset": null,
              "name": "USERROW11",
              "offset": "0x0B",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 12",
              "reset": null,
              "name": "USERROW12",
              "offset": "0x0C",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 13",
              "reset": null,
              "name": "USERROW13",
              "offset": "0x0D",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 14",
              "reset": null,
              "name": "USERROW14",
              "offset": "0x0E",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 15",
              "reset": null,
              "name": "USERROW15",
              "offset": "0x0F",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 16",
              "reset": null,
              "name": "USERROW16",
              "offset": "0x10",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 17",
              "reset": null,
              "name": "USERROW17",
              "offset": "0x11",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 18",
              "reset": null,
              "name": "USERROW18",
              "offset": "0x12",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 19",
              "reset": null,
              "name": "USERROW19",
              "offset": "0x13",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 20",
              "reset": null,
              "name": "USERROW20",
              "offset": "0x14",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 21",
              "reset": null,
              "name": "USERROW21",
              "offset": "0x15",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 22",
              "reset": null,
              "name": "USERROW22",
              "offset": "0x16",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 23",
              "reset": null,
              "name": "USERROW23",
              "offset": "0x17",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 24",
              "reset": null,
              "name": "USERROW24",
              "offset": "0x18",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 25",
              "reset": null,
              "name": "USERROW25",
              "offset": "0x19",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 26",
              "reset": null,
              "name": "USERROW26",
              "offset": "0x1A",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 27",
              "reset": null,
              "name": "USERROW27",
              "offset": "0x1B",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 28",
              "reset": null,
              "name": "USERROW28",
              "offset": "0x1C",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 29",
              "reset": null,
              "name": "USERROW29",
              "offset": "0x1D",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 30",
              "reset": null,
              "name": "USERROW30",
              "offset": "0x1E",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            },
            {
              "caption": "User Row Byte 31",
              "reset": null,
              "name": "USERROW31",
              "offset": "0x1F",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Undocumented"
            }
          ]
        }
      ]
    },
    {
      "caption": "Virtual Ports",
      "id": "I2103",
      "name": "VPORT",
      "register_groups": [
        {
          "caption": "Virtual Ports",
          "name": "VPORT",
          "size": "0x4",
          "registers": [
            {
              "caption": "Data Direction",
              "reset": null,
              "name": "DIR",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Writing to the Virtual PORT registers has the same effect as writing to the regular registers, but allows for\nmemory-specific instructions, such as bit-manipulation instructions, which are not valid for the extended\nI/O memory space where the regular PORT registers reside."
            },
            {
              "caption": "Input Value",
              "reset": null,
              "name": "IN",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Writing to the Virtual PORT registers has the same effect as writing to the regular registers, but allows for\nmemory-specific instructions, such as bit-manipulation instructions, which are not valid for the extended\nI/O memory space where the regular PORT registers reside."
            },
            {
              "caption": "Interrupt Flags",
              "reset": "0x00",
              "name": "INTFLAGS",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Pin Interrupt",
                  "mask": "0xff",
                  "name": "INT",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "The INT flag is set when a pin change/state matches the pin's input sense configuration, and the pin is\nconfigured as source for port interrupt.\nWriting a '1' to this flag's bit location will clear the flag.\nFor enabling and executing the interrupt, refer to PORT_PINnCTRL.ISC."
                }
              ],
              "description": "Writing to the Virtual PORT registers has the same effect as writing to the regular registers, but allows for\nmemory-specific instructions, such as bit-manipulation instructions, which are not valid for the extended\nI/O memory space where the regular PORT registers reside."
            },
            {
              "caption": "Output Value",
              "reset": null,
              "name": "OUT",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": null,
              "description": "Writing to the Virtual PORT registers has the same effect as writing to the regular registers, but allows for\nmemory-specific instructions, such as bit-manipulation instructions, which are not valid for the extended\nI/O memory space where the regular PORT registers reside."
            }
          ]
        }
      ]
    },
    {
      "caption": "Voltage reference",
      "id": "I2601",
      "name": "VREF",
      "register_groups": [
        {
          "caption": "Voltage reference",
          "name": "VREF",
          "size": "0x2",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "ADC0 reference select",
                  "mask": "0x70",
                  "name": "ADC0REFSEL",
                  "rw": "RW",
                  "values_ref": "VREF_ADC0REFSEL",
                  "description": "These bits select the reference voltage for the ADC0.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | 0.55V       |\n| 0x1   | 1.1V        |\n| 0x2   | 2.5V        |\n| 0x3   | 4.3V        |\n| 0x4   | 1.5V        |\n| other | Reserved    |\n\n"
                },
                {
                  "caption": "DAC0/AC0 reference select",
                  "mask": "0x7",
                  "name": "DAC0REFSEL",
                  "rw": "RW",
                  "values_ref": "VREF_DAC0REFSEL",
                  "description": "These bits select the reference voltage for the AC0.\n\n\n| Value | Description |\n| :---- | :---------- |\n| 0x0   | 0.55V       |\n| 0x1   | 1.1V        |\n| 0x2   | 2.5V        |\n| 0x3   | 4.3V        |\n| 0x4   | 1.5V        |\n| other | Reserved    |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "ADC0 reference enable",
                  "mask": "0x2",
                  "name": "ADC0REFEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit forces the voltage reference for the ADC0 to be running, even if it is not requested.\nWriting a '0' to this bit allows automatic enable/disable of the reference source by the peripheral."
                },
                {
                  "caption": "DAC0/AC0 reference enable",
                  "mask": "0x1",
                  "name": "DAC0REFEN",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing a '1' to this bit forces the voltage reference for the AC0 to be running, even if it is not requested.\nWriting a '0' to this bit allows automatic enable/disable of the reference source by the peripheral."
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "caption": "Watch-Dog Timer",
      "id": "I2127",
      "name": "WDT",
      "register_groups": [
        {
          "caption": "Watch-Dog Timer",
          "name": "WDT",
          "size": "0x2",
          "registers": [
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x0",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Period",
                  "mask": "0xf",
                  "name": "PERIOD",
                  "rw": "RW",
                  "values_ref": "WDT_PERIOD",
                  "description": "Writing a non-zero value to this bit enables the WDT, and selects the time-out period in Normal mode\naccordingly. In Window mode, these bits select the duration of the open window.\nThe bits are optionally lock-protected:\n* If LOCK in WDT.STATUS is '1', all bits are change-protected (Access = R)\n* If LOCK in WDT.STATUS is '0', all bits can be changed (Access = R/W)\n\n\n| Value | Name  | Description |\n| :---- | :---- | :---------- |\n| 0x0   | OFF   | -           |\n| 0x1   | 8CLK  | 0.008s      |\n| 0x2   | 16CLK | 0.016s      |\n| 0x3   | 32CLK | 0.032s      |\n\n\n\n\n| Value | Name   | Description |\n| :---- | :----- | :---------- |\n| 0x4   | 64CLK  | 0.064s      |\n| 0x5   | 128CLK | 0.128s      |\n| 0x6   | 256CLK | 0.256s      |\n| 0x7   | 512CLK | 0.512s      |\n| 0x8   | 1KCLK  | 1.0s        |\n| 0x9   | 2KCLK  | 2.0s        |\n| 0xA   | 4KCLK  | 4.1s        |\n| 0xB   | 8KCLK  | 8.2s        |\n| other | -      | Reserved    |\n\n"
                },
                {
                  "caption": "Window",
                  "mask": "0xf0",
                  "name": "WINDOW",
                  "rw": "RW",
                  "values_ref": "WDT_WINDOW",
                  "description": "Writing a non-zero value to these bits enables the Window mode, and selects the duration of the closed\nperiod accordingly.\nThe bits are optionally lock-protected:\n* If LOCK bit in WDT.STATUS is '1', all bits are change-protected (Access = R)\n* If LOCK bit in WDT.STATUS is '0', all bits can be changed (Access = R/W)\n\n\n| Value | Name   | Description |\n| :---- | :----- | :---------- |\n| 0x0   | OFF    | -           |\n| 0x1   | 8CLK   | 0.008s      |\n| 0x2   | 16CLK  | 0.016s      |\n| 0x3   | 32CLK  | 0.032s      |\n| 0x4   | 64CLK  | 0.064s      |\n| 0x5   | 128CLK | 0.128s      |\n| 0x6   | 256CLK | 0.256s      |\n| 0x7   | 512CLK | 0.512s      |\n| 0x8   | 1KCLK  | 1.024s      |\n| 0x9   | 2KCLK  | 2.048s      |\n| 0xA   | 4KCLK  | 4.096s      |\n| 0xB   | 8KCLK  | 8.192s      |\n| other | -      | Reserved    |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Status",
              "reset": "0x00",
              "name": "STATUS",
              "offset": "0x1",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Lock enable",
                  "mask": "0x80",
                  "name": "LOCK",
                  "rw": "RW",
                  "values_ref": null,
                  "description": "Writing this bit to '1' write protects the WDT.CTRLA register.\nIt is only possible to write this bit to '1'. This bit can only be cleared in Debug mode.\nIf the PERIOD bits in WDT.CTRLA are different from zero after boot code, the lock will automatically be\nset.\nThis bit is under CCP."
                },
                {
                  "caption": "Syncronization busy",
                  "mask": "0x1",
                  "name": "SYNCBUSY",
                  "rw": "R",
                  "values_ref": null,
                  "description": "This bit is set after writing to the WDT.CTRLA register while the data is being synchronized from the\nsystem clock domain to the WDT clock domain.\nThis bit is cleared by the system after the synchronization is finished.\nThis bit is not under CCP.\nRelated Links\nSynchronization\nConfiguration Change Protection"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    },
    {
      "id": "UPDI",
      "caption": "Unified Program and Debug Interface",
      "name": "UPDI",
      "register_groups": [
        {
          "caption": "Unified Program and Debug Interface",
          "name": "UPDI",
          "size": "0x0D",
          "registers": [
            {
              "caption": "Status A",
              "reset": "0x20",
              "name": "STATUSA",
              "offset": "0x0",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "UPDI Revision",
                  "mask": "0xf0",
                  "name": "UPDIREV",
                  "rw": "R",
                  "description": "These bits are read-only and contain the revision of the current UPDI implementation."
                }
              ],
              "description": null
            },
            {
              "caption": "Status B",
              "reset": "0x00",
              "name": "STATUSB",
              "offset": "0x1",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "UPDI Error Signature",
                  "mask": "0x7",
                  "name": "PESIG",
                  "rw": "R",
                  "description": "These bits describe the UPDI Error Signature and are set when an internal UPDI error condition occurs.\nThe PESIG field is cleared on a read from the debugger.\nTable 30-7. Valid Error Signatures\nPESIG[2:0] Error Type Error Description\n0x0 No error No error detected (Default)\n0x1 Parity error Wrong sampling of the parity bit\n0x2 Frame error Wrong sampling of frame Stop bits\n0x3 Access Layer Time-out Error UPDI can get no data or response from the Access layer.\nExamples of error cases are system domain in Sleep or\nsystem domain Reset.\n0x4 Clock Recovery error Wrong sampling of frame Start bit\n0x5 - Reserved\n0x6 Reserved Reserved\n0x7 Contention error Signalize Driving Contention on the UPDI RXD/TXD line"
                }
              ],
              "description": null
            },
            {
              "caption": "Control A",
              "reset": "0x00",
              "name": "CTRLA",
              "offset": "0x2",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Inter-Byte Delay Enable",
                  "mask": "0x80",
                  "name": "IBDLY",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit enables a fixed inter-byte delay between each data byte transmitted from the UPDI\nwhen doing multi-byte LD(S). The fixed length is two IDLE characters. Before the first transmitted byte,the\nregular GT delay used for direction change will be used."
                },
                {
                  "caption": "Parity Disable",
                  "mask": "0x20",
                  "name": "PARD",
                  "rw": "RW",
                  "description": "Writing this bit to '1' will disable parity detection in the UPDI by ignoring the Parity bit. This feature is\nrecommended only during testing."
                },
                {
                  "caption": "Disable Time-Out Detection",
                  "mask": "0x10",
                  "name": "DTD",
                  "rw": "RW",
                  "description": "Setting this bit disables the time-out detection on the PHY layer, which requests a response from the ACC\nlayer within a specified time (65536 UPDI clock cycles)."
                },
                {
                  "caption": "Response Signature Disable",
                  "mask": "0x8",
                  "name": "RSD",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit will disable any response signatures generated by the UPDI. This is to reduce the\nprotocol overhead to a minimum when writing large blocks of data to the NVM space. Disabling the\nResponse Signature should be used with caution, and only when the delay experienced by the UPDI\nwhen accessing the system bus is predictable, otherwise loss of data may occur."
                },
                {
                  "caption": "Guard Time Value",
                  "mask": "0x7",
                  "name": "GTVAL",
                  "rw": "RW",
                  "description": "This bit field selects the Guard Time Value that will be used by the UPDI when the transmission mode\nswitches from RX to TX. The guard time is equal to the baud rate used in 1-Wire mode.\n\n\n| Value | Description                           |\n| :---- | :------------------------------------ |\n| 0x0   | UPDI Guard Time: 128 cycles (default) |\n| 0x1   | UPDI Guard Time: 64 cycles            |\n| 0x2   | UPDI Guard Time: 32 cycles            |\n| 0x3   | UPDI Guard Time: 16 cycles            |\n| 0x4   | UPDI Guard Time: 8 cycles             |\n| 0x5   | UPDI Guard Time: 4 cycles             |\n| 0x6   | UPDI Guard Time: 2 cycles             |\n| 0x7   | GT off (no extra Idle bits inserted)  |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Disable Nack Response",
                  "mask": "0x10",
                  "name": "NACKDIS",
                  "rw": "RW",
                  "description": "Writing this bit to '1' disables the NACK signature sent by the UPDI if a System Reset is issued during an\nongoing LD(S) and ST(S) operation."
                },
                {
                  "caption": "Collision and Contention Detection Disable",
                  "mask": "0x8",
                  "name": "CCDETDIS",
                  "rw": "RW",
                  "description": "If this bit is written to '0', contention detection is enabled for the 1W mode. This means that the UPDI can\ndetect a collision in an ongoing 1-Wire transmission."
                },
                {
                  "caption": "UPDI Disalbe",
                  "mask": "0x4",
                  "name": "UPDIDIS",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit disables the UPDI PHY interface. The clock request from the UPDI is lowered, and\nthe UPDI is reset. All UPDI PHY configurations and KEYs will be reset when the UPDI is disabled."
                }
              ],
              "description": null
            },
            {
              "caption": "Control B",
              "reset": "0x00",
              "name": "CTRLB",
              "offset": "0x3",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Disable Nack Response",
                  "mask": "0x10",
                  "name": "NACKDIS",
                  "rw": "RW",
                  "description": "Writing this bit to '1' disables the NACK signature sent by the UPDI if a System Reset is issued during an\nongoing LD(S) and ST(S) operation."
                },
                {
                  "caption": "Collision and Contention Detection Disable",
                  "mask": "0x8",
                  "name": "CCDETDIS",
                  "rw": "RW",
                  "description": "If this bit is written to '0', contention detection is enabled for the 1W mode. This means that the UPDI can\ndetect a collision in an ongoing 1-Wire transmission."
                },
                {
                  "caption": "UPDI Disable",
                  "mask": "0x4",
                  "name": "UPDIDIS",
                  "rw": "RW",
                  "description": "Writing a '1' to this bit disables the UPDI PHY interface. The clock request from the UPDI is lowered, and\nthe UPDI is reset. All UPDI PHY configurations and KEYs will be reset when the UPDI is disabled."
                }
              ],
              "description": null
            },
            {
              "caption": "ASI Key Status",
              "reset": "0x00",
              "name": "ASI_KEY_STATUS",
              "offset": "0x7",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "User Row Write Key Status",
                  "mask": "0x20",
                  "name": "UROWWRITE",
                  "rw": "RW",
                  "description": "This bit is set to '1' if the UROWWRITE KEY is active. Otherwise, this bit reads as zero."
                },
                {
                  "caption": "NVM Programming Key Status",
                  "mask": "0x10",
                  "name": "NVMPROG",
                  "rw": "R",
                  "description": "This bit is set to '1' if the NVMPROG KEY is active. This bit is automatically reset after the programming\nsequence is done. Otherwise, this bit reads as zero."
                },
                {
                  "caption": "Chip Erase Key Status",
                  "mask": "0x8",
                  "name": "CHIPERASE",
                  "rw": "R",
                  "description": "This bit is set to '1' if the CHIPERASE KEY is active. This bit will automatically be reset when the Chip\nErase sequence is completed. Otherwise, this bit reads as zero."
                }
              ],
              "description": null
            },
            {
              "caption": "ASI Reset Request",
              "reset": "0x00",
              "name": "ASI_RESET_REQ",
              "offset": "0x8",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "Reset Request",
                  "mask": "0xff",
                  "name": "RSTREQ",
                  "rw": "RW",
                  "description": "A Reset is signalized to the System when writing the Reset signature 0x59h to this address.\nWriting any other signature to this register will clear the Reset.\nWhen reading this register, reading bit RSTREQ[0] will tell if the UPDI is holding an active Reset on the\nsystem. If this bit is '1', the UPDI has an active Reset request to the system. All other bits will read as '0'.\nThe UPDI will not be reset when issuing a System Reset from this register."
                }
              ],
              "description": null
            },
            {
              "caption": "ASI Control A",
              "reset": "0x03",
              "name": "ASI_CTRLA",
              "offset": "0x9",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "UPDI Clock Divider Select",
                  "mask": "0x3",
                  "name": "UPDICLKSEL",
                  "rw": "RW",
                  "description": "Writing these bits select the UPDI clock output frequency. Default setting after Reset and enable is 4\nMHz. Any other clock output selection is only recommended when the BOD is at the highest level. For all\nother BOD settings, the default 4 MHz selection is recommended.\n\n\n| Value | Description                        |\n| :---- | :--------------------------------- |\n| 0x0   | Reserved                           |\n| 0x1   | 16 MHz UPDI clock                  |\n| 0x2   | 8 MHz UPDI clock                   |\n| 0x3   | 4 MHz UPDI clock (Default Setting) |\n\n"
                }
              ],
              "description": null
            },
            {
              "caption": "ASI System Control A",
              "reset": "0x00",
              "name": "ASI_SYS_CTRLA",
              "offset": "0xA",
              "rw": "RW",
              "size": 1,
              "bitfields": [
                {
                  "caption": "User Row Programming Done",
                  "mask": "0x2",
                  "name": "UROWWRITE_FINAL",
                  "rw": "RW",
                  "description": "This bit should be written through the UPDI when the user row data has been written to the RAM. Writing\nthis bit will start the process of programming the user row data to the Flash.\nIf this bit is written before the User Row code is written to RAM by the UPDI, the CPU will progress\nwithout the written data.\nThis bit is only writable if the Userrow-write KEY is successfully decoded."
                },
                {
                  "caption": "Request System Clock",
                  "mask": "0x1",
                  "name": "CLKREQ",
                  "rw": "RW",
                  "description": "If this bit is written to '1', the ASI is requesting the system clock, independent of system Sleep modes.\nThis makes it possible for the UPDI to access the ACC layer, also if the system is in Sleep mode.\nWriting a zero to this bit will lower the clock request.\nThis bit will be reset when the UPDI is disabled.\nThis bit is set by default when the UPDI is enabled in any mode (Fuse, 12V)."
                }
              ],
              "description": null
            },
            {
              "caption": " ASI System Status",
              "reset": "0x01",
              "name": "ASI_SYS_STATUS",
              "offset": "0xb",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "System Reset Active",
                  "mask": "0x20",
                  "name": "RSTSYS",
                  "rw": "R",
                  "description": "If this bit is set, there is an active Reset on the system domain. If this bit is cleared, the system is not in\nReset.\nThis bit is cleared on read.\nA Reset held from the ASI_RESET_REQ register will also affect this bit."
                },
                {
                  "caption": "System Domain in Sleep",
                  "mask": "0x10",
                  "name": "INSLEEP",
                  "rw": "R",
                  "description": "If this bit is set, the system domain is in IDLE or deeper Sleep mode. If this bit is cleared, the system is\nnot in Sleep."
                },
                {
                  "caption": "Start NVM Programming",
                  "mask": "0x8",
                  "name": "NVMPROG",
                  "rw": "R",
                  "description": "If this bit is set, NVM Programming can start from the UPDI.\nWhen the UPDI is done, it must reset the system through the UPDI Reset register."
                },
                {
                  "caption": "Start User Row Programming",
                  "mask": "0x4",
                  "name": "UROWPROG",
                  "rw": "R",
                  "description": "If this bit is set, User Row Programming can start from the UPDI.\nWhen the UPDI is done, it must write the UROWWRITE_FINAL bit in ASI_SYS_CTRLA."
                },
                {
                  "caption": "NVM Lock Status",
                  "mask": "0x1",
                  "name": "LOCKSTATUS",
                  "rw": "R",
                  "description": "If this bit is set, the device is locked. If a Chip Erase is done, and the Lockbits are cleared, this bit will\nread as zero."
                }
              ],
              "description": null
            },
            {
              "caption": "ASI CRC Status",
              "reset": "0x00",
              "name": "ASI_CRC_STATUS",
              "offset": "0xc",
              "rw": "R",
              "size": 1,
              "bitfields": [
                {
                  "caption": "CRC Execution Status",
                  "mask": "0x7",
                  "name": "CRC_STATUS",
                  "rw": "R",
                  "description": "These bits signalize the status of the CRC conversion. The bits are one-hot encoded.\n\n\n| Value | Description                             |\n| :---- | :-------------------------------------- |\n| 0x0   | Not enabled                             |\n| 0x1   | CRC enabled, busy                       |\n| 0x2   | CRC enabled, done with OK signature     |\n| 0x4   | CRC enabled, done with FAILED signature |\n| Other | Reserved                                |\n\n"
                }
              ],
              "description": null
            }
          ]
        }
      ]
    }
  ]
}
